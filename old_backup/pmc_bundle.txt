===== BEGIN FILE: pmc.ps1 =====
# Command line argument parsing must appear before any executable statements
param(
    [switch]$NoInteractive,
    [switch]$Debug1,
    [switch]$Debug2,
    [switch]$Debug3,
    [string]$Config = $null,
    [string]$SecurityLevel = 'balanced',
    [switch]$Help
)

# Interactive mode is enabled by default, use -NoInteractive to disable
$Interactive = -not $NoInteractive.IsPresent

Set-StrictMode -Version Latest

$ErrorActionPreference = 'Continue'

if ($Help) {
    Write-Host @"
PMC - Project Management Console

Usage: pmc.ps1 [options]

Options:
  -NoInteractive     Disable enhanced interactive mode (enabled by default)
  -Debug1            Enable basic debug logging (commands, errors)
  -Debug2            Enable detailed debug logging (parsing, validation, storage)
  -Debug3            Enable verbose debug logging (UI rendering, completion details)
  -Config <path>     Use specific config file path
  -SecurityLevel <level>  Set security level: permissive, balanced, strict (default: balanced)
  -Help              Show this help message

Interactive Features:
  - Tab: Visual completion menus with arrow key navigation
  - Ghost text: Real-time parameter hints during typing
  - Professional keyboard shortcuts (Ctrl+A, Ctrl+E, etc.)
  - Command history with Up/Down arrows and Ctrl+R search

Commands:
  help               Show available commands
  exit, quit, q      Exit PMC

Examples:
  pmc.ps1 -Interactive -Debug2
  pmc.ps1 -SecurityLevel strict -Debug1
"@ -ForegroundColor Green
    exit 0
}

$root = Split-Path -Parent $MyInvocation.MyCommand.Path
$moduleManifest = Join-Path $root 'module/Pmc.Strict/Pmc.Strict.psd1'
if (-not (Test-Path $moduleManifest)) { Write-Host "Strict module not found at $moduleManifest" -ForegroundColor Red; exit 1 }

try {
    Import-Module $moduleManifest -Force -ErrorAction Stop
    Write-Host "✓ PMC module loaded successfully" -ForegroundColor Green
} catch {
    Write-Host "✗ Failed to import PMC module: $_" -ForegroundColor Red
    exit 1
}

# Verify core functions are available
if (-not (Get-Command Invoke-PmcCommand -ErrorAction SilentlyContinue)) {
    Write-Host "✗ PMC core functions not available after import" -ForegroundColor Red
    exit 1
}
if (-not (Get-Command Test-PmcInputSafety -ErrorAction SilentlyContinue)) {
    Write-Host "✗ PMC security functions not available after import" -ForegroundColor Red
    exit 1
}

# Simple config provider that reads/writes ./config.json next to this script
$configPath = if ($Config) { $Config } else { Join-Path $root 'config.json' }

function Get-StrictConfig {
    if (Test-Path $configPath) {
        return (Get-Content $configPath -Raw | ConvertFrom-Json -AsHashtable)
    }
    # Enhanced defaults with new systems
    return @{
        Display = @{
            Theme = @{ Enabled=$true; Hex='#33aaff'; UseTrueColor=$true; Global=$true; PreserveAlerts=$true }
            Icons = @{ Mode='emoji' } # 'emoji' or 'ascii'
            RefreshOnCommand = $true
            ShowBannerOnRefresh = $true
        }
        Behavior = @{ SafePathsStrict=$true; EnableCsvLedger=$true; WhatIf=$false; MaxUndoLevels=10; MaxBackups=3; ReportRichCsv=$false }
        Paths = @{ AllowedWriteDirs = @() }
        Debug = @{ Level=0; LogPath='debug.log'; MaxSize='10MB'; RedactSensitive=$true; IncludePerformance=$false }
        Security = @{ AllowedWritePaths=@('./','./reports/','./backups/','./exports/','./excel_input/','./excel_output/'); MaxFileSize='100MB'; MaxMemoryUsage='500MB'; ScanForSensitiveData=$true; RequirePathWhitelist=$true; AuditAllFileOps=$true }
        Interactive = @{ Enabled=$false; GhostText=$true; CompletionMenus=$true }
        Excel = @{
            SourceFolder = './excel_input'
            DestinationPath = './excel_output.xlsm'
            SourceSheet = 'SVI-CAS'
            DestSheet = 'Output'
            ID2FieldName = 'CASNumber'
            AllowedExtensions = @('.xlsm', '.xlsx')
            MaxFileSize = '50MB'
            Mappings = @(
                @{ Field='RequestDate';    SourceCell='W23'; DestCell='B2'  }
                @{ Field='AuditType';      SourceCell='W78'; DestCell='B3'  }
                @{ Field='AuditorName';    SourceCell='W10'; DestCell='B4'  }
                @{ Field='TPName';         SourceCell='W3';  DestCell='B5'  }
                @{ Field='TPEmailAddress'; SourceCell='X3';  DestCell='B6'  }
                @{ Field='TPPhoneNumber';  SourceCell='Y3';  DestCell='B7'  }
                @{ Field='TaxID';          SourceCell='W13'; DestCell='B8'  }
                @{ Field='CASNumber';      SourceCell='G17'; DestCell='B9'  }
            )
        }
    }
}

function Set-StrictConfig($cfg) { $cfg | ConvertTo-Json -Depth 10 | Set-Content -Path $configPath -Encoding UTF8 }

Set-PmcConfigProvider -Get { Get-StrictConfig } -Set { param($cfg) Set-StrictConfig $cfg }

# Initialize systems based on command line flags (after config provider is set)
$debugLevel = 0
if ($Debug3) { $debugLevel = 3 }
elseif ($Debug2) { $debugLevel = 2 }
elseif ($Debug1) { $debugLevel = 1 }

Initialize-PmcDebugSystem -Level $debugLevel
# Now that config provider is ready, update debug settings from config
try { Update-PmcDebugFromConfig } catch { Write-Host "Note: Update-PmcDebugFromConfig not available" -ForegroundColor Yellow }
if ($debugLevel -gt 0) { Write-Host "✓ Debug logging enabled (Level $debugLevel)" -ForegroundColor Green }

# Initialize security system from config, then apply requested profile
Initialize-PmcSecuritySystem
# Now that config provider is ready, update security settings from config
try { Update-PmcSecurityFromConfig } catch { Write-Host "Note: Update-PmcSecurityFromConfig not available" -ForegroundColor Yellow }

# Set security level
Set-PmcSecurityLevel -Level $SecurityLevel
Write-Host "✓ Security level: $SecurityLevel" -ForegroundColor Green

# Initialize theme/display system (capabilities + styles)
Initialize-PmcThemeSystem

function Show-StrictHelp {
    if (Get-Command Pmc-ShowHelpUI -ErrorAction SilentlyContinue) {
        Pmc-ShowHelpUI
    } else {
        $rows = Get-PmcHelp
        foreach ($r in ($rows | Sort-Object Domain, Action)) {
            Write-Host ("  {0} {1}  {2}" -f $r.Domain, $r.Action, $r.Description)
        }
    }
}

function Show-SystemStatus {
    Write-PmcStyled -Style 'Title' -Text "`nPMC System Status:"

    # Debug status
    $debugStatus = Get-PmcDebugStatus
    Write-PmcStyled -Style 'Body' -Text "  Debug: " -NoNewline
    if ($debugStatus.Enabled) {
        Write-PmcStyled -Style 'Success' -Text "Level $($debugStatus.Level) → $($debugStatus.LogPath)"
    } else {
        Write-PmcStyled -Style 'Muted' -Text "Disabled"
    }

    # Security status
    $securityStatus = Get-PmcSecurityStatus
    Write-PmcStyled -Style 'Body' -Text "  Security: " -NoNewline
    if ($securityStatus.PathWhitelistEnabled) {
        Write-PmcStyled -Style 'Success' -Text "Active ($(($securityStatus.AllowedWritePaths).Count) allowed paths)"
    } else {
        Write-PmcStyled -Style 'Warning' -Text "Permissive mode"
    }

    # Interactive status
    if ($Interactive) {
        $interactiveStatus = Get-PmcInteractiveStatus
        Write-PmcStyled -Style 'Body' -Text "  Interactive: " -NoNewline
        if ($interactiveStatus) {
            Write-PmcStyled -Style 'Success' -Text "Available"
        } else {
            Write-PmcStyled -Style 'Warning' -Text "PSReadLine required"
        }
    }

    # Memory usage
    $memoryMB = [Math]::Round($securityStatus.CurrentMemoryUsage / 1MB, 1)
    $limitMB = [Math]::Round($securityStatus.MaxMemoryUsage / 1MB, 1)
    Write-PmcStyled -Style 'Info' -Text "  Memory: $memoryMB MB / $limitMB MB"

    # Theme / Display
    try {
        $disp = Get-PmcState -Section 'Display'
        $theme = $disp.Theme
        $caps = $disp.Capabilities
        Write-PmcStyled -Style 'Body' -Text ("  Theme: {0}" -f ($theme.Hex ?? '#33aaff'))
        Write-PmcStyled -Style 'Muted' -Text ("  Capabilities: ANSI={0} TrueColor={1} TTY={2} NoColor={3}" -f $caps.AnsiSupport, $caps.TrueColorSupport, $caps.IsTTY, $caps.NoColor)
    } catch {
        Write-PmcStyled -Style 'Warning' -Text "  Theme: Display state unavailable"
    }

    Write-Host ""
}

# Enhanced shell with interactive support
function Show-PmcBanner {
    Write-PmcStyled -Style 'Title' -Text "pmc — enhanced project management console"
    Write-PmcStyled -Style 'Muted' -Text "Type 'help' for commands, 'status' for system info, 'exit' to quit."
}


function Start-PmcShell {
    if ($Interactive) {
        try {
            $ok = Enable-PmcInteractiveMode
            if (-not $ok) { throw "Interactive mode not available" }
        } catch {
            Write-PmcDebug -Level 2 -Category 'SHELL' -Message "Interactive init failed: $_"
            Write-PmcStyled -Style 'Error' -Text ("Interactive mode failed to start: {0}" -f $_)
            exit 1
        }
    }

    while ($true) {
        try {
            # Use Console.ReadKey for interactive input (NO fallback)
            if ($Interactive) {
                if (Get-Command Read-PmcCommand -ErrorAction SilentlyContinue) {
                    $line = Read-PmcCommand
                } else {
                    Write-PmcStyled -Style 'Error' -Text "Interactive command reader not available; aborting."
                    exit 1
                }
            } else {
                Write-Host "Interactive mode is required. Remove -NoInteractive." -ForegroundColor Red
                exit 1
            }
        } catch {
            Write-PmcDebug -Level 1 -Category 'SHELL' -Message "Input error: $_"
            break
        }

        if ($null -eq $line) { break }
        $line = $line.Trim()
        if (-not $line) { continue }

        # Check input safety
        if (-not (Test-PmcInputSafety -Input $line -InputType 'command')) {
            Write-PmcStyled -Style 'Error' -Text "Input rejected for security reasons"
            continue
        }

        switch -Regex ($line) {
            '^(?i)(exit|quit|q)$' {
                if ($Interactive) {
                    Disable-PmcInteractiveMode
                }
                break
            }
            '^(?i)status$' { Show-SystemStatus; continue }
            '^(?i)debug\s+(on|off|\d+)$' {
                $debugArg = $matches[1]
                if ($debugArg -eq 'off') {
                    Initialize-PmcDebugSystem -Level 0
                    Write-PmcStyled -Style 'Warning' -Text "Debug logging disabled"
                } elseif ($debugArg -eq 'on') {
                    Initialize-PmcDebugSystem -Level 1
                    Write-PmcStyled -Style 'Success' -Text "Debug logging enabled (Level 1)"
                } elseif ($debugArg -match '^\d+$') {
                    $level = [Math]::Min([int]$debugArg, 3)
                    Initialize-PmcDebugSystem -Level $level
                    Write-PmcStyled -Style 'Success' -Text ("Debug logging set to Level {0}" -f $level)
                }
                continue
            }
            '^(?i)interactive\s+(on|off|enable|disable)$' {
                $interactiveArg = $matches[1]
                if (($interactiveArg -eq 'on' -or $interactiveArg -eq 'enable') -and -not $Interactive) {
                    try {
                        Enable-PmcInteractiveMode
                        $Interactive = $true
                        Write-PmcStyled -Style 'Success' -Text "Interactive mode enabled"
                    } catch {
                        Write-PmcStyled -Style 'Error' -Text ("Failed to enable interactive mode: {0}" -f $_)
                    }
                } elseif (($interactiveArg -eq 'off' -or $interactiveArg -eq 'disable') -and $Interactive) {
                    try {
                        Disable-PmcInteractiveMode
                        $Interactive = $false
                        Write-PmcStyled -Style 'Warning' -Text "Interactive mode disabled"
                    } catch {
                        Write-PmcStyled -Style 'Error' -Text ("Failed to disable interactive mode: {0}" -f $_)
                    }
                }
                continue
            }
            default {
                try {
                    # Clear screen for command output, leaving input area at bottom
                    if (Get-Command Clear-CommandOutput -ErrorAction SilentlyContinue) {
                        Clear-CommandOutput
                    }
                    # Execute command - output will appear at top of screen
                    Invoke-PmcCommand -Buffer $line
                    # After command execution, add some spacing before next prompt
                    Write-Host ""
                } catch {
                    Write-PmcStyled -Style 'Error' -Text ("Error: {0}" -f $_)
                }
            }
        }
    }
}

# Start the enhanced shell
Start-PmcShell

===== END FILE: pmc.ps1 =====

===== BEGIN FILE: start-pmc.ps1 =====
#!/usr/bin/env pwsh
# PMC Launcher - runs PMC in proper interactive context like t2.ps1

param(
    [switch]$NoInteractive,
    [switch]$Debug1,
    [switch]$Debug2,
    [switch]$Debug3,
    [string]$Config = $null,
    [string]$SecurityLevel = 'balanced',
    [switch]$Help
)

# Get the directory this script is in
$ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path

# Change to PMC directory
Set-Location $ScriptDir

# Build argument hashtable for pmc.ps1 (secure parameter passing)
$params = @{}
if ($NoInteractive) { $params['NoInteractive'] = $true }
if ($Debug1) { $params['Debug1'] = $true }
if ($Debug2) { $params['Debug2'] = $true }
if ($Debug3) { $params['Debug3'] = $true }
if ($Config) { $params['Config'] = $Config }
if ($SecurityLevel -ne 'balanced') { $params['SecurityLevel'] = $SecurityLevel }
if ($Help) { $params['Help'] = $true }

# Execute PMC via dot-sourcing with parameter splatting (secure)
. ./pmc.ps1 @params
===== END FILE: start-pmc.ps1 =====

===== BEGIN FILE: config.json =====
{
  "Excel": {
    "ID2FieldName": "CASNumber",
    "MaxFileSize": "50MB",
    "SourceSheet": "SVI-CAS",
    "AllowedExtensions": [
      ".xlsm",
      ".xlsx"
    ],
    "SourceFolder": "./excel_input",
    "Mappings": [
      {
        "Field": "RequestDate",
        "SourceCell": "W23",
        "DestCell": "B2"
      },
      {
        "Field": "AuditType",
        "SourceCell": "W78",
        "DestCell": "B3"
      },
      {
        "Field": "AuditorName",
        "SourceCell": "W10",
        "DestCell": "B4"
      },
      {
        "Field": "TPName",
        "SourceCell": "W3",
        "DestCell": "B5"
      },
      {
        "Field": "TPEmailAddress",
        "SourceCell": "X3",
        "DestCell": "B6"
      },
      {
        "Field": "TPPhoneNumber",
        "SourceCell": "Y3",
        "DestCell": "B7"
      },
      {
        "Field": "TaxID",
        "SourceCell": "W13",
        "DestCell": "B8"
      },
      {
        "Field": "CASNumber",
        "SourceCell": "G17",
        "DestCell": "B9"
      }
    ],
    "DestSheet": "Output",
    "DestinationPath": "./excel_output.xlsm"
  },
  "Security": {
    "RequirePathWhitelist": true,
    "AllowedWritePaths": [
      "./",
      "./reports/",
      "./backups/",
      "./exports/",
      "./excel_input/",
      "./excel_output/"
    ],
    "AuditAllFileOps": true,
    "MaxFileSize": "100MB",
    "MaxMemoryUsage": "500MB",
    "ScanForSensitiveData": true
  },
  "Paths": {
    "AllowedWriteDirs": []
  },
  "Display": {
    "RefreshOnCommand": true,
    "ShowBannerOnRefresh": true,
    "Theme": {
      "UseTrueColor": true,
      "Enabled": true,
      "PreserveAlerts": true,
      "Hex": "#33aaff",
      "Global": true
    },
    "Icons": {
      "Mode": "emoji"
    }
  },
  "Behavior": {
    "MaxUndoLevels": 10,
    "WhatIf": false,
    "SafePathsStrict": true,
    "MaxBackups": 3,
    "EnableCsvLedger": true,
    "ReportRichCsv": false
  },
  "Interactive": {
    "GhostText": true,
    "Enabled": false,
    "CompletionMenus": true
  },
  "Debug": {
    "IncludePerformance": false,
    "LogPath": "debug.log",
    "RedactSensitive": true,
    "MaxSize": "10MB",
    "Level": 0
  }
}

===== END FILE: config.json =====

===== BEGIN FILE: tasks.json =====
{
  "schema_version": 1,
  "projects": [
    {
      "name": "inbox",
      "description": "Default inbox project",
      "color": "blue",
      "isArchived": false,
      "sortOrder": 0
    },
    {
      "name": "new project",
      "description": "Created 2025-09-17",
      "aliases": [],
      "created": "2025-09-17 12:36:07"
    },
    {
      "name": "test",
      "description": "Created 2025-09-17",
      "aliases": [],
      "created": "2025-09-17 14:00:36"
    },
    {
      "name": "demo",
      "description": "Demo project for grid testing",
      "aliases": [],
      "created": "2025-09-17 16:00:00"
    }
  ],
  "aliases": {},
  "currentContext": "inbox",
  "preferences": {
    "autoBackup": false
  },
  "activityLog": [
    {
      "user": null,
      "action": "project add",
      "timestamp": "2025-09-17 12:36:07"
    },
    {
      "user": null,
      "action": "task add",
      "timestamp": "2025-09-17 12:39:23"
    },
    {
      "action": "project add",
      "timestamp": "2025-09-17 14:00:36",
      "user": null
    },
    {
      "timestamp": "2025-09-17 14:46:19",
      "user": null,
      "action": "time log"
    },
    {
      "timestamp": "2025-09-17 14:46:26",
      "user": null,
      "action": "time report"
    },
    {
      "user": null,
      "action": "time report",
      "timestamp": "2025-09-17 15:05:42"
    },
    {
      "user": null,
      "timestamp": "2025-09-17 15:24:36",
      "action": "time report"
    },
    {
      "action": "task add",
      "timestamp": "2025-09-17 15:36:04",
      "user": null
    },
    {
      "action": "task done",
      "timestamp": "2025-09-17 21:06:21",
      "user": null
    }
  ],
  "tasks": [
    {
      "id": 1,
      "text": "Review quarterly budget proposal",
      "status": "completed",
      "project": "inbox",
      "priority": 1,
      "created": "2025-09-17 12:39:23",
      "tags": [
        "urgent",
        "finance"
      ],
      "due": "2025-09-17",
      "completed": "2025-09-17 21:06:21"
    },
    {
      "status": "pending",
      "id": 2,
      "tags": [
        "testing",
        "development"
      ],
      "priority": 2,
      "text": "Implement new data grid theming system",
      "project": "test",
      "created": "2025-09-17 15:36:04",
      "due": "2025-09-17"
    },
    {
      "id": 3,
      "text": "Update documentation for PMC features",
      "status": "pending",
      "project": "demo",
      "priority": 3,
      "created": "2025-09-17 16:00:00",
      "tags": [
        "documentation"
      ],
      "due": "2025-09-18"
    },
    {
      "id": 4,
      "text": "Schedule team retrospective meeting",
      "status": "pending",
      "project": "inbox",
      "priority": 2,
      "created": "2025-09-17 16:00:00",
      "tags": [
        "meeting",
        "team"
      ],
      "due": "2025-09-16"
    },
    {
      "id": 5,
      "text": "Optimize database query performance",
      "status": "pending",
      "project": "demo",
      "priority": 1,
      "created": "2025-09-17 16:00:00",
      "tags": [
        "performance",
        "database"
      ],
      "due": "2025-09-15"
    },
    {
      "id": 6,
      "text": "Create user onboarding guide",
      "status": "pending",
      "project": "new project",
      "priority": 3,
      "created": "2025-09-17 16:00:00",
      "tags": [
        "documentation",
        "ux"
      ]
    }
  ],
  "timelogs": [
    {
      "id": 1,
      "time": "14:46",
      "minutes": 60,
      "date": "2025-09-17",
      "notes": "",
      "project": "test"
    }
  ],
  "deleted": [],
  "completed": [],
  "templates": [],
  "recurringTemplates": []
}

===== END FILE: tasks.json =====

===== BEGIN FILE: module/Pmc.Strict/Pmc.Strict.psd1 =====
@{
    RootModule        = 'Pmc.Strict.psm1'
    ModuleVersion     = '0.1.0'
    GUID              = '5b2d6a0a-8a8f-4e2a-9d0d-3a3b0e2a3b6f'
    Author            = 'pmc'
    CompanyName       = 'pmc'
    Copyright         = '(c) pmc'
    Description       = 'Strict, homogeneous domain-action command engine for pmc.'
    PowerShellVersion = '5.1'
    TypesToProcess    = @()
    FunctionsToExport = @(
        'Invoke-PmcCommand',
        'Get-PmcSchema',
        'Get-PmcHelp',
        'Show-PmcHelpUI',
        'Show-PmcHelpDomain',
        'Show-PmcHelpCommand',
        'Show-PmcHelpAll',
        'Set-PmcConfigProvider',
        'Enable-PmcInteractiveMode',
        'Disable-PmcInteractiveMode',
        'Get-PmcInteractiveStatus',
        'Read-PmcCommand',
        'Write-PmcDebug',
        'Get-PmcDebugStatus',
        'Show-PmcDebugLog',
        'Measure-PmcOperation',
        'Initialize-PmcDebugSystem',
        'Initialize-PmcSecuritySystem',
        'Initialize-PmcThemeSystem',
        'Update-PmcDebugFromConfig',
        'Update-PmcSecurityFromConfig',
        'Get-PmcConfig',
        'Get-PmcConfigProviders',
        'Set-PmcConfigProviders',
        'Get-PmcState',
        'Set-PmcState',
        'ConvertTo-PmcTokens',
        'ConvertTo-PmcDate',
        'Show-PmcSmartHelp',
        'Write-PmcStyled',
        'Test-PmcInputSafety',
        'Test-PmcPathSafety',
        'Invoke-PmcSecureFileOperation',
        'Protect-PmcUserInput',
        'Get-PmcSecurityStatus',
        'Set-PmcSecurityLevel',
        # TASK DOMAIN HANDLERS
        'Add-PmcTask',
        'Get-PmcTaskList',
        'Show-PmcTask',
        'Set-PmcTask',
        'Complete-PmcTask',
        'Remove-PmcTask',
        'Move-PmcTask',
        'Set-PmcTaskPostponed',
        'Copy-PmcTask',
        'Add-PmcTaskNote',
        'Edit-PmcTask',
        'Find-PmcTask',
        'Set-PmcTaskPriority',
        'Show-PmcAgenda',
        'Show-PmcWeekTasks',
        'Show-PmcMonthTasks',
        # PROJECT DOMAIN HANDLERS
        'Add-PmcProject',
        'Get-PmcProjectList',
        'Show-PmcProject',
        'Set-PmcProject',
        'Rename-PmcProject',
        'Remove-PmcProject',
        'Set-PmcProjectArchived',
        'Set-PmcProjectFields',
        'Show-PmcProjectFields',
        'Get-PmcProjectStats',
        'Show-PmcProjectInfo',
        'Get-PmcRecentProjects',
        # TIME/TIMER DOMAIN HANDLERS
        'Add-PmcTimeEntry',
        'Get-PmcTimeReport',
        'Get-PmcTimeList',
        'Edit-PmcTimeEntry',
        'Remove-PmcTimeEntry',
        'Start-PmcTimer',
        'Stop-PmcTimer',
        'Get-PmcTimerStatus',
        # ACTIVITY DOMAIN
        'Get-PmcActivityList',
        # TEMPLATE DOMAIN
        'Save-PmcTemplate',
        'Invoke-PmcTemplate',
        'Get-PmcTemplateList',
        'Remove-PmcTemplate',
        # RECURRING DOMAIN
        'Add-PmcRecurringTask',
        'Get-PmcRecurringList',
        # ALIAS DOMAIN
        'Add-PmcAlias',
        'Remove-PmcAlias',
        # DEPENDENCY DOMAIN
        'Add-PmcDependency',
        'Remove-PmcDependency',
        'Show-PmcDependencies',
        'Show-PmcDependencyGraph',
        # FOCUS DOMAIN
        'Set-PmcFocus',
        'Clear-PmcFocus',
        'Get-PmcFocusStatus',
        # SYSTEM DOMAIN
        'Invoke-PmcUndo',
        'Invoke-PmcRedo',
        'New-PmcBackup',
        'Clear-PmcCompletedTasks',
        # VIEW DOMAIN
        'Show-PmcTodayTasks',
        'Show-PmcTomorrowTasks',
        'Show-PmcOverdueTasks',
        'Show-PmcUpcomingTasks',
        'Show-PmcBlockedTasks',
        'Show-PmcNoDueDateTasks',
        'Show-PmcProjectsView',
        'Show-PmcNextTasks',
        # EXCEL DOMAIN
        'Import-PmcExcelData',
        'Show-PmcExcelPreview',
        'Get-PmcLatestExcelFile',
        # THEME DOMAIN
        'Reset-PmcTheme',
        'Edit-PmcTheme',
        'Get-PmcThemeList',
        'Apply-PmcTheme',
        'Show-PmcThemeInfo',
        # CONFIG DOMAIN
        'Show-PmcConfig',
        'Edit-PmcConfig',
        'Set-PmcConfigValue',
        'Reload-PmcConfig',
        'Validate-PmcConfig',
        'Set-PmcIconMode',
        # IMPORT/EXPORT DOMAIN
        'Import-PmcTasks',
        'Export-PmcTasks',
        # SHOW DOMAIN
        'Get-PmcAliasList',
        'Show-PmcCommands',
        # HELP DOMAIN
        'Show-PmcCommandBrowser',
        'Show-PmcHelpExamples',
        'Show-PmcHelpGuide',
        # SHORTCUT-ONLY FUNCTIONS
        'Get-PmcStats',
        'Show-PmcBurndown',
        'Get-PmcVelocity',
        'Set-PmcTheme',
        'Show-PmcPreferences',
        'Invoke-PmcShortcutNumber',
        'Start-PmcReview',
        # DATA DISPLAY SYSTEM
        'Show-PmcDataGrid'
    )
    AliasesToExport   = @()
    CmdletsToExport   = @()
    VariablesToExport = @()
}

===== END FILE: module/Pmc.Strict/Pmc.Strict.psd1 =====

===== BEGIN FILE: module/Pmc.Strict/Pmc.Strict.psm1 =====
# Pmc.Strict module - strict domain-action engine

# NOTE: Completions use plain strings; no PmcCompletionItem class is used anymore.

enum PmcCompletionMode {
    Domain      # Completing domain names (task, project, time)
    Action      # Completing actions (add, list, done)
    Arguments   # Completing arguments (@project, due:date, p1)
    FreeText    # No completions available
}

class PmcEditorState {
    [string] $Buffer = ""
    [int] $CursorPos = 0
    [bool] $InCompletion = $false
    [string] $OriginalBuffer = ""
    [string[]] $Completions = @()
    [int] $CompletionIndex = -1
    [PmcCompletionMode] $Mode = [PmcCompletionMode]::Domain
    [string] $CurrentToken = ""
    [int] $TokenStart = 0
    [int] $TokenEnd = 0

    # History and undo/redo
    [string[]] $History = @()
    [int] $HistoryIndex = -1
    [string[]] $UndoStack = @()
    [string[]] $RedoStack = @()
    [int] $MaxUndoItems = 50
    [int] $MaxHistoryItems = 100
}

# Dot-source internal components with debug tracing
Write-Host "Loading Pmc.Strict module..." -ForegroundColor Green

try {
    Write-Host "  Loading Types.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/Types.ps1
    Write-Host "  ✓ Types.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Types.ps1 failed: $_" -ForegroundColor Red
    throw
}

# Ensure centralized state is available before any consumer
try {
    Write-Host "  Loading State.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/State.ps1
    Write-Host "  ✓ State.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ State.ps1 failed: $_" -ForegroundColor Red
    throw
}

# Config providers and helpers before Debug/Security which consult config
try {
    Write-Host "  Loading Config.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/Config.ps1
    Write-Host "  ✓ Config.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Config.ps1 failed: $_" -ForegroundColor Red
    throw
}

# Now load Debug and Security modules (no auto-init inside files)
try {
    Write-Host "  Loading Debug.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/Debug.ps1
    Write-Host "  ✓ Debug.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Debug.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading Security.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/Security.ps1
    Write-Host "  ✓ Security.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Security.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading Storage.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/Storage.ps1
    Write-Host "  ✓ Storage.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Storage.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading UI.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/UI.ps1
    Write-Host "  ✓ UI.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ UI.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading Resolvers.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/Resolvers.ps1
    Write-Host "  ✓ Resolvers.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Resolvers.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading CommandMap.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/CommandMap.ps1
    Write-Host "  ✓ CommandMap.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ CommandMap.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading Schemas.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/Schemas.ps1
    Write-Host "  ✓ Schemas.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Schemas.ps1 failed: $_" -ForegroundColor Red
    throw
}

## moved earlier

try {
    Write-Host "  Loading Execution.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/Execution.ps1
    Write-Host "  ✓ Execution.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Execution.ps1 failed: $_" -ForegroundColor Red
    throw
}


try {
    Write-Host "  Loading Help.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/Help.ps1
    Write-Host "  ✓ Help.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Help.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading Interactive.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/Interactive.ps1
    Write-Host "  ✓ Interactive.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Interactive.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading Dependencies.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/Dependencies.ps1
    Write-Host "  ✓ Dependencies.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Dependencies.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading Focus.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/Focus.ps1
    Write-Host "  ✓ Focus.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Focus.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading UndoRedo.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/UndoRedo.ps1
    Write-Host "  ✓ UndoRedo.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ UndoRedo.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading Views.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/Views.ps1
    Write-Host "  ✓ Views.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Views.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading Aliases.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/Aliases.ps1
    Write-Host "  ✓ Aliases.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Aliases.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading Analytics.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/Analytics.ps1
    Write-Host "  ✓ Analytics.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Analytics.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading Theme.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/Theme.ps1
    Write-Host "  ✓ Theme.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Theme.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading Excel.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/Excel.ps1
    Write-Host "  ✓ Excel.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Excel.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading ImportExport.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/ImportExport.ps1
    Write-Host "  ✓ ImportExport.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ ImportExport.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading Shortcuts.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/Shortcuts.ps1
    Write-Host "  ✓ Shortcuts.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Shortcuts.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading Review.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/Review.ps1
    Write-Host "  ✓ Review.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Review.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading HelpUI.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/HelpUI.ps1
    Write-Host "  ✓ HelpUI.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ HelpUI.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading TaskEditor.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/TaskEditor.ps1
    Write-Host "  ✓ TaskEditor.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ TaskEditor.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading ProjectWizard.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/ProjectWizard.ps1
    Write-Host "  ✓ ProjectWizard.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ ProjectWizard.ps1 failed: $_" -ForegroundColor Red
    throw
}

try {
    Write-Host "  Loading DataDisplay.ps1..." -ForegroundColor Gray
    . $PSScriptRoot/src/DataDisplay.ps1
    Write-Host "  ✓ DataDisplay.ps1 loaded" -ForegroundColor Green
} catch {
    Write-Host "  ✗ DataDisplay.ps1 failed: $_" -ForegroundColor Red
    throw
}

Write-Host "Pmc.Strict module loaded successfully!" -ForegroundColor Green

# Ensure required public functions are exported (override narrow exports in sub-files)
Export-ModuleMember -Function `
    Invoke-PmcCommand, `
    Get-PmcSchema, `
    Get-PmcHelp, `
    Set-PmcConfigProvider, `
    Write-PmcDebug, `
    Get-PmcDebugStatus, `
    Show-PmcDebugLog, `
    Measure-PmcOperation, `
    Initialize-PmcDebugSystem, `
    Initialize-PmcSecuritySystem, `
    Initialize-PmcThemeSystem, `
    Write-PmcStyled, Show-PmcHeader, Show-PmcSeparator, Show-PmcTable, `
    Test-PmcInputSafety, `
    Test-PmcPathSafety, `
    Invoke-PmcSecureFileOperation, `
    Protect-PmcUserInput, `
    Get-PmcSecurityStatus, `
    Set-PmcSecurityLevel, `
    Enable-PmcInteractiveMode, `
    Disable-PmcInteractiveMode, `
    Get-PmcInteractiveStatus, `
    Show-PmcSmartHelp, `
    Show-PmcHelpDomain, `
    Show-PmcHelpCommand, `
    Show-PmcHelpUI, `
    Show-PmcCommandBrowser, `
    Show-PmcHelpExamples, `
    Show-PmcHelpGuide, `
    Invoke-PmcTaskEditor, `
    Invoke-PmcProjectWizard, `
    Show-PmcAgenda

===== END FILE: module/Pmc.Strict/Pmc.Strict.psm1 =====

===== BEGIN FILE: module/Pmc.Strict/src/Aliases.ps1 =====
# User alias system: alias, alias add, alias remove; show aliases

function Get-PmcAliasTable {
    $data = Get-PmcDataAlias
    if (-not (Pmc-HasProp $data 'aliases') -or -not $data.aliases) { $data.aliases = @{} }
    # Normalize to hashtable if JSON loaded as PSCustomObject
    if ($data.aliases -is [pscustomobject]) {
        $ht = @{}
        foreach ($p in $data.aliases.PSObject.Properties) { $ht[$p.Name] = $p.Value }
        $data.aliases = $ht
    }
    # Seed helpful defaults if empty
    try {
        $keyCount = 0
        if ($data.aliases -is [hashtable]) { $keyCount = @($data.aliases.Keys).Count }
        elseif ($data.aliases.PSObject -and $data.aliases.PSObject.Properties) { $keyCount = @($data.aliases.PSObject.Properties.Name).Count }
    } catch { $keyCount = 0 }
    if ($keyCount -eq 0) {
        $data.aliases['projects'] = 'view projects'
    }
    return $data.aliases
}

function Save-PmcAliases($aliases) {
    $data = Get-PmcDataAlias
    $data.aliases = $aliases
    Save-StrictData $data 'alias update'
}

function Get-PmcAliasList {
    param([PmcCommandContext]$Context)
    $aliases = Get-PmcAliasTable
    Write-Host "\nALIASES" -ForegroundColor Cyan
    Write-Host "────────" -ForegroundColor DarkGray
    $rows = @()
    if ($aliases -is [hashtable]) {
        foreach ($entry in $aliases.GetEnumerator()) {
            $rows += @{ alias = [string]$entry.Key; expands = [string]$entry.Value }
        }
    } elseif ($aliases -is [pscustomobject]) {
        foreach ($p in $aliases.PSObject.Properties) {
            $rows += @{ alias = [string]$p.Name; expands = [string]$p.Value }
        }
    }
    if (@($rows).Count -eq 0) { Write-Host 'No aliases defined' -ForegroundColor Yellow; return }
    $rows = $rows | Sort-Object alias
    Show-PmcTable -Columns @(@{key='alias';title='Alias';width=16}, @{key='expands';title='Expands To';width=48}) -Rows $rows
}

function Add-PmcAlias {
    param([PmcCommandContext]$Context)
    $text = ($Context.FreeText -join ' ').Trim()
    if (-not $text -or -not ($text -match '^(\S+)\s+(.+)$')) { Write-Host "Usage: alias add <name> <expansion...>" -ForegroundColor Yellow; return }
    $name = $matches[1]; $expansion = $matches[2]
    $aliases = Get-PmcAliasTable
    $aliases[$name] = $expansion
    Save-PmcAliases $aliases
    Write-Host ("Added alias '{0}' = {1}" -f $name, $expansion) -ForegroundColor Green
}

function Remove-PmcAlias {
    param([PmcCommandContext]$Context)
    $name = ($Context.FreeText -join ' ').Trim()
    if ([string]::IsNullOrWhiteSpace($name)) { Write-Host "Usage: alias remove <name>" -ForegroundColor Yellow; return }
    $aliases = Get-PmcAliasTable
    if (-not $aliases.ContainsKey($name)) { Write-Host ("Alias '{0}' not found" -f $name) -ForegroundColor Red; return }
    $aliases.Remove($name) | Out-Null
    Save-PmcAliases $aliases
    Write-Host ("Removed alias '{0}'" -f $name) -ForegroundColor Green
}

function Expand-PmcUserAliases {
    param([string]$Buffer)
    try {
        $aliases = Get-PmcAliasTable
        if (-not $aliases) { return $Buffer }
        # Normalize alias keys safely
        $keys = @()
        if ($aliases -is [hashtable]) { $keys = @($aliases.Keys) }
        elseif ($aliases.PSObject -and $aliases.PSObject.Properties) { $keys = @($aliases.PSObject.Properties.Name) }
        if (@($keys).Count -eq 0) { return $Buffer }
        $tokens = ConvertTo-PmcTokens $Buffer
        if ($tokens.Count -eq 0) { return $Buffer }
        $first = $tokens[0]
        $hasKey = $false
        $expansion = $null
        if ($aliases -is [hashtable]) { $hasKey = $aliases.ContainsKey($first); if ($hasKey) { $expansion = [string]$aliases[$first] } }
        elseif ($aliases.PSObject) { try { $expansion = [string]($aliases.$first); $hasKey = -not [string]::IsNullOrEmpty($expansion) } catch {
            # Property access failed - alias does not exist
        } }
        if ($hasKey -and $expansion) {
            # Replace first token with its expansion
            $rest = if ($tokens.Count -gt 1) { ' ' + ($tokens[1..($tokens.Count-1)] -join ' ') } else { '' }
            return ($expansion + $rest)
        }
    } catch {
        # Alias expansion failed - return original buffer
    }
    return $Buffer
}

===== END FILE: module/Pmc.Strict/src/Aliases.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/Analytics.ps1 =====
# Analytics and Insights: stats, burndown, velocity

function Get-PmcStatistics {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "Analytics" -Message "Starting stats"

    $data = Get-PmcDataAlias
    $now = Get-Date
    $d7 = $now.Date.AddDays(-7)
    $d30 = $now.Date.AddDays(-30)

    $pending = @($data.tasks | Where-Object { $_.status -eq 'pending' }).Count
    $completed = @($data.tasks | Where-Object { $_.status -eq 'completed' }).Count
    $completed7 = @($data.tasks | Where-Object { $_.completed -and ([datetime]$_.completed) -ge $d7 }).Count
    $added7 = @($data.tasks | Where-Object { $_.created -and ([datetime]$_.created) -ge $d7 }).Count

    $logs7 = @($data.timelogs | Where-Object { $_.date -and ([datetime]$_.date) -ge $d7 })
    $minutes7 = ($logs7 | Measure-Object minutes -Sum).Sum
    $hours7 = [Math]::Round(($minutes7/60),2)

    $rows = @(
        @{ metric='Pending tasks'; value=$pending },
        @{ metric='Completed (all)'; value=$completed },
        @{ metric='Completed (7d)'; value=$completed7 },
        @{ metric='Added (7d)'; value=$added7 },
        @{ metric='Hours logged (7d)'; value=$hours7 }
    )
    $cols = @(
        @{ key='metric'; title='Metric'; width=26 },
        @{ key='value'; title='Value'; width=10; align='right' }
    )
    Show-PmcTable -Columns $cols -Rows $rows -Title 'STATS'

    Write-PmcDebug -Level 2 -Category "Analytics" -Message "Stats completed" -Data @{ Pending=$pending; Completed7=$completed7; Hours7=$hours7 }
}

function Show-PmcBurndownChart {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "Analytics" -Message "Starting burndown"

    $data = Get-PmcDataAlias
    $today = (Get-Date).Date
    $horizon = 7
    $rows = @()

    for ($i=0; $i -lt $horizon; $i++) {
        $day = $today.AddDays($i)
        $remaining = @($data.tasks | Where-Object {
            try {
                $_.status -eq 'pending' -and (
                    (-not $_.due) -or ([datetime]$_.due) -ge $day
                )
            } catch { $false }
        }).Count
        $rows += @{ date=$day.ToString('yyyy-MM-dd'); remaining=$remaining }
    }

    $cols = @(
        @{ key='date'; title='Date'; width=12 },
        @{ key='remaining'; title='Remaining'; width=12; align='right' }
    )
    Show-PmcTable -Columns $cols -Rows $rows -Title 'BURNDOWN (next 7 days)'
    Show-PmcTip 'Simple burndown: remaining tasks projected by day'

    Write-PmcDebug -Level 2 -Category "Analytics" -Message "Burndown completed"
}

function Get-PmcVelocity {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "Analytics" -Message "Starting velocity"

    $data = Get-PmcDataAlias
    $startOfWeek = (Get-Date).Date.AddDays(-1 * (([int](Get-Date).DayOfWeek + 6) % 7))
    $rows = @()
    for ($w=0; $w -lt 4; $w++) {
        $wStart = $startOfWeek.AddDays(-7*$w)
        $wEnd = $wStart.AddDays(7)
        $done = @($data.tasks | Where-Object { $_.status -eq 'completed' -and $_.completed -and ([datetime]$_.completed) -ge $wStart -and ([datetime]$_.completed) -lt $wEnd }).Count
        $mins = @($data.timelogs | Where-Object { $_.date -and ([datetime]$_.date) -ge $wStart -and ([datetime]$_.date) -lt $wEnd } | Measure-Object minutes -Sum).Sum
        $hrs = [Math]::Round(($mins/60),1)
        $rows += @{ week=$wStart.ToString('yyyy-MM-dd'); completed=$done; hours=$hrs }
    }

    $cols = @(
        @{ key='week'; title='Week'; width=12 },
        @{ key='completed'; title='Done'; width=8; align='right' },
        @{ key='hours'; title='Hours'; width=8; align='right' }
    )
    Show-PmcTable -Columns $cols -Rows ($rows | Sort-Object week) -Title 'VELOCITY (last 4 weeks)'
    Write-PmcDebug -Level 2 -Category "Analytics" -Message "Velocity completed"
}


===== END FILE: module/Pmc.Strict/src/Analytics.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/CommandMap.ps1 =====
# Canonical domain -> action -> function map (strict)

$Script:PmcCommandMap = @{
    task = @{
        add     = 'Add-PmcTask'
        list    = 'Get-PmcTaskList'
        view    = 'Show-PmcTask'
        update  = 'Set-PmcTask'
        done    = 'Complete-PmcTask'
        delete  = 'Remove-PmcTask'
        move    = 'Move-PmcTask'
        postpone= 'Set-PmcTaskPostponed'
        duplicate='Copy-PmcTask'
        note    = 'Add-PmcTaskNote'
        edit    = 'Edit-PmcTask'
        search  = 'Find-PmcTask'
        priority= 'Set-PmcTaskPriority'
        agenda  = 'Show-PmcAgenda'
        week    = 'Show-PmcWeekTasks'
        month   = 'Show-PmcMonthTasks'
    }
    project = @{
        add     = 'Add-PmcProject'
        list    = 'Get-PmcProjectList'
        view    = 'Show-PmcProject'
        update  = 'Set-PmcProject'
        edit    = 'Edit-PmcProject'
        rename  = 'Rename-PmcProject'
        delete  = 'Remove-PmcProject'
        archive = 'Set-PmcProjectArchived'
        'set-fields' = 'Set-PmcProjectFields'
        'show-fields'= 'Show-PmcProjectFields'
        stats   = 'Get-PmcProjectStats'
        info    = 'Show-PmcProjectInfo'
        recent  = 'Get-PmcRecentProjects'
    }
    activity = @{
        list    = 'Get-PmcActivityList'
    }
    time = @{
        log     = 'Add-PmcTimeEntry'
        report  = 'Get-PmcTimeReport'
        list    = 'Get-PmcTimeList'
        edit    = 'Edit-PmcTimeEntry'
        delete  = 'Remove-PmcTimeEntry'
    }
    timer = @{
        start   = 'Start-PmcTimer'
        stop    = 'Stop-PmcTimer'
        status  = 'Get-PmcTimerStatus'
    }
    template = @{
        save    = 'Save-PmcTemplate'
        apply   = 'Invoke-PmcTemplate'
        list    = 'Get-PmcTemplateList'
        remove  = 'Remove-PmcTemplate'
    }
    recurring = @{
        add     = 'Add-PmcRecurringTask'
        list    = 'Get-PmcRecurringList'
    }
    alias = @{
        add     = 'Add-PmcAlias'
        remove  = 'Remove-PmcAlias'
    }
    dep = @{
        add     = 'Add-PmcDependency'
        remove  = 'Remove-PmcDependency'
        show    = 'Show-PmcDependencies'
        graph   = 'Show-PmcDependencyGraph'
    }
    focus = @{
        set     = 'Set-PmcFocus'
        clear   = 'Clear-PmcFocus'
        status  = 'Get-PmcFocusStatus'
    }
    system = @{
        undo    = 'Invoke-PmcUndo'
        redo    = 'Invoke-PmcRedo'
        backup  = 'New-PmcBackup'
        clean   = 'Clear-PmcCompletedTasks'
    }
    view = @{
        today     = 'Show-PmcTodayTasks'
        tomorrow  = 'Show-PmcTomorrowTasks'
        overdue   = 'Show-PmcOverdueTasks'
        upcoming  = 'Show-PmcUpcomingTasks'
        blocked   = 'Show-PmcBlockedTasks'
        noduedate = 'Show-PmcNoDueDateTasks'
        projects  = 'Show-PmcProjectsView'
        next      = 'Show-PmcNextTasks'
    }
    excel = @{
        import   = 'Import-PmcExcelData'
        bind     = 'Bind-PmcExcelImports'
        view     = 'Show-PmcExcelPreview'
        latest   = 'Get-PmcLatestExcelFile'
    }
    theme = @{
        reset    = 'Reset-PmcTheme'
        adjust   = 'Edit-PmcTheme'
        list     = 'Get-PmcThemeList'
        apply    = 'Apply-PmcTheme'
        info     = 'Show-PmcThemeInfo'
    }
    interactive = @{
        status   = 'Get-PmcInteractiveStatus'
    }
    config = @{
        show    = 'Show-PmcConfig'
        edit    = 'Edit-PmcConfig'
        set     = 'Set-PmcConfigValue'
        reload  = 'Reload-PmcConfig'
        validate= 'Validate-PmcConfig'
        icons   = 'Set-PmcIconMode'
    }
    import = @{
        tasks   = 'Import-PmcTasks'
    }
    export = @{
        tasks   = 'Export-PmcTasks'
    }
    show = @{
        aliases = 'Get-PmcAliasList'
        commands= 'Show-PmcCommands'
    }
    help = @{
        all     = 'Show-PmcHelpAll'
        show    = 'Show-PmcSmartHelp'
        commands= 'Show-PmcCommandBrowser'
        examples= 'Show-PmcHelpExamples'
        guide   = 'Show-PmcHelpGuide'
        domain  = 'Show-PmcHelpDomain'
        command = 'Show-PmcHelpCommand'
    }
}

# Single-word shortcuts (domain-less commands)
$Script:PmcShortcutMap = @{
    add       = 'Add-PmcTask'
    done      = 'Complete-PmcTask'
    delete    = 'Remove-PmcTask'
    update    = 'Set-PmcTask'
    move      = 'Move-PmcTask'
    postpone  = 'Set-PmcTaskPostponed'
    duplicate = 'Copy-PmcTask'
    note      = 'Add-PmcTaskNote'
    edit      = 'Edit-PmcTask'
    list      = 'Get-PmcTaskList'
    search    = 'Find-PmcTask'
    priority  = 'Set-PmcTaskPriority'
    agenda    = 'Show-PmcAgenda'
    week      = 'Show-PmcWeekTasks'
    month     = 'Show-PmcMonthTasks'
    log       = 'Add-PmcTimeEntry'
    report    = 'Get-PmcTimeReport'
    today     = 'Show-PmcTodayTasks'
    tomorrow  = 'Show-PmcTomorrowTasks'
    overdue   = 'Show-PmcOverdueTasks'
    upcoming  = 'Show-PmcUpcomingTasks'
    blocked   = 'Show-PmcBlockedTasks'
    noduedate = 'Show-PmcNoDueDateTasks'
    projects  = 'Show-PmcProjectsView'
    undo      = 'Invoke-PmcUndo'
    redo      = 'Invoke-PmcRedo'
    backup    = 'New-PmcBackup'
    clean     = 'Clear-PmcCompletedTasks'
    focus     = 'Set-PmcFocus'
    unfocus   = 'Clear-PmcFocus'
    context   = 'Get-PmcFocusStatus'
    next      = 'Show-PmcNextTasks'
    stats     = 'Get-PmcStats'
    burndown  = 'Show-PmcBurndown'
    velocity  = 'Get-PmcVelocity'
    theme     = 'Set-PmcTheme'
    prefs     = 'Show-PmcPreferences'
    '#'       = 'Invoke-PmcShortcutNumber'
    alias     = 'Get-PmcAliasList'
    review    = 'Start-PmcReview'
    import    = 'Import-PmcTasks'
    export    = 'Export-PmcTasks'
}

# Minimal descriptions for help
$Script:PmcCommandMeta = @{
    'task add'      = @{ Desc='Add a new task' }
    'task list'     = @{ Desc='List tasks' }
    'task done'     = @{ Desc='Complete a task' }
    'project add'   = @{ Desc='Create project' }
    'project list'  = @{ Desc='List projects' }
    'time log'      = @{ Desc='Log time entry' }
    'time report'   = @{ Desc='Show time report' }
    'time list'     = @{ Desc='List time logs' }
    'timer start'   = @{ Desc='Start timer' }
    'timer stop'    = @{ Desc='Stop timer' }
    'timer status'  = @{ Desc='Show timer' }
    'dep add'       = @{ Desc='Add task dependency' }
    'dep remove'    = @{ Desc='Remove task dependency' }
    'dep show'      = @{ Desc='Show task dependencies' }
    'dep graph'     = @{ Desc='Visual dependency graph' }
    'focus set'     = @{ Desc='Set project context' }
    'focus clear'   = @{ Desc='Clear project context' }
    'focus status'  = @{ Desc='Show current context' }
    'system undo'   = @{ Desc='Undo last action' }
    'system redo'   = @{ Desc='Redo last action' }
    'system backup' = @{ Desc='Create data backup' }
    'system clean'  = @{ Desc='Clean completed tasks' }
    'view today'    = @{ Desc='Tasks due today' }
    'view tomorrow' = @{ Desc='Tasks due tomorrow' }
    'view overdue'  = @{ Desc='Overdue tasks' }
    'view upcoming' = @{ Desc='Upcoming tasks (7 days)' }
    'view blocked'  = @{ Desc='Tasks blocked by dependencies' }
    'view noduedate'= @{ Desc='Tasks without due dates' }
    'view projects' = @{ Desc='Projects dashboard' }
    'view next'     = @{ Desc='Next actions summary' }
    'excel import'  = @{ Desc='Import tasks from Excel/CSV' }
    'excel view'    = @{ Desc='Preview Excel/CSV import' }
    'excel latest'  = @{ Desc='Show latest Excel/CSV file' }
    'theme reset'   = @{ Desc='Reset theme to default' }
    'theme adjust'  = @{ Desc='Adjust theme interactively' }
    'config icons'  = @{ Desc='Set icons: ascii|emoji' }
    'stats'         = @{ Desc='Productivity statistics' }
    'burndown'      = @{ Desc='Burndown overview (7d)' }
    'velocity'      = @{ Desc='Velocity (last 4 weeks)' }
    'prefs'         = @{ Desc='Edit preferences' }
    'alias add'     = @{ Desc='Add user alias' }
    'alias remove'  = @{ Desc='Remove user alias' }
    'show aliases'  = @{ Desc='Show user aliases' }
    'show commands' = @{ Desc='List all commands' }
    'help all'      = @{ Desc='Full command help' }
    'project stats' = @{ Desc='Project statistics' }
    'project info'  = @{ Desc='Project information' }
    'project recent'= @{ Desc='Recent projects' }
    'import tasks'  = @{ Desc='Import tasks from CSV/JSON' }
    'export tasks'  = @{ Desc='Export tasks to CSV/JSON' }
    'review'        = @{ Desc='Weekly review workflow' }
}

===== END FILE: module/Pmc.Strict/src/CommandMap.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/Config.ps1 =====
# Config provider indirection - now uses centralized state

function Set-PmcConfigProvider {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true, Position=0)] [scriptblock]$Get,
        [Parameter(Position=1)] [scriptblock]$Set
    )
    Set-PmcConfigProviders -Get $Get -Set $Set
}

function Get-PmcConfig {
    $providers = Get-PmcConfigProviders
    try { return & $providers.Get } catch { return @{} }
}

function Save-PmcConfig {
    param($cfg)
    $providers = Get-PmcConfigProviders
    if ($providers.Set) {
        try { & $providers.Set $cfg; return } catch {
            # Custom config provider failed - fall back to default
        }
    }
    # Default: write to pmc/config.json near module root
    try {
        $root = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
        $path = Join-Path $root 'config.json'
        $cfg | ConvertTo-Json -Depth 10 | Set-Content -Path $path -Encoding UTF8
    } catch {
        # Default config file save failed - settings not persisted
    }
}

# Basic config schema validation and normalization
function Get-PmcDefaultConfig {
    return @{
        Display = @{ Theme = @{ Enabled=$true; Hex='#33aaff' }; Icons=@{ Mode='emoji' } }
        Debug = @{ Level=0; LogPath='debug.log'; MaxSize='10MB'; RedactSensitive=$true; IncludePerformance=$false }
        Security = @{ AllowedWritePaths=@('./','./reports/','./backups/'); MaxFileSize='100MB'; MaxMemoryUsage='500MB'; ScanForSensitiveData=$true; RequirePathWhitelist=$true; AuditAllFileOps=$true }
    }
}

function Test-PmcConfigSchema {
    $cfg = Get-PmcConfig
    $errors = @(); $warnings=@()
    # Display.Theme.Hex
    try { $hex = [string]$cfg.Display.Theme.Hex; if (-not ($hex -match '^#?[0-9a-fA-F]{6}$')) { $warnings += 'Display.Theme.Hex invalid; using default' } } catch { $warnings += 'Display.Theme.Hex missing' }
    # Icons mode
    try { $mode = [string]$cfg.Display.Icons.Mode; if ($mode -notin @('ascii','emoji')) { $warnings += 'Display.Icons.Mode must be ascii|emoji' } } catch { $warnings += 'Display.Icons.Mode missing' }
    # Debug level
    try { $lvl = [int]$cfg.Debug.Level; if ($lvl -lt 0 -or $lvl -gt 3) { $warnings += 'Debug.Level out of range (0-3)' } } catch { $warnings += 'Debug.Level missing' }
    # Security paths
    try { if (-not ($cfg.Security.AllowedWritePaths -is [System.Collections.IEnumerable])) { $warnings += 'Security.AllowedWritePaths must be an array' } } catch { $warnings += 'Security.AllowedWritePaths missing' }
    return [pscustomobject]@{ IsValid = ($errors.Count -eq 0); Errors=$errors; Warnings=$warnings }
}

function Normalize-PmcConfig {
    $cfg = Get-PmcConfig
    $def = Get-PmcDefaultConfig
    foreach ($k in $def.Keys) {
        if (-not $cfg.ContainsKey($k)) { $cfg[$k] = $def[$k]; continue }
        foreach ($k2 in $def[$k].Keys) {
            if (-not $cfg[$k].ContainsKey($k2)) { $cfg[$k][$k2] = $def[$k][$k2] }
        }
    }
    # Normalize hex
    try { if ($cfg.Display.Theme.Hex -and -not ($cfg.Display.Theme.Hex.ToString().StartsWith('#'))) { $cfg.Display.Theme.Hex = '#' + $cfg.Display.Theme.Hex } } catch {}
    # Icons mode default
    try { if (-not $cfg.Display.Icons.Mode) { $cfg.Display.Icons.Mode = 'emoji' } } catch {}
    Save-PmcConfig $cfg
    return $cfg
}

function Validate-PmcConfig { param([PmcCommandContext]$Context)
    $result = Test-PmcConfigSchema
    if (-not $result.IsValid -or $result.Warnings.Count -gt 0) {
        Write-PmcStyled -Style 'Warning' -Text 'Config issues detected:'
        foreach ($w in $result.Warnings) { Write-PmcStyled -Style 'Muted' -Text ('  - ' + $w) }
    } else {
        Write-PmcStyled -Style 'Success' -Text 'Config looks good.'
    }
}

# Explicitly export the function to ensure it's available
Export-ModuleMember -Function Get-PmcConfig

===== END FILE: module/Pmc.Strict/src/Config.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/DataDisplay.ps1 =====
# DataDisplay.ps1 - Universal data grid system for PMC
# Provides flexible, auto-sizing grid display for any domain combination

Set-StrictMode -Version Latest

class PmcGridRenderer {
    [hashtable] $ColumnConfig
    [int] $TerminalWidth
    [string[]] $Domains
    [hashtable] $Filters
    [hashtable] $ThemeConfig
    [hashtable] $ProjectLookup

    PmcGridRenderer([hashtable]$Columns, [string[]]$Domains, [hashtable]$Filters) {
        $this.ColumnConfig = $Columns
        $this.Domains = $Domains
        $this.Filters = $Filters
        $this.ThemeConfig = $this.InitializeTheme(@{})
        $this.TerminalWidth = $this.GetTerminalWidth()
        $this.ProjectLookup = $this.LoadProjectLookup()
    }

    [hashtable] InitializeTheme([hashtable]$UserTheme) {
        # Get PMC's existing style system
        $pmcStyles = Get-PmcState -Section 'Display' -Key 'Styles'

        # Default grid theme using PMC style tokens
        $defaultTheme = @{
            Default = @{
                Style = "Body"  # Uses PMC's Body style token
            }
            Columns = @{}
            Rows = @{
                Header = @{ Style = "Header" }      # Uses PMC's Header style
                Separator = @{ Style = "Border" }   # Uses PMC's Border style
            }
            Cells = @()
        }

        # Merge user theme with defaults (deep merge)
        if ($UserTheme.PSObject.Properties['Default']) {
            $defaultTheme.Default = $this.MergeStyles($defaultTheme.Default, $UserTheme.Default)
        }
        if ($UserTheme.PSObject.Properties['Columns']) {
            foreach ($col in $UserTheme.Columns.Keys) {
                $defaultTheme.Columns[$col] = $UserTheme.Columns[$col]
            }
        }
        if ($UserTheme.PSObject.Properties['Rows']) {
            foreach ($row in $UserTheme.Rows.Keys) {
                $defaultTheme.Rows[$row] = $this.MergeStyles($defaultTheme.Rows[$row], $UserTheme.Rows[$row])
            }
        }
        if ($UserTheme.PSObject.Properties['Cells']) {
            $defaultTheme.Cells = $UserTheme.Cells
        }

        return $defaultTheme
    }

    [hashtable] MergeStyles([hashtable]$Base, [hashtable]$Override) {
        $merged = @{}
        if ($Base) {
            foreach ($key in $Base.Keys) { $merged[$key] = $Base[$key] }
        }
        if ($Override) {
            foreach ($key in $Override.Keys) { $merged[$key] = $Override[$key] }
        }
        return $merged
    }

    [hashtable] GetCellTheme([object]$Item, [string]$ColumnName, [int]$RowIndex, [bool]$IsHeader) {
        # Start with default theme
        $cellTheme = $this.ThemeConfig.Default.Clone()

        # Apply column theme
        if ($ColumnName -and $this.ThemeConfig.Columns.PSObject.Properties[$ColumnName]) {
            $cellTheme = $this.MergeStyles($cellTheme, $this.ThemeConfig.Columns[$ColumnName])
        }

        # Apply row theme
        if ($IsHeader -and $this.ThemeConfig.Rows.PSObject.Properties['Header']) {
            $cellTheme = $this.MergeStyles($cellTheme, $this.ThemeConfig.Rows.Header)
        }

        # Apply cell-specific themes (conditional)
        if (-not $IsHeader -and $this.ThemeConfig.Cells) {
            foreach ($cellRule in $this.ThemeConfig.Cells) {
                # Check if rule applies to this cell
                if ($cellRule.PSObject.Properties['Column'] -and $cellRule.Column -ne $ColumnName) {
                    continue  # Rule is column-specific and doesn't match
                }

                $applies = $true
                if ($cellRule.PSObject.Properties['Condition'] -and $cellRule.Condition) {
                    try {
                        $applies = & $cellRule.Condition $Item
                    } catch {
                        $applies = $false
                    }
                }

                if ($applies -and $cellRule.PSObject.Properties['Style']) {
                    $cellTheme = $this.MergeStyles($cellTheme, $cellRule.Style)
                }
            }
        }

        return $cellTheme
    }

    [string] ApplyTheme([string]$Text, [hashtable]$CellTheme) {
        # If we have a PMC style token, use Write-PmcStyled approach
        if ($CellTheme.PSObject.Properties['Style']) {
            $style = Get-PmcStyle $CellTheme.Style
            if ($style -and $style.PSObject.Properties['Fg']) {
                # Use PMC's styling but return the ANSI codes directly for grid integration
                return $this.ConvertPmcStyleToAnsi($Text, $style, $CellTheme)
            }
        }

        # Direct color specification (RGB, Hex, Named)
        $fgCode = ""
        $bgCode = ""

        # Handle foreground color
        if ($CellTheme.PSObject.Properties['Foreground'] -or $CellTheme.PSObject.Properties['Fg']) {
            $fg = if ($CellTheme.Foreground) { $CellTheme.Foreground } else { $CellTheme.Fg }
            $fgCode = $this.GetColorCode($fg, $false)
        }

        # Handle background color
        if ($CellTheme.PSObject.Properties['Background'] -or $CellTheme.PSObject.Properties['Bg']) {
            $bg = if ($CellTheme.Background) { $CellTheme.Background } else { $CellTheme.Bg }
            $bgCode = $this.GetColorCode($bg, $true)
        }

        if ($fgCode -or $bgCode) {
            return "$fgCode$bgCode$Text" + [PmcVT]::Reset()
        }

        return $Text
    }

    [string] ConvertPmcStyleToAnsi([string]$Text, [hashtable]$PmcStyle, [hashtable]$CellTheme) {
        $codes = ""

        # Convert PMC style to ANSI codes
        if ($PmcStyle.PSObject.Properties['Fg']) {
            $codes += $this.GetColorCode($PmcStyle.Fg, $false)
        }
        if ($PmcStyle.PSObject.Properties['Bg']) {
            $codes += $this.GetColorCode($PmcStyle.Bg, $true)
        }

        # Apply any additional cell-specific overrides
        if ($CellTheme.PSObject.Properties['Fg']) {
            $codes += $this.GetColorCode($CellTheme.Fg, $false)
        }
        if ($CellTheme.PSObject.Properties['Bg']) {
            $codes += $this.GetColorCode($CellTheme.Bg, $true)
        }

        if ($codes) {
            return "$codes$Text" + [PmcVT]::Reset()
        }
        return $Text
    }

    [string] GetColorCode([string]$Color, [bool]$IsBackground) {
        if (-not $Color) { return "" }

        # Handle hex colors (#RRGGBB or #RGB)
        if ($Color -match '^#([0-9A-Fa-f]{6}|[0-9A-Fa-f]{3})$') {
            $rgb = ConvertFrom-PmcHex $Color
            if ($rgb) {
                return if ($IsBackground) { [PmcVT]::BgRGB($rgb.R, $rgb.G, $rgb.B) } else { [PmcVT]::FgRGB($rgb.R, $rgb.G, $rgb.B) }
            }
        }

        # Handle RGB values (255,128,64)
        if ($Color -match '^(\d{1,3}),(\d{1,3}),(\d{1,3})$') {
            $r = [int]$Matches[1]
            $g = [int]$Matches[2]
            $b = [int]$Matches[3]
            if ($r -le 255 -and $g -le 255 -and $b -le 255) {
                return if ($IsBackground) { [PmcVT]::BgRGB($r, $g, $b) } else { [PmcVT]::FgRGB($r, $g, $b) }
            }
        }

        # Handle named colors (fallback to standard ANSI)
        $ansiCode = if ($IsBackground) { 40 } else { 30 }
        switch ($Color.ToLower()) {
            "black" { $ansiCode += 0 }
            "red" { $ansiCode += 1 }
            "green" { $ansiCode += 2 }
            "yellow" { $ansiCode += 3 }
            "blue" { $ansiCode += 4 }
            "magenta" { $ansiCode += 5 }
            "cyan" { $ansiCode += 6 }
            "white" { $ansiCode += 7 }
            "gray" { $ansiCode = if ($IsBackground) { 100 } else { 90 } }
            "brightred" { $ansiCode = if ($IsBackground) { 101 } else { 91 } }
            "brightgreen" { $ansiCode = if ($IsBackground) { 102 } else { 92 } }
            "brightyellow" { $ansiCode = if ($IsBackground) { 103 } else { 93 } }
            "brightblue" { $ansiCode = if ($IsBackground) { 104 } else { 94 } }
            "brightmagenta" { $ansiCode = if ($IsBackground) { 105 } else { 95 } }
            "brightcyan" { $ansiCode = if ($IsBackground) { 106 } else { 96 } }
            "brightwhite" { $ansiCode = if ($IsBackground) { 107 } else { 97 } }
            default { return "" }
        }

        return "`e[${ansiCode}m"
    }

    [int] GetTerminalWidth() {
        try {
            $width = [Console]::WindowWidth
            if ($width -lt 40) { return 80 }  # Fallback for narrow terminals
            return $width
        } catch {
            return 80  # Safe fallback
        }
    }

    [hashtable] LoadProjectLookup() {
        # Load project data to resolve project names from IDs
        $lookup = @{}
        try {
            $data = Get-PmcDataProvider 'Storage'
            if ($data -and $data.GetData) {
                $allData = $data.GetData()
                if ($allData.projects) {
                    foreach ($project in $allData.projects) {
                        if ($project.name) {
                            $lookup[$project.name] = $project.name
                            # Also map any aliases if they exist
                            if ($project.PSObject.Properties['aliases'] -and $project.aliases) {
                                foreach ($alias in $project.aliases) {
                                    $lookup[$alias] = $project.name
                                }
                            }
                        }
                    }
                }
            }
        } catch {
            Write-PmcDebug -Level 2 -Category "DataDisplay" -Message "Failed to load project lookup" -Data @{ Error = $_.Exception.Message }
        }
        return $lookup
    }

    [hashtable] GetColumnWidths([object[]]$Data) {
        $widths = @{}
        $totalFixed = 0
        $flexColumns = @()

        # Calculate fixed widths and identify flex columns
        foreach ($col in $this.ColumnConfig.Keys) {
            if ($this.ColumnConfig[$col].Width) {
                $widths[$col] = $this.ColumnConfig[$col].Width
                $totalFixed += $widths[$col]
            } else {
                $flexColumns += $col
            }
        }

        # Calculate available space for flex columns
        $padding = ($this.ColumnConfig.Keys.Count - 1) * 2  # 2 spaces between columns
        $available = $this.TerminalWidth - $totalFixed - $padding - 4  # 4 for margins

        if ($flexColumns.Count -gt 0) {
            $flexWidth = [Math]::Max(8, [Math]::Floor($available / $flexColumns.Count))
            foreach ($col in $flexColumns) {
                $widths[$col] = $flexWidth
            }
        }

        return $widths
    }

    [string] FormatRow([object]$Item, [hashtable]$Widths, [bool]$IsHeader = $false, [int]$RowIndex = 0) {
        $parts = @()

        foreach ($col in $this.ColumnConfig.Keys) {
            $width = $Widths[$col]
            $formatted = ""
            $colConfig = $this.ColumnConfig[$col]

            if ($IsHeader) {
                $value = if ($colConfig.PSObject.Properties['Header']) { $colConfig.Header } else { $col }
            } else {
                $value = $this.GetItemValue($Item, $col)
            }

            # Apply truncation if needed
            if ($colConfig.PSObject.Properties['Truncate'] -and $colConfig.Truncate -and $value.Length -gt $width) {
                $value = $value.Substring(0, $width - 3) + "..."
            } elseif ($value.Length -gt $width) {
                $value = $value.Substring(0, $width)
            }

            # Apply alignment
            $alignment = if ($colConfig.PSObject.Properties['Alignment'] -and $colConfig.Alignment) { $colConfig.Alignment } else { "Left" }

            switch ($alignment) {
                "Right" { $formatted = $value.PadLeft($width) }
                "Center" {
                    $padding = $width - $value.Length
                    $leftPad = [Math]::Floor($padding / 2)
                    $rightPad = $padding - $leftPad
                    $formatted = " " * $leftPad + $value + " " * $rightPad
                }
                default { $formatted = $value.PadRight($width) }  # Left
            }

            # Apply theming to the formatted cell content
            $cellTheme = $this.GetCellTheme($Item, $col, $RowIndex, $IsHeader)
            $themedText = $this.ApplyTheme($formatted, $cellTheme)

            $parts += $themedText
        }

        return "  " + ($parts -join "  ")
    }

    [string] GetItemValue([object]$Item, [string]$ColumnName) {
        try {
            switch ($ColumnName) {
                "id" { return (Pmc-GetProp $Item 'id' '') -as [string] }
                "text" { return (Pmc-GetProp $Item 'text' '') -as [string] }
                "project" {
                    $projectId = (Pmc-GetProp $Item 'project' 'inbox') -as [string]
                    # Resolve project name if lookup is available
                    if ($this.ProjectLookup -and $this.ProjectLookup.PSObject.Properties[$projectId]) {
                        return $this.ProjectLookup[$projectId]
                    }
                    return $projectId
                }
                "due" {
                    $dueVal = (Pmc-GetProp $Item 'due' $null)
                    if ($dueVal) {
                        try {
                            $date = [datetime]$dueVal
                            return $date.ToString('MM/dd')
                        } catch {
                            return [string]$dueVal
                        }
                    }
                    return ""
                }
                "priority" {
                    $p = (Pmc-GetProp $Item 'priority' 0)
                    if ($p -and $p -le 3) {
                        return "P$($p)"
                    }
                    return ""
                }
                "status" { return if ($Item.status) { $Item.status } else { "pending" } }
                default {
                    # Dynamic property access
                    if ($Item.PSObject.Properties[$ColumnName]) {
                        return $Item.$ColumnName.ToString()
                    }
                    return ""
                }
            }
            return ""
        } catch {
            return ""
        }
    }

    [object[]] RenderGrid([object[]]$Data) {
        if (-not $Data -or $Data.Count -eq 0) {
            return @("  No data to display")
        }

        $widths = $this.GetColumnWidths($Data)
        $lines = @()

        # Render header (row index -1 for header)
        $headerLine = $this.FormatRow($null, $widths, $true, -1)
        $lines += $headerLine

        # Render separator with theming
        $separatorParts = @()
        foreach ($col in $this.ColumnConfig.Keys) {
            $separatorParts += "-" * $widths[$col]
        }
        $separatorLine = "  " + ($separatorParts -join "  ")
        # Apply separator styling using PMC's style system
        if ($this.ThemeConfig.Rows.PSObject.Properties['Separator']) {
            $sepStyle = $this.ThemeConfig.Rows.Separator
            if ($sepStyle.PSObject.Properties['Style']) {
                Write-PmcStyled -Style $sepStyle.Style -Text $separatorLine -NoNewline
                $lines += ""  # Add to lines array for consistency
            } else {
                $lines += $separatorLine
            }
        } else {
            $lines += $separatorLine
        }

        # Render data rows with row index
        $rowIndex = 0
        foreach ($item in $Data) {
            if ($item -ne $null) {
                $lines += $this.FormatRow($item, $widths, $false, $rowIndex)
                $rowIndex++
            }
        }

        return $lines
    }
}

function Get-PmcFilteredData {
    param(
        [string[]]$Domains,
        [hashtable]$Filters
    )

    $data = Get-PmcDataAlias
    $results = @()

    foreach ($domain in $Domains) {
        switch ($domain) {
            "task" {
                $items = if ($data.tasks) { @($data.tasks) } else { @() }

                # Apply filters
                if ($Filters.PSObject.Properties['status'] -and $Filters.status) {
                    $items = @($items | Where-Object { $_.PSObject.Properties['status'] -and $_.status -eq $Filters.status })
                }

                if ($Filters.PSObject.Properties['due_range'] -and $Filters.due_range) {
                    $today = (Get-Date).Date
                    switch ($Filters.due_range) {
                        "overdue_and_today" {
                            $items = @($items | Where-Object {
                                if (-not ($_.PSObject.Properties['due'] -and $_.due -and ($_.due -is [string]) -and $_.due -match '^\d{4}-\d{2}-\d{2}$')) { return $false }
                                $d = [datetime]::ParseExact([string]$_.due, 'yyyy-MM-dd', [Globalization.CultureInfo]::InvariantCulture)
                                return ($d.Date -le $today)
                            })
                        }
                        "today" {
                            $items = @($items | Where-Object {
                                if (-not ($_.PSObject.Properties['due'] -and $_.due -and ($_.due -is [string]) -and $_.due -match '^\d{4}-\d{2}-\d{2}$')) { return $false }
                                $d = [datetime]::ParseExact([string]$_.due, 'yyyy-MM-dd', [Globalization.CultureInfo]::InvariantCulture)
                                return ($d.Date -eq $today)
                            })
                        }
                        "overdue" {
                            $items = @($items | Where-Object {
                                if (-not ($_.PSObject.Properties['due'] -and $_.due -and ($_.due -is [string]) -and $_.due -match '^\d{4}-\d{2}-\d{2}$')) { return $false }
                                $d = [datetime]::ParseExact([string]$_.due, 'yyyy-MM-dd', [Globalization.CultureInfo]::InvariantCulture)
                                return ($d.Date -lt $today)
                            })
                        }
                    }
                }

                if ($Filters.PSObject.Properties['project'] -and $Filters.project) {
                    $items = @($items | Where-Object { $_.PSObject.Properties['project'] -and $_.project -eq $Filters.project })
                }

                $results += $items
            }
            "project" {
                $items = if ($data.projects) { @($data.projects) } else { @() }

                # Apply project filters if any
                if ($Filters.archived -eq $false) {
                    $items = @($items | Where-Object { (-not (Pmc-HasProp $_ 'isArchived')) -or (-not $_.isArchived) })
                }

                $results += $items
            }
            "timelog" {
                $items = if ($data.timelogs) { @($data.timelogs) } else { @() }
                $results += $items
            }
        }
    }

    return $results
}

function Show-PmcDataGrid {
    param(
        [string[]]$Domains = @("task"),
        [hashtable]$Columns = @{},
        [hashtable]$Filters = @{},
        [string]$Title = "",
        [hashtable]$Theme = @{}
    )

    Write-PmcDebug -Level 2 -Category "DataDisplay" -Message "Rendering data grid" -Data @{
        Domains = $Domains -join ","
        ColumnCount = $Columns.Keys.Count
        FilterCount = $Filters.Keys.Count
    }

    # Default column configuration for tasks
    if ($Columns.Keys.Count -eq 0 -and $Domains -contains "task") {
        $Columns = @{
            "id" = @{ Header = "#"; Width = 4; Alignment = "Right" }
            "text" = @{ Header = "Task"; Width = 35; Alignment = "Left" }
            "project" = @{ Header = "Project"; Width = 12; Alignment = "Left"; Truncate = $true }
            "due" = @{ Header = "Due"; Width = 8; Alignment = "Center" }
            "priority" = @{ Header = "P"; Width = 3; Alignment = "Center" }
        }
    }

    # Get filtered data
    $data = Get-PmcFilteredData -Domains $Domains -Filters $Filters

    # Display title if provided
    if ($Title) {
        Write-PmcStyled -Style 'Title' -Text "`n$Title"
        Write-PmcStyled -Style 'Border' -Text ("─" * 50)
    }

    if (-not $data -or @($data).Count -eq 0) {
        Write-PmcStyled -Style 'Muted' -Text "No items match the specified criteria"
        return
    }

    # Create renderer and display grid
    $renderer = [PmcGridRenderer]::new($Columns, $Domains, $Filters)

    # Apply theme configuration if provided
    if ($Theme.Count -gt 0) {
        $renderer.ThemeConfig = $renderer.InitializeTheme($Theme)
    }
    $gridLines = $renderer.RenderGrid($data)

    foreach ($line in $gridLines) {
        Write-Host $line
    }

    Write-PmcDebug -Level 2 -Category "DataDisplay" -Message "Grid rendering completed" -Data @{
        ItemCount = @($data).Count
        LineCount = @($gridLines).Count
    }
}

# Export functions for module manifest
Export-ModuleMember -Function Show-PmcDataGrid

===== END FILE: module/Pmc.Strict/src/DataDisplay.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/Debug.ps1 =====
# Structured Debug Logging System for PMC
# Multi-level debug output with file rotation and sensitive data redaction

Set-StrictMode -Version Latest

# Debug system state - now managed by centralized state
# State initialization moved to State.ps1

function Initialize-PmcDebugSystem {
    <#
    .SYNOPSIS
    Initializes the debug system based on configuration and command line arguments

    .PARAMETER Level
    Debug level (0=off, 1=basic, 2=detailed, 3=verbose)

    .PARAMETER LogPath
    Path to debug log file (relative to PMC root or absolute)
    #>
    param(
        [int]$Level = 0,
        [string]$LogPath = 'debug.log'
    )

    # Defer config loading to avoid circular dependency during initialization
    # Configuration will be applied later via Update-PmcDebugFromConfig

    # Override with explicit parameters
    if ($Level -gt 0) { Set-PmcState -Section 'Debug' -Key 'Level' -Value $Level }
    if ($LogPath -ne 'debug.log') { Set-PmcState -Section 'Debug' -Key 'LogPath' -Value $LogPath }

    # Check environment variables for debug settings
    if ($env:PMC_DEBUG) {
        try {
            $envLevel = [int]$env:PMC_DEBUG
            if ($envLevel -ge 1 -and $envLevel -le 3) {
                Set-PmcState -Section 'Debug' -Key 'Level' -Value $envLevel
            }
        } catch {
            # Environment variable parsing failed - skip environment override
        }
    }

    # Check PowerShell debug preference
    if ($DebugPreference -ne 'SilentlyContinue') {
        $debugState = Get-PmcDebugState
        Set-PmcState -Section 'Debug' -Key 'Level' -Value ([Math]::Max($debugState.Level, 1))
    }

    $debugState = Get-PmcDebugState
    if ($debugState.Level -gt 0) {
        Ensure-PmcDebugLogPath
        Write-PmcDebug -Level 1 -Category 'SYSTEM' -Message "Debug system initialized (Level=$($debugState.Level), Session=$($debugState.SessionId))"
    }
}

function Ensure-PmcDebugLogPath {
    try {
        $logPath = Get-PmcDebugLogPath
        $dir = Split-Path $logPath -Parent
        if (-not (Test-Path $dir)) {
            New-Item -ItemType Directory -Path $dir -Force | Out-Null
        }

        # Rotate log if it's too large
        if (Test-Path $logPath) {
            $size = (Get-Item $logPath).Length
            $debugState = Get-PmcDebugState
            if ($size -gt $debugState.MaxSize) {
                $oldPath = $logPath + '.old'
                if (Test-Path $oldPath) { Remove-Item $oldPath -Force }
                Move-Item $logPath $oldPath -Force
            }
        }
    } catch {
        # Debug log path setup failed - debug output may be unavailable
        Write-PmcDebug -Level 1 -Category 'SYSTEM' -Message "Debug log setup failed: $_"
    }
}

function Get-PmcDebugLogPath {
    $debugState = Get-PmcDebugState
    $logPath = $debugState.LogPath
    if ([System.IO.Path]::IsPathRooted($logPath)) {
        return $logPath
    }

    # Relative to PMC root directory (three levels up from src)
    $root = Split-Path (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent) -Parent
    return Join-Path $root $logPath
}

function Write-PmcDebug {
    <#
    .SYNOPSIS
    Writes a debug message with specified level and category

    .PARAMETER Level
    Debug level required for this message (1=basic, 2=detailed, 3=verbose)

    .PARAMETER Category
    Category/component name (e.g., COMMAND, COMPLETION, UI, STORAGE)

    .PARAMETER Message
    Debug message content

    .PARAMETER Data
    Optional structured data to include (hashtable/object)

    .PARAMETER Timing
    Optional timing information (milliseconds)
    #>
    param(
        [Parameter(Mandatory)]
        [ValidateRange(1,3)]
        [int]$Level,

        [Parameter(Mandatory)]
        [string]$Category,

        [Parameter(Mandatory)]
        [string]$Message,

        [object]$Data = $null,

        [int]$Timing = -1
    )

    # Skip if debug level is insufficient
    $debugState = Get-PmcDebugState
    if ($debugState.Level -lt $Level) { return }

    try {
        $timestamp = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss.fff')
        $session = $debugState.SessionId
        $levelName = @('', 'DBG1', 'DBG2', 'DBG3')[$Level]

        # Build base log entry
        $logEntry = "[$timestamp] [$session] [$levelName] [$Category] $Message"

        # Add timing if provided and enabled
        if ($Timing -ge 0 -and $debugState.IncludePerformance) {
            $logEntry += " (${Timing}ms)"
        }

        # Add structured data if provided
        if ($Data) {
            try {
                $dataJson = $Data | ConvertTo-Json -Compress -Depth 3
                $logEntry += " | Data: $dataJson"
            } catch {
                $logEntry += " | Data: [Serialization Error]"
            }
        }

        # Redact sensitive information if enabled
        if ($debugState.RedactSensitive) {
            $logEntry = Protect-PmcSensitiveData $logEntry
        }

        # Write to log file
        $logPath = Get-PmcDebugLogPath
        Add-Content -Path $logPath -Value $logEntry -Encoding UTF8

    } catch {
        # Silent failure - don't let debug logging break the application
    }
}

function Protect-PmcSensitiveData {
    param([string]$Text)

    try {
        # Redact common sensitive patterns
        $protected = $Text

        # API keys, tokens, secrets
        $protected = $protected -replace '((?i)(token|secret|password|passwd|apikey|api_key|key|pwd)\s*[:=]\s*)(\S+)', '$1****'

        # Long hex strings (potential secrets/hashes)
        $protected = $protected -replace '\b[0-9a-fA-F]{32,}\b', '****'

        # Email addresses
        $protected = $protected -replace '\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b', '****@****.***'

        # File paths that might contain usernames
        $protected = $protected -replace '([C-Z]:\\Users\\)([^\\]+)', '$1****'
        $protected = $protected -replace '(/home/)([^/]+)', '$1****'

        # Credit card numbers (basic pattern)
        $protected = $protected -replace '\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b', '****-****-****-****'

        # Social Security Numbers
        $protected = $protected -replace '\b\d{3}-\d{2}-\d{4}\b', '***-**-****'

        return $protected
    } catch {
        return $Text
    }
}

function Measure-PmcOperation {
    <#
    .SYNOPSIS
    Measures execution time of a script block and logs performance data

    .PARAMETER Name
    Operation name for logging

    .PARAMETER Category
    Debug category

    .PARAMETER ScriptBlock
    Code to execute and measure

    .PARAMETER Level
    Debug level for performance logging (default 2)
    #>
    param(
        [Parameter(Mandatory)]
        [string]$Name,

        [string]$Category = 'PERF',

        [Parameter(Mandatory)]
        [scriptblock]$ScriptBlock,

        [int]$Level = 2
    )

    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()

    try {
        $result = & $ScriptBlock
        $stopwatch.Stop()

        Write-PmcDebug -Level $Level -Category $Category -Message "$Name completed" -Timing $stopwatch.ElapsedMilliseconds

        return $result
    } catch {
        $stopwatch.Stop()
        Write-PmcDebug -Level 1 -Category $Category -Message "$Name failed: $_" -Timing $stopwatch.ElapsedMilliseconds
        throw
    }
}

function Write-PmcDebugCommand {
    <#
    .SYNOPSIS
    Debug logging specifically for command execution (Level 1)
    #>
    param(
        [Parameter(Mandatory)]
        [string]$Command,

        [string]$Status = 'EXECUTE',

        [object]$Context = $null,

        [int]$Timing = -1
    )

    Write-PmcDebug -Level 1 -Category 'COMMAND' -Message "$Status`: $Command" -Data $Context -Timing $Timing
}

function Write-PmcDebugCompletion {
    <#
    .SYNOPSIS
    Debug logging for completion system (Level 2)
    #>
    param(
        [Parameter(Mandatory)]
        [string]$Message,

        [object]$Data = $null,

        [int]$Timing = -1
    )

    Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message $Message -Data $Data -Timing $Timing
}

function Write-PmcDebugUI {
    <#
    .SYNOPSIS
    Debug logging for UI rendering (Level 3)
    #>
    param(
        [Parameter(Mandatory)]
        [string]$Message,

        [object]$Data = $null,

        [int]$Timing = -1
    )

    Write-PmcDebug -Level 3 -Category 'UI' -Message $Message -Data $Data -Timing $Timing
}

function Write-PmcDebugStorage {
    <#
    .SYNOPSIS
    Debug logging for storage operations (Level 2)
    #>
    param(
        [Parameter(Mandatory)]
        [string]$Operation,

        [string]$File = '',

        [object]$Data = $null,

        [int]$Timing = -1
    )

    $message = if ($File) { "$Operation`: $File" } else { $Operation }
    Write-PmcDebug -Level 2 -Category 'STORAGE' -Message $message -Data $Data -Timing $Timing
}

function Get-PmcDebugStatus {
    <#
    .SYNOPSIS
    Returns current debug system status and configuration
    #>

    $logPath = Get-PmcDebugLogPath
    $logSize = if (Test-Path $logPath) { (Get-Item $logPath).Length } else { 0 }

    $debugState = Get-PmcDebugState
    return [PSCustomObject]@{
        Enabled = ($debugState.Level -gt 0)
        Level = $debugState.Level
        LogPath = $logPath
        LogSize = $logSize
        MaxSize = $debugState.MaxSize
        RedactSensitive = $debugState.RedactSensitive
        IncludePerformance = $debugState.IncludePerformance
        SessionId = $debugState.SessionId
        Uptime = ((Get-Date) - $debugState.StartTime)
    }
}

function Show-PmcDebugLog {
    <#
    .SYNOPSIS
    Shows recent debug log entries

    .PARAMETER Lines
    Number of recent lines to show (default 50)

    .PARAMETER Category
    Filter by category (optional)
    #>
    param(
        [int]$Lines = 50,
        [string]$Category = ''
    )

    $logPath = Get-PmcDebugLogPath
    if (-not (Test-Path $logPath)) {
        Write-Host "No debug log found at: $logPath" -ForegroundColor Yellow
        return
    }

    try {
        $content = Get-Content $logPath -Tail $Lines

        if ($Category) {
            $content = $content | Where-Object { $_ -match "\[$Category\]" }
        }

        foreach ($line in $content) {
            # Color code by level and category
            if ($line -match '\[DBG1\]') {
                Write-Host $line -ForegroundColor Green
            } elseif ($line -match '\[DBG2\]') {
                Write-Host $line -ForegroundColor Yellow
            } elseif ($line -match '\[DBG3\]') {
                Write-Host $line -ForegroundColor Cyan
            } elseif ($line -match '\[ERROR\]') {
                Write-Host $line -ForegroundColor Red
            } else {
                Write-Host $line
            }
        }
    } catch {
        Write-Host "Error reading debug log: $_" -ForegroundColor Red
    }
}

function Update-PmcDebugFromConfig {
    <#
    .SYNOPSIS
    Updates debug settings from configuration after config provider is ready
    #>
    try {
        $cfg = Get-PmcConfig
        if ($cfg.Debug) {
            if ($cfg.Debug.Level -ne $null) { Set-PmcState -Section 'Debug' -Key 'Level' -Value ([int]$cfg.Debug.Level) }
            if ($cfg.Debug.LogPath) { Set-PmcState -Section 'Debug' -Key 'LogPath' -Value ([string]$cfg.Debug.LogPath) }
            if ($cfg.Debug.MaxSize) {
                try {
                    $maxSize = [int64]($cfg.Debug.MaxSize -replace '[^\d]','') * 1MB
                    Set-PmcState -Section 'Debug' -Key 'MaxSize' -Value $maxSize
                } catch {
                    # Configuration parsing failed - keep default MaxSize value
                }
            }
            if ($cfg.Debug.RedactSensitive -ne $null) { Set-PmcState -Section 'Debug' -Key 'RedactSensitive' -Value ([bool]$cfg.Debug.RedactSensitive) }
            if ($cfg.Debug.IncludePerformance -ne $null) { Set-PmcState -Section 'Debug' -Key 'IncludePerformance' -Value ([bool]$cfg.Debug.IncludePerformance) }
        }
    } catch {
        # Configuration loading failed - debug system will use defaults
    }
}

# Note: Debug system is initialized by the root orchestrator after config providers are set

===== END FILE: module/Pmc.Strict/src/Debug.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/Dependencies.ps1 =====
# Dependencies System Implementation
# Based on t2.ps1 dependencies functionality

function Update-PmcBlockedStatus {
    param($data = (Get-PmcDataAlias))

    Write-PmcDebug -Level 3 -Category "Dependencies" -Message "Updating blocked status for all tasks"

    # Clear all blocked status first
    foreach ($task in @($data.tasks)) {
        if ($null -eq $task) { continue }
        if (Pmc-HasProp $task 'blocked') { $task.PSObject.Properties.Remove('blocked') }
    }

    # Set blocked status for tasks with pending dependencies
    foreach ($task in @($data.tasks) | Where-Object {
        $null -ne $_ -and
        (Pmc-HasProp $_ 'depends') -and
        $_.depends -and
        $_.depends.Count -gt 0
    }) {
        $blockers = $data.tasks | Where-Object {
            Pmc-HasProp $_ 'id' -and ($_.id -in $task.depends) -and (Pmc-HasProp $_ 'status') -and $_.status -eq 'pending'
        }
        $isBlocked = ($blockers.Count -gt 0)

        if ($isBlocked) {
            if (Pmc-HasProp $task 'blocked') { $task.blocked = $true } else { Add-Member -InputObject $task -MemberType NoteProperty -Name blocked -Value $true }
        }
    }

    Write-PmcDebug -Level 3 -Category "Dependencies" -Message "Blocked status update completed"
}

function Add-PmcDependency {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "Dependencies" -Message "Starting dep add" -Data @{ FreeText = $Context.FreeText }

    $data = Get-PmcDataAlias
    $ids = $Context.FreeText

    if ($ids.Count -lt 2) {
        Write-Host "Usage: dep add <task> <depends-on>" -ForegroundColor Yellow
        return
    }

    $taskId = $null
    $dependsOnId = $null

    # Resolve task IDs
    if ($ids[0] -match '^\d+$') { $taskId = [int]$ids[0] }
    if ($ids[1] -match '^\d+$') { $dependsOnId = [int]$ids[1] }

    if (-not $taskId -or -not $dependsOnId) {
        Write-Host "Invalid task IDs" -ForegroundColor Red
        return
    }

    $task = $data.tasks | Where-Object { $_.id -eq $taskId } | Select-Object -First 1
    $dependsOnTask = $data.tasks | Where-Object { $_.id -eq $dependsOnId } | Select-Object -First 1

    if (-not $task) {
        Write-Host "Task #$taskId not found" -ForegroundColor Red
        return
    }

    if (-not $dependsOnTask) {
        Write-Host "Task #$dependsOnId not found" -ForegroundColor Red
        return
    }

    # Initialize depends array if needed
    if (-not (Pmc-HasProp $task 'depends')) { $task | Add-Member -NotePropertyName depends -NotePropertyValue @() -Force }

    # Check if dependency already exists
    if ($task.depends -contains $dependsOnId) {
        Write-Host "Dependency already exists" -ForegroundColor Yellow
        return
    }

    # Add dependency
    $task.depends = @($task.depends + $dependsOnId)

    # Update blocked status for all tasks
    Update-PmcBlockedStatus -data $data

    Save-StrictData $data 'dep add'
    Write-Host "Added dependency: Task #$taskId depends on Task #$dependsOnId" -ForegroundColor Green

    Write-PmcDebug -Level 2 -Category "Dependencies" -Message "Dependency added successfully" -Data @{ TaskId = $taskId; DependsOn = $dependsOnId }
}

function Remove-PmcDependency {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "Dependencies" -Message "Starting dep remove" -Data @{ FreeText = $Context.FreeText }

    $data = Get-PmcDataAlias
    $ids = $Context.FreeText

    if ($ids.Count -lt 2) {
        Write-Host "Usage: dep remove <task> <depends-on>" -ForegroundColor Yellow
        return
    }

    $taskId = $null
    $dependsOnId = $null

    # Resolve task IDs
    if ($ids[0] -match '^\d+$') { $taskId = [int]$ids[0] }
    if ($ids[1] -match '^\d+$') { $dependsOnId = [int]$ids[1] }

    if (-not $taskId -or -not $dependsOnId) {
        Write-Host "Invalid task IDs" -ForegroundColor Red
        return
    }

    $task = $data.tasks | Where-Object { $_.id -eq $taskId } | Select-Object -First 1

    if (-not $task -or -not (Pmc-HasProp $task 'depends') -or -not $task.depends) {
        Write-Host "No such dependency found" -ForegroundColor Yellow
        return
    }

    # Remove dependency
    $task.depends = @($task.depends | Where-Object { $_ -ne $dependsOnId })

    # Clean up empty depends array
    if ($task.depends.Count -eq 0) { try { $task.PSObject.Properties.Remove('depends') } catch {} }

    # Update blocked status for all tasks
    Update-PmcBlockedStatus -data $data

    Save-StrictData $data 'dep remove'
    Write-Host "Removed dependency: Task #$taskId no longer depends on Task #$dependsOnId" -ForegroundColor Green

    Write-PmcDebug -Level 2 -Category "Dependencies" -Message "Dependency removed successfully" -Data @{ TaskId = $taskId; DependsOn = $dependsOnId }
}

function Show-PmcDependencies {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "Dependencies" -Message "Starting dep show" -Data @{ FreeText = $Context.FreeText }

    $data = Get-PmcDataAlias
    $text = ($Context.FreeText -join ' ').Trim()

    if (-not $text) {
        Write-Host "Usage: dep show <task>" -ForegroundColor Yellow
        return
    }

    $taskId = $null
    if ($text -match '^\d+$') { $taskId = [int]$text }

    if (-not $taskId) {
        Write-Host "Invalid task ID" -ForegroundColor Red
        return
    }

    $task = $data.tasks | Where-Object { $_.id -eq $taskId } | Select-Object -First 1

    if (-not $task) {
        Write-Host "Task #$taskId not found" -ForegroundColor Red
        return
    }

    Write-Host "`nDEPENDENCIES for Task #$taskId" -ForegroundColor Cyan
    Write-Host ("Task: {0}" -f $task.text) -ForegroundColor White
    Write-Host "─────────────────────────────────" -ForegroundColor DarkGray

    $depends = if ((Pmc-HasProp $task 'depends') -and $task.depends) { $task.depends } else { @() }

    if ($depends.Count -eq 0) {
        Write-Host "  No dependencies" -ForegroundColor Gray
        return
    }

    $rows = @()
    foreach ($depId in $depends) {
        $depTask = $data.tasks | Where-Object { $_.id -eq $depId } | Select-Object -First 1
        $status = if ($depTask) { $depTask.status } else { 'missing' }
        $text = if ($depTask) { $depTask.text } else { '(missing task)' }
        $rows += @{ id = "#$depId"; status = $status; text = $text }
    }

    $cols = @(
        @{ key='id'; title='ID'; width=6 },
        @{ key='status'; title='Status'; width=10 },
        @{ key='text'; title='Task'; width=50 }
    )

    Show-PmcTable -Columns $cols -Rows $rows -Title "Dependencies for Task #$taskId"

    # Show if this task is blocked
    if ($task.blocked) {
        Write-Host "`n⚠️  This task is BLOCKED by pending dependencies" -ForegroundColor Red
    } else {
        Write-Host "`n✅ This task is ready to work on" -ForegroundColor Green
    }

    Write-PmcDebug -Level 2 -Category "Dependencies" -Message "Dependencies shown successfully" -Data @{ TaskId = $taskId; DependencyCount = $depends.Count }
}

function Show-PmcDependencyGraph {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "Dependencies" -Message "Starting dep graph"

    $data = Get-PmcDataAlias
    $rows = @()

    foreach ($task in $data.tasks) {
        if ((Pmc-HasProp $task 'depends') -and @($task.depends).Count -gt 0) {
            $dependsText = ($task.depends -join ', ')
            $status = if ($task.blocked) { "🔒 BLOCKED" } else { "✅ Ready" }
            $rows += @{
                task = "#$($task.id)"
                depends = $dependsText
                status = $status
                text = $task.text
            }
        }
    }

    if (@($rows).Count -eq 0) {
        Write-Host "`nDEPENDENCY GRAPH" -ForegroundColor Cyan
        Write-Host "No task dependencies found" -ForegroundColor Gray
        return
    }

    $cols = @(
        @{ key='task'; title='Task'; width=8 },
        @{ key='depends'; title='Depends On'; width=15 },
        @{ key='status'; title='Status'; width=12 },
        @{ key='text'; title='Description'; width=40 }
    )

    Show-PmcTable -Columns $cols -Rows $rows -Title 'DEPENDENCY GRAPH'

    # Summary statistics
    $blockedCount = @($data.tasks | Where-Object { $_.blocked }).Count
    $dependentCount = @($data.tasks | Where-Object { (Pmc-HasProp $_ 'depends') -and $_.depends }).Count

    Write-Host "`nSummary:" -ForegroundColor Cyan
    Write-Host "  Tasks with dependencies: $dependentCount" -ForegroundColor White
    Write-Host "  Currently blocked tasks: $blockedCount" -ForegroundColor $(if ($blockedCount -gt 0) { 'Red' } else { 'Green' })

    Write-PmcDebug -Level 2 -Category "Dependencies" -Message "Dependency graph shown successfully" -Data @{ DependentTasks = $dependentCount; BlockedTasks = $blockedCount }
}

===== END FILE: module/Pmc.Strict/src/Dependencies.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/Excel.ps1 =====
# ExcelT2020.ps1 - Secure Excel T2020 integration for PMC
# Enhanced with PMC security, error handling, and logging

# =============================
# Secure Excel COM Management
# =============================

$script:ExcelApp = $null
$script:ExcelTimeout = 30000  # 30 seconds

function New-SecureExcelApp {
    [CmdletBinding()]
    param()

    if ($script:ExcelApp -ne $null) {
        Write-PmcDebug -Level 2 -Category 'EXCEL' -Message 'Reusing existing Excel application'
        return $script:ExcelApp
    }

    try {
        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message 'Creating new Excel COM application'
        $app = New-Object -ComObject Excel.Application
        $app.Visible = $false
        $app.DisplayAlerts = $false
        $app.EnableEvents = $false
        $app.ScreenUpdating = $false
        $script:ExcelApp = $app

        Write-PmcDebug -Level 2 -Category 'EXCEL' -Message "Excel application created (PID: $($app.Hwnd))"
        return $script:ExcelApp
    } catch {
        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message "Excel COM creation failed: $_"
        throw "Excel COM is not available. Ensure Excel is installed. Error: $_"
    }
}

function Close-SecureExcelApp {
    [CmdletBinding()]
    param()

    if ($script:ExcelApp -eq $null) { return }

    try {
        Write-PmcDebug -Level 2 -Category 'EXCEL' -Message 'Closing Excel application'
        $script:ExcelApp.Quit()
        [void][Runtime.InteropServices.Marshal]::ReleaseComObject($script:ExcelApp)
        $script:ExcelApp = $null
        Write-PmcDebug -Level 2 -Category 'EXCEL' -Message 'Excel application closed successfully'
    } catch {
        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message "Excel cleanup error: $_"
        $script:ExcelApp = $null
    }
}

function Open-SecureWorkbook {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [string]$Path,
        [switch]$ReadOnly
    )

    # Security: Validate path using PMC security system
    if (-not (Test-PmcPathSafety -Path $Path -Operation 'read')) {
        throw "Path security validation failed: $Path"
    }

    # Security: Check file size
    $securityStatus = Get-PmcSecurityStatus
    if (Test-Path $Path) {
        $fileSize = (Get-Item $Path).Length
        if ($fileSize -gt $securityStatus.MaxFileSize) {
            throw "File too large: $([Math]::Round($fileSize/1MB,1))MB exceeds limit of $([Math]::Round($securityStatus.MaxFileSize/1MB,1))MB"
        }
    } else {
        throw "Workbook not found: $Path"
    }

    $app = New-SecureExcelApp

    try {
        Write-PmcDebug -Level 2 -Category 'EXCEL' -Message "Opening workbook: $(Split-Path $Path -Leaf)"
        $workbook = $app.Workbooks.Open($Path, $false, [bool]$ReadOnly)
        Write-PmcDebug -Level 3 -Category 'EXCEL' -Message "Workbook opened successfully with $($workbook.Worksheets.Count) worksheets"
        return $workbook
    } catch {
        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message "Failed to open workbook: $_"
        throw "Failed to open workbook '$(Split-Path $Path -Leaf)': $_"
    }
}

function Save-SecureWorkbook {
    [CmdletBinding()]
    param([Parameter(Mandatory)] $Workbook)

    try {
        Write-PmcDebug -Level 2 -Category 'EXCEL' -Message "Saving workbook: $($Workbook.Name)"
        $Workbook.Save()
        Write-PmcDebug -Level 3 -Category 'EXCEL' -Message 'Workbook saved successfully'
    } catch {
        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message "Save failed: $_"
        throw "Failed to save workbook '$($Workbook.Name)': $_"
    }
}

function Close-SecureWorkbook {
    [CmdletBinding()]
    param([Parameter(Mandatory)] $Workbook)

    try {
        Write-PmcDebug -Level 3 -Category 'EXCEL' -Message "Closing workbook: $($Workbook.Name)"
        $Workbook.Close($false)
    } catch {
        Write-PmcDebug -Level 2 -Category 'EXCEL' -Message "Workbook close error: $_"
    }
}

function Get-SecureWorksheet {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] $Workbook,
        [Parameter(Mandatory)] [string]$Name
    )

    try {
        $worksheet = $Workbook.Worksheets.Item($Name)
        Write-PmcDebug -Level 3 -Category 'EXCEL' -Message "Found worksheet: $Name"
        return $worksheet
    } catch {
        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message "Worksheet '$Name' not found in '$($Workbook.Name)'"
        throw "Worksheet '$Name' not found in '$($Workbook.Name)'"
    }
}

# =============================
# Enhanced T2020 Operations
# =============================

function Get-ExcelT2020Config {
    [CmdletBinding()]
    param()

    $config = Get-StrictConfig
    if (-not $config.Excel) {
        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message 'Excel config not found, using defaults'
        return @{
            SourceFolder = Join-Path $PSScriptRoot 'excel_input'
            DestinationPath = Join-Path $PSScriptRoot 'excel_output.xlsm'
            SourceSheet = 'SVI-CAS'
            DestSheet = 'Output'
            ID2FieldName = 'CASNumber'
            Mappings = @(
                @{ Field='RequestDate';    SourceCell='W23'; DestCell='B2'  }
                @{ Field='AuditType';      SourceCell='W78'; DestCell='B3'  }
                @{ Field='AuditorName';    SourceCell='W10'; DestCell='B4'  }
                @{ Field='TPName';         SourceCell='W3';  DestCell='B5'  }
                @{ Field='TPEmailAddress'; SourceCell='X3';  DestCell='B6'  }
                @{ Field='TPPhoneNumber';  SourceCell='Y3';  DestCell='B7'  }
                @{ Field='TaxID';          SourceCell='W13'; DestCell='B8'  }
                @{ Field='CASNumber';      SourceCell='G17'; DestCell='B9'  }
            )
            AllowedExtensions = @('.xlsm', '.xlsx')
            MaxFileSize = '50MB'
        }
    }
    return $config.Excel
}

function Copy-SecureCellValue {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] $SourceSheet,
        [Parameter(Mandatory)] [string]$SourceCell,
        [Parameter(Mandatory)] $DestSheet,
        [Parameter(Mandatory)] [string]$DestCell
    )

    try {
        $srcRange = $SourceSheet.Range($SourceCell)
        $dstRange = $DestSheet.Range($DestCell)

        $val = $srcRange.Value2
        if ($null -eq $val -or $val -eq '') {
            $dstRange.Value2 = ''
            Write-PmcDebug -Level 3 -Category 'EXCEL' -Message "Cleared cell $DestCell (source $SourceCell was empty)"
        } else {
            # Sanitize value for security
            $sanitizedVal = Protect-PmcUserInput -Input $val.ToString() -InputType 'data'
            $srcRange.Copy() | Out-Null
            $dstRange.PasteSpecial(-4163) | Out-Null  # xlPasteValues
            (New-SecureExcelApp).CutCopyMode = 0
            Write-PmcDebug -Level 3 -Category 'EXCEL' -Message "Copied ${SourceCell} -> ${DestCell}: $(($sanitizedVal -replace '(.{20}).*', '$1...'))"
        }
    } catch {
        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message "Cell copy failed ${SourceCell} -> ${DestCell}: $_"
        throw "Failed to copy cell ${SourceCell} to ${DestCell}: $_"
    }
}

function Extract-T2020FieldsSecure {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [string]$SourcePath,
        [string]$SourceSheetName,
        [array]$Mappings
    )

    $config = Get-ExcelT2020Config
    if (-not $SourceSheetName) { $SourceSheetName = $config.SourceSheet }
    if (-not $Mappings) { $Mappings = $config.Mappings }

    $srcWb = $null
    try {
        Write-PmcDebug -Level 2 -Category 'EXCEL' -Message "Extracting fields from: $(Split-Path $SourcePath -Leaf)"
        $srcWb = Open-SecureWorkbook -Path $SourcePath -ReadOnly
        $wsSrc = Get-SecureWorksheet -Workbook $srcWb -Name $SourceSheetName

        $data = [ordered]@{}
        foreach ($m in $Mappings) {
            try {
                $val = $wsSrc.Range($m.SourceCell).Value2
                # Sanitize extracted data
                $sanitizedVal = if ($val) { Protect-PmcUserInput -Input $val.ToString() -InputType 'data' } else { '' }
                $data[$m.Field] = $sanitizedVal
                Write-PmcDebug -Level 3 -Category 'EXCEL' -Message "Extracted $($m.Field): $(($sanitizedVal -replace '(.{15}).*', '$1...'))"
            } catch {
                Write-PmcDebug -Level 2 -Category 'EXCEL' -Message "Failed to extract field $($m.Field) from $($m.SourceCell): $_"
                $data[$m.Field] = ''
            }
        }

        Write-PmcDebug -Level 2 -Category 'EXCEL' -Message "Successfully extracted $($data.Count) fields"
        return @{ Success=$true; Data=$data; Source=$SourcePath }
    } catch {
        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message "Extract operation failed: $_"
        return @{ Success=$false; Error="Extract failed: $_"; Source=$SourcePath }
    } finally {
        if ($srcWb) { Close-SecureWorkbook -Workbook $srcWb }
    }
}

function Copy-T2020ForFileSecure {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [string]$SourcePath,
        [Parameter(Mandatory)] [string]$DestinationPath,
        [string]$SourceSheetName,
        [string]$DestSheetName,
        [array]$Mappings
    )

    $config = Get-ExcelT2020Config
    if (-not $SourceSheetName) { $SourceSheetName = $config.SourceSheet }
    if (-not $DestSheetName) { $DestSheetName = $config.DestSheet }
    if (-not $Mappings) { $Mappings = $config.Mappings }

    # Security: Validate destination path
    if (-not (Test-PmcPathSafety -Path $DestinationPath -Operation 'write')) {
        throw "Destination path security validation failed: $DestinationPath"
    }

    $srcWb = $null
    $dstWb = $null
    try {
        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message "Starting T2020 copy: $(Split-Path $SourcePath -Leaf) -> $(Split-Path $DestinationPath -Leaf)"

        $srcWb = Open-SecureWorkbook -Path $SourcePath -ReadOnly
        $dstWb = Open-SecureWorkbook -Path $DestinationPath

        $wsSrc = Get-SecureWorksheet -Workbook $srcWb -Name $SourceSheetName
        $wsDst = Get-SecureWorksheet -Workbook $dstWb -Name $DestSheetName

        $copiedFields = 0
        foreach ($m in $Mappings) {
            try {
                Copy-SecureCellValue -SourceSheet $wsSrc -SourceCell $m.SourceCell -DestSheet $wsDst -DestCell $m.DestCell
                $copiedFields++
            } catch {
                Write-PmcDebug -Level 2 -Category 'EXCEL' -Message "Field copy failed for $($m.Field): $_"
            }
        }

        Save-SecureWorkbook -Workbook $dstWb
        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message "T2020 copy completed: $copiedFields/$($Mappings.Count) fields copied"

        return @{
            Success=$true;
            Message="Copied $copiedFields/$($Mappings.Count) fields from '$(Split-Path $SourcePath -Leaf)' to '$(Split-Path $DestinationPath -Leaf)'"
            FieldsCopied=$copiedFields
            TotalFields=$Mappings.Count
        }
    } catch {
        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message "T2020 copy operation failed: $_"
        return @{ Success=$false; Error="Copy failed: $_" }
    } finally {
        if ($srcWb) { Close-SecureWorkbook -Workbook $srcWb }
        if ($dstWb) { Close-SecureWorkbook -Workbook $dstWb }
    }
}

function Invoke-T2020BatchSecure {
    [CmdletBinding()]
    param(
        [string]$SourceFolder,
        [string]$DestinationPath,
        [string]$SourcePattern = '*.xlsm',
        [switch]$WhatIf
    )

    try {
        $config = Get-ExcelT2020Config
        if (-not $SourceFolder) { $SourceFolder = $config.SourceFolder }
        if (-not $DestinationPath) { $DestinationPath = $config.DestinationPath }

        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message "Starting T2020 batch import from: $SourceFolder"

        # Security: Validate source folder
        if (-not (Test-PmcPathSafety -Path $SourceFolder -Operation 'read')) {
            throw "Source folder security validation failed: $SourceFolder"
        }

        if (-not (Test-Path $SourceFolder)) {
            throw "Source folder not found: $SourceFolder"
        }

        $allowedExts = $config.AllowedExtensions
        $files = Get-ChildItem -Path $SourceFolder -Filter $SourcePattern -File |
                 Where-Object { $_.Extension -in $allowedExts } |
                 Sort-Object Name

        if ($files.Count -eq 0) {
            Write-PmcDebug -Level 1 -Category 'EXCEL' -Message "No valid files found in source folder"
            return @{ Success=$true; Message='No files found'; Processed=0; Summary=@() }
        }

        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message "Found $($files.Count) files to process"

        if ($WhatIf) {
            foreach ($f in $files) {
                Write-PmcStyled -Style 'Warning' -Text ("  Would process: {0}" -f $f.Name)
            }
            return @{ Success=$true; Message="WhatIf: Would process $($files.Count) files"; Processed=0; Summary=@() }
        }

        $processed = 0
        $summary = @()

        foreach ($f in $files) {
            Write-PmcDebug -Level 2 -Category 'EXCEL' -Message "Processing file: $($f.Name)"

            $extract = Extract-T2020FieldsSecure -SourcePath $f.FullName
            $copy = Copy-T2020ForFileSecure -SourcePath $f.FullName -DestinationPath $DestinationPath

            $success = ($extract.Success -and $copy.Success)
            if ($success) { $processed++ }

            $record = [ordered]@{
                Timestamp = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
                Source = $f.Name  # Only filename for security
                Success = $success
                FieldsCopied = if ($copy.FieldsCopied) { $copy.FieldsCopied } else { 0 }
                TotalFields = if ($copy.TotalFields) { $copy.TotalFields } else { 0 }
                Error = if ($success) { '' } else { ($copy.Error ?? $extract.Error) }
                Fields = if ($extract.Success) { $extract.Data } else { @{} }
            }
            $summary += $record

            if ($success) {
                Write-PmcDebug -Level 1 -Category 'EXCEL' -Message "✓ Processed: $($f.Name) ($($record.FieldsCopied)/$($record.TotalFields) fields)"
            } else {
                Write-PmcDebug -Level 1 -Category 'EXCEL' -Message "✗ Failed: $($f.Name) - $($record.Error)"
            }
        }

        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message "T2020 batch import completed: $processed/$($files.Count) files processed successfully"

        return @{
            Success=$true;
            Processed=$processed;
            Total=$files.Count;
            Summary=$summary
        }

    } catch {
        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message "T2020 batch import failed: $_"
        return @{ Success=$false; Error=$_.ToString(); Summary=@() }
    } finally {
        # Always cleanup Excel
        Close-SecureExcelApp
    }
}

# =============================
# PMC Excel Command Functions
# =============================

function Import-PmcFromExcel {
    [CmdletBinding()]
    param([PmcCommandContext]$Context)

    try {
        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message 'Starting Excel import command'

        $result = Invoke-T2020BatchSecure -WhatIf:$Context.Args.ContainsKey('whatif')

        if (-not $result.Success) {
            Write-PmcStyled -Style 'Error' -Text ("Excel import failed: {0}" -f $result.Error)
            return
        }

        # Display summary table
        if ($result.Summary.Count -gt 0) {
            $rows = @()
            foreach ($record in $result.Summary) {
                $status = if ($record.Success) { '✓' } else { '✗' }
                $fields = "$($record.FieldsCopied)/$($record.TotalFields)"
                $rows += @($record.Timestamp, $record.Source, $fields, $status)
            }

            # Use PMC's table formatting
            $headers = @('Time', 'File', 'Fields', 'Status')
            # TODO: Replace with actual PMC table formatter when available
            Write-PmcStyled -Style 'Info' -Text "`n  Excel T2020 Import Results:"
            Write-PmcStyled -Style 'Border' -Text ("  " + ("-" * 60))

            $headerLine = "  {0,-19} {1,-20} {2,-8} {3,-6}" -f $headers
            Write-Host $headerLine -ForegroundColor Yellow
            Write-Host "  " + ("-" * 60) -ForegroundColor DarkGray

            foreach ($row in $rows) {
                $color = if ($row[3] -eq '✓') { 'Green' } else { 'Red' }
                $line = "  {0,-19} {1,-20} {2,-8} {3,-6}" -f $row
                Write-PmcStyled -Style (if ($color -eq 'Green') { 'Success' } elseif ($color -eq 'Yellow') { 'Warning' } else { 'Error' }) -Text $line
            }
            Write-Host ""
        }

        $successCount = ($result.Summary | Where-Object { $_.Success }).Count
        Write-PmcStyled -Style 'Success' -Text ("  Processed {0}/{1} files successfully" -f $successCount, $result.Total)

        # Store import history in PMC data for 'excel latest' command
        $data = Get-PmcData
        if (-not $data.excelImports) {
            $data | Add-Member -NotePropertyName excelImports -NotePropertyValue @() -Force
        }
        $data.excelImports += $result.Summary

        # Keep only last 50 imports
        if ($data.excelImports.Count -gt 50) {
            $data.excelImports = $data.excelImports[-50..-1]
        }

        Save-PmcData -Data $data

        # Attempt to bind imported fields to existing projects (safe, ID2-based)
        try {
            Invoke-PmcExcelBinding -Records $result.Summary | Out-Null
        } catch {
            Write-PmcDebug -Level 1 -Category 'EXCEL' -Message ("Binding step failed: {0}" -f $_)
        }

    } catch {
        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message "Excel import command failed: $_"
        Write-PmcStyled -Style 'Error' -Text ("Excel import error: {0}" -f $_)
    }
}

# Safe binder: attaches imported Excel fields to existing projects using ID2 only
function Invoke-PmcExcelBinding {
    [CmdletBinding()]
    param([Parameter(Mandatory)] [array]$Records)

    Write-PmcDebug -Level 1 -Category 'EXCEL' -Message 'Binding Excel records to projects (ID2)'

    $data = Get-PmcData
    if (-not $data -or -not $data.projects) { Write-PmcDebug -Level 1 -Category 'EXCEL' -Message 'No data/projects available'; return @{ Updated=0; Matched=0; Skipped=0 } }

    $cfg = Get-ExcelT2020Config
    $id2Field = if ($cfg.ID2FieldName) { [string]$cfg.ID2FieldName } else { 'CASNumber' }

    $updated = 0; $matched = 0; $skipped = 0
    foreach ($rec in $Records) {
        try {
            if (-not $rec.Success) { $skipped++; continue }
            if (-not $rec.Fields) { $skipped++; continue }
            if (-not $rec.Fields.ContainsKey($id2Field)) { $skipped++; continue }
            $val = [string]$rec.Fields[$id2Field]
            if ([string]::IsNullOrWhiteSpace($val)) { $skipped++; continue }

            $proj = ($data.projects | Where-Object { $_ -ne $null -and $_.PSObject.Properties['ID2'] -and [string]$_.ID2 -eq $val } | Select-Object -First 1)
            if (-not $proj) { $skipped++; continue }

            $matched++
            # Optionally map additional fields if configured (only non-empty values; do not overwrite non-empty)
            $maps = @()
            if ($cfg.PSObject.Properties['ProjectFieldMappings']) { $maps = @($cfg.ProjectFieldMappings) }
            foreach ($m in $maps) {
                try {
                    $from = [string]$m['From']; $to = [string]$m['To']
                    if (-not $from -or -not $to) { continue }
                    if (-not $rec.Fields.ContainsKey($from)) { continue }
                    $v = [string]$rec.Fields[$from]
                    if ([string]::IsNullOrWhiteSpace($v)) { continue }
                    $existing = if ($proj.PSObject.Properties[$to]) { [string]$proj.$to } else { '' }
                    if ([string]::IsNullOrWhiteSpace($existing)) {
                        $proj | Add-Member -NotePropertyName $to -NotePropertyValue $v -Force
                        $updated++
                        Write-PmcDebug -Level 2 -Category 'EXCEL' -Message ("Project '{0}' set {1}='{2}'" -f $proj.name, $to, $v)
                    }
                } catch {
                    Write-PmcDebug -Level 2 -Category 'EXCEL' -Message ("Mapping failed: {0}" -f $_)
                }
            }
        } catch {
            $skipped++
            Write-PmcDebug -Level 2 -Category 'EXCEL' -Message ("Record bind error: {0}" -f $_)
        }
    }

    if ($updated -gt 0) { Save-PmcData -Data $data }
    Write-PmcDebug -Level 1 -Category 'EXCEL' -Message ("Binding finished (matched={0}, updated={1}, skipped={2})" -f $matched, $updated, $skipped)
    return @{ Updated=$updated; Matched=$matched; Skipped=$skipped }
}

function Bind-PmcExcelImports {
    [CmdletBinding()]
    param([PmcCommandContext]$Context)

    try {
        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message 'Starting Excel bind command'
        $data = Get-PmcData
        if (-not $data.excelImports -or $data.excelImports.Count -eq 0) {
            Write-PmcStyled -Style 'Warning' -Text 'No Excel import records to bind.'
            return
        }
        $result = Invoke-PmcExcelBinding -Records $data.excelImports
        Write-PmcStyled -Style 'Success' -Text ("Excel binding complete. Matched={0} Updated={1} Skipped={2}" -f $result.Matched, $result.Updated, $result.Skipped)
    } catch {
        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message ("Excel bind command failed: {0}" -f $_)
        Write-PmcStyled -Style 'Error' -Text ("Excel bind error: {0}" -f $_)
    }
}

# Wrappers to align with CommandMap function names
function Import-PmcExcelData { param([PmcCommandContext]$Context) Import-PmcFromExcel -Context $Context }
function Show-PmcExcelPreview { param([PmcCommandContext]$Context) Show-PmcExcelData -Context $Context }
function Get-PmcLatestExcelFile { param([PmcCommandContext]$Context) Get-PmcLatestExcelData -Context $Context }

function Show-PmcExcelData {
    [CmdletBinding()]
    param([PmcCommandContext]$Context)

    try {
        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message 'Starting Excel view command'

        $config = Get-ExcelT2020Config
        $sourceFolder = $config.SourceFolder

        if (-not (Test-Path $sourceFolder)) {
            Write-PmcStyled -Style 'Error' -Text ("Source folder not found: {0}" -f $sourceFolder)
            return
        }

        $files = Get-ChildItem -Path $sourceFolder -Filter '*.xlsm' -File |
                 Where-Object { $_.Extension -in $config.AllowedExtensions } |
                 Sort-Object Name

        if ($files.Count -eq 0) {
            Write-PmcStyled -Style 'Warning' -Text ("No Excel files found in: {0}" -f $sourceFolder)
            return
        }

        # Preview first file's data
        $firstFile = $files[0]
        Write-PmcStyled -Style 'Info' -Text "`n  Excel T2020 Preview:"
        Write-PmcStyled -Style 'Muted' -Text ("  Source: {0}" -f $sourceFolder)
        Write-PmcStyled -Style 'Muted' -Text ("  Files found: {0}" -f $files.Count)
        Write-PmcStyled -Style 'Muted' -Text ("  Preview from: {0}" -f $firstFile.Name)
        Write-Host ""

        $extract = Extract-T2020FieldsSecure -SourcePath $firstFile.FullName

        if ($extract.Success) {
            $rows = @()
            foreach ($field in $extract.Data.GetEnumerator()) {
                $value = if ($field.Value) {
                    if ($field.Value.ToString().Length -gt 30) {
                        $field.Value.ToString().Substring(0, 27) + "..."
                    } else {
                        $field.Value.ToString()
                    }
                } else {
                    "(empty)"
                }
                $rows += @($field.Key, $value)
            }

            # Simple table display
            Write-PmcStyled -Style 'Warning' -Text "  Field Mappings:"
            Write-PmcStyled -Style 'Border' -Text ("  " + ("-" * 50))
            foreach ($row in $rows) {
                Write-PmcStyled -Style 'Body' -Text ("  {0,-15} {1}" -f $row[0], $row[1])
            }
            Write-Host ""
        } else {
            Write-PmcStyled -Style 'Error' -Text ("  Failed to preview: {0}" -f $extract.Error)
        }

    } catch {
        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message "Excel view command failed: $_"
        Write-PmcStyled -Style 'Error' -Text ("Excel view error: {0}" -f $_)
    }
}

function Get-PmcLatestExcelData {
    [CmdletBinding()]
    param([PmcCommandContext]$Context)

    try {
        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message 'Starting Excel latest command'

        $data = Get-PmcData
        $imports = @($data.excelImports)

        if ($imports.Count -eq 0) {
            Write-PmcStyled -Style 'Warning' -Text "No Excel imports found. Run 'excel import' first."
            return
        }

        # Show last 10 imports
        $recent = $imports | Select-Object -Last 10

        Write-PmcStyled -Style 'Info' -Text "`n  Recent Excel Imports:"
        Write-Host "  " + ("-" * 70) -ForegroundColor DarkGray

        $headerLine = "  {0,-19} {1,-20} {2,-8} {3,-6} {4,-12}" -f 'Time', 'File', 'Fields', 'Status', 'Error'
        Write-Host $headerLine -ForegroundColor Yellow
        Write-Host "  " + ("-" * 70) -ForegroundColor DarkGray

        foreach ($import in $recent) {
            $status = if ($import.Success) { '✓' } else { '✗' }
            $fields = "$($import.FieldsCopied)/$($import.TotalFields)"
            $error = if ($import.Error -and $import.Error.Length -gt 12) {
                $import.Error.Substring(0, 9) + "..."
            } else {
                $import.Error
            }

            $color = if ($import.Success) { 'Green' } else { 'Red' }
            $line = "  {0,-19} {1,-20} {2,-8} {3,-6} {4,-12}" -f $import.Timestamp, $import.Source, $fields, $status, $error
            Write-Host $line -ForegroundColor $color
        }
        Write-Host ""

        $successCount = ($recent | Where-Object { $_.Success }).Count
        Write-Host "  Recent success rate: $successCount/$($recent.Count)" -ForegroundColor Cyan

    } catch {
        Write-PmcDebug -Level 1 -Category 'EXCEL' -Message "Excel latest command failed: $_"
        Write-Host "Excel latest error: $_" -ForegroundColor Red
    }
}


===== END FILE: module/Pmc.Strict/src/Excel.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/Execution.ps1 =====
# Execution pipeline for domain-action commands

function Set-PmcContextDefaults {
    param([PmcCommandContext]$Context)

    # Apply default values based on domain/action patterns
    # This function sets defaults for common arguments to simplify command usage

    if (-not $Context.Args) { $Context.Args = @{} }
    if (-not $Context.FreeText) { $Context.FreeText = @() }

    # Domain-specific defaults
    switch ($Context.Domain) {
        'task' {
            # For task operations, ensure priority defaults exist
            if ($Context.Action -in @('add', 'update', 'edit') -and -not $Context.Args.ContainsKey('priority')) {
                $Context.Args['priority'] = 0  # Default priority
            }
        }
        'project' {
            # Project operations may need defaults
            if ($Context.Action -eq 'add' -and -not $Context.Args.ContainsKey('status')) {
                $Context.Args['status'] = 'active'  # Default status
            }
        }
        'time' {
            # Time logging defaults
            if ($Context.Action -eq 'log' -and -not $Context.Args.ContainsKey('date')) {
                $Context.Args['date'] = (Get-Date).ToString('yyyy-MM-dd')  # Default to today
            }
        }
    }
}

function Resolve-PmcHandler {
    param([string]$Domain,[string]$Action)
    if (-not $Script:PmcCommandMap.ContainsKey($Domain)) { return $null }
    $map = $Script:PmcCommandMap[$Domain]
    if (-not $map.ContainsKey($Action)) { return $null }
    return $map[$Action]
}

function Resolve-PmcProjectFromTokens {
    param(
        [string[]] $Tokens,
        [int] $StartIndex
    )
    # Returns a hashtable: @{ Name = <string>; Consumed = <int> }
    # If no resolution, returns @{ Name=$null; Consumed=1 } (consume only the '@...' token)
    $result = @{ Name = $null; Consumed = 1 }
    if ($StartIndex -lt 0 -or $StartIndex -ge $Tokens.Count) { return $result }
    $first = $Tokens[$StartIndex]
    if (-not ($first -match '^@(.+)$')) { return $result }

    $initial = $matches[1]
    $candidates = @()
    try {
        $data = Get-PmcDataAlias
        $projects = @($data.projects | ForEach-Object { [string]$_.name })
        if (-not $projects) { return $result }

        # Greedily extend with following plain tokens (no prefixes, not '--')
        $bestName = $null
        $bestLen = 1
        $current = $initial
        if ($projects -contains $current) { $bestName = $current; $bestLen = 1 }

        for ($i = $StartIndex + 1; $i -lt $Tokens.Count; $i++) {
            $t = $Tokens[$i]
            if ($t -eq '--' -or $t -match '^@' -or $t -match '^(p[1-3])$' -or $t -match '^due:' -or $t -match '^#' -or $t -match '^-#') {
                break
            }
            $current = "$current $t"
            if ($projects -contains $current) { $bestName = $current; $bestLen = ($i - $StartIndex + 1) }
        }

        if ($bestName) {
            $result.Name = $bestName
            $result.Consumed = $bestLen
            return $result
        }
    } catch { }

    return $result
}

function Parse-PmcArgsFromTokens {
    param(
        [string[]] $Tokens,
        [int] $StartIndex = 0
    )

    $args = @{}
    $free = @()
    $seenPlain = $false
    for ($i = $StartIndex; $i -lt $Tokens.Count; $i++) {
        $t = $Tokens[$i]
        if ($seenPlain) { $free += $t; continue }
        if ($t -eq '--') { $seenPlain = $true; continue }
        if ($t -match '^@') {
            $res = Resolve-PmcProjectFromTokens -Tokens $Tokens -StartIndex $i
            if ($res.Name) { $args['project'] = $res.Name; $i += ($res.Consumed - 1); continue }
            if ($t -match '^@(.+)$') { $args['project'] = $matches[1]; continue }
        }
        if ($t -match '^(p[1-3])$') { $args['priority'] = $matches[1]; continue }
        if ($t -match '^due:(.+)$') { $args['due'] = $matches[1]; continue }
        if ($t -match '^#(.+)$' -or $t -match '^\+(.+)$') { if (-not $args.ContainsKey('tags')) { $args['tags']=@() }; $args['tags'] += $matches[1]; continue }
        if ($t -match '^-#?(.+)$') { if (-not $args.ContainsKey('removeTags')) { $args['removeTags']=@() }; $args['removeTags'] += $matches[1]; continue }
        $seenPlain = $true
        $free += $t
    }
    return @{ Args = $args; Free = $free }
}

function ConvertTo-PmcIdSet {
    param([string]$text)
    $ids = @()
    foreach ($part in ($text -split ',')) {
        $p = $part.Trim()
        if ($p -match '^(\d+)-(\d+)$') { $a=[int]$matches[1]; $b=[int]$matches[2]; if ($a -le $b) { for ($i=$a; $i -le $b; $i++) { $ids += $i } } else { for ($i=$a; $i -ge $b; $i--) { $ids += $i } } }
        elseif ($p -match '^\d+$') { $ids += [int]$p }
    }
    return @($ids | Select-Object -Unique)
}

function ConvertTo-PmcContext {
    param([string[]]$Tokens)
    if ($Tokens.Count -lt 1) { return @{ Success=$false; Error='Empty command' } }

    # Special handling for 'help' so users can type: 'help', 'help <domain>', 'help <domain> <action>'
    if ($Tokens[0].ToLower() -eq 'help') {
        if ($Tokens.Count -eq 1) {
            $ctx = [PmcCommandContext]::new('help','show')
            $ctx.Raw = 'help show'
            return @{ Success=$true; Context=$ctx; Handler='Show-PmcSmartHelp' }
        } elseif ($Tokens.Count -eq 2) {
            $ctx = [PmcCommandContext]::new('help','domain')
            $ctx.Raw = ($Tokens -join ' ')
            $ctx.FreeText = @($Tokens[1])
            return @{ Success=$true; Context=$ctx; Handler='Show-PmcHelpDomain' }
        } else {
            $ctx = [PmcCommandContext]::new('help','command')
            $ctx.Raw = ($Tokens -join ' ')
            $ctx.FreeText = @($Tokens[1], $Tokens[2])
            return @{ Success=$true; Context=$ctx; Handler='Show-PmcHelpCommand' }
        }
    }

    # Treat first token matching a shortcut as a shortcut command (with args)
    $firstToken = $Tokens[0].ToLower()
    if ($Script:PmcShortcutMap.ContainsKey($firstToken)) {
        $fn = $Script:PmcShortcutMap[$firstToken]
        $ctx = [PmcCommandContext]::new('shortcut', $firstToken)
        $ctx.Raw = ($Tokens -join ' ')
        $parsedArgs = Parse-PmcArgsFromTokens -Tokens $Tokens -StartIndex 1
        $ctx.Args = $parsedArgs.Args
        $ctx.FreeText = $parsedArgs.Free
        return @{ Success=$true; Context=$ctx; Handler=$fn }
    }

    # Standard domain-action parsing
    if ($Tokens.Count -lt 2) {
        return @{ Success=$false; Error='Missing action. Use: <domain> <action> [...] or use shortcuts like: add, done, list' }
    }
    $domain = $Tokens[0].ToLower()
    $action = $Tokens[1].ToLower()
    $fn = Resolve-PmcHandler -Domain $domain -Action $action
    if (-not $fn) {
        if (-not $Script:PmcCommandMap.ContainsKey($domain)) {
            return @{ Success=$false; Error="Unknown domain '$domain'" }
        }
        return @{ Success=$false; Error="Unknown action '$action' for domain '$domain'" }
    }
    $ctx = [PmcCommandContext]::new($domain,$action)
    $ctx.Raw = ($Tokens -join ' ')
    # Arg-first rule with -- sentinel; supports @Project with spaces via greedy match
    $rest = @($Tokens | Select-Object -Skip 2)
    $parsed = Parse-PmcArgsFromTokens -Tokens $rest -StartIndex 0
    $ctx.Args = $parsed.Args
    $ctx.FreeText = $parsed.Free
    return @{ Success=$true; Context=$ctx; Handler=$fn }
}

function Invoke-PmcCommand {
    param([Parameter(Mandatory=$true)][string]$Buffer)

    Write-PmcDebugCommand -Command $Buffer -Status 'START'

    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()

    try {
        # Expand user-defined aliases before tokenization
        # Check for alias expansion
        if (Get-Command Expand-PmcUserAliases -ErrorAction SilentlyContinue) {
            $Buffer = Expand-PmcUserAliases -Buffer $Buffer
        }

        $tokens = ConvertTo-PmcTokens $Buffer
        Write-PmcDebug -Level 2 -Category 'PARSER' -Message "Tokenized command" -Data @{ TokenCount = $tokens.Count; Tokens = $tokens }

        $parsed = ConvertTo-PmcContext $tokens
        if (-not $parsed.Success) {
            Write-PmcDebugCommand -Command $Buffer -Status 'PARSE_ERROR' -Context @{ Error = $parsed.Error } -Timing $stopwatch.ElapsedMilliseconds
            Write-Host "Error: $($parsed.Error)" -ForegroundColor Red
            return
        }

        $fn = $parsed.Handler
        $ctx = $parsed.Context

        Write-PmcDebug -Level 2 -Category 'PARSER' -Message "Context parsed" -Data @{ Domain = $ctx.Domain; Action = $ctx.Action; ArgCount = $ctx.Args.Count; Handler = $fn }

        try {
            Set-PmcContextDefaults -Context $ctx
            Write-PmcDebug -Level 3 -Category 'COERCION' -Message "Context coerced" -Data @{ Args = $ctx.Args }
        } catch {
            Write-PmcDebug -Level 1 -Category 'COERCION' -Message "Coercion failed: $_"
        }

        try {
            $ok = Test-PmcContext -Context $ctx
            if (-not $ok) {
                Write-PmcDebugCommand -Command $Buffer -Status 'VALIDATION_ERROR' -Context @{ Domain = $ctx.Domain; Action = $ctx.Action } -Timing $stopwatch.ElapsedMilliseconds
                return
            }
            Write-PmcDebug -Level 3 -Category 'VALIDATION' -Message "Context validated successfully"
        } catch {
            Write-PmcDebug -Level 1 -Category 'VALIDATION' -Message "Validation failed: $_"
        }

        if (Get-Command -Name $fn -ErrorAction SilentlyContinue) {
            Write-PmcDebug -Level 2 -Category 'EXECUTION' -Message "Invoking handler: $fn"

            & $fn -Context $ctx

            $stopwatch.Stop()
            Write-PmcDebugCommand -Command $Buffer -Status 'SUCCESS' -Context @{ Domain = $ctx.Domain; Action = $ctx.Action; Handler = $fn } -Timing $stopwatch.ElapsedMilliseconds
        } else {
            Write-PmcDebugCommand -Command $Buffer -Status 'NO_HANDLER' -Context @{ Domain = $ctx.Domain; Action = $ctx.Action; Handler = $fn } -Timing $stopwatch.ElapsedMilliseconds
            Write-Host "Not implemented: $($ctx.Domain) $($ctx.Action)" -ForegroundColor Yellow
        }

    } catch {
        $stopwatch.Stop()
        Write-PmcDebugCommand -Command $Buffer -Status 'ERROR' -Context @{ Error = $_.ToString(); Exception = $_.Exception.GetType().Name } -Timing $stopwatch.ElapsedMilliseconds
        Write-Host "Command execution failed: $_" -ForegroundColor Red
    }
}

function ConvertTo-PmcContextType {
    param([PmcCommandContext]$Context)
    if (-not $Context) { return }
    $key = "$($Context.Domain) $($Context.Action)".ToLower()
    $schema = if ($Script:PmcParameterMap.ContainsKey($key)) { $Script:PmcParameterMap[$key] } else { @() }
    if (-not $schema -or @($schema).Count -eq 0) { return }
    # TaskID: parse first free text token to ids if applicable
    $needsId = $false
    foreach ($def in $schema) { if ($def['Type'] -eq 'TaskID') { $needsId = $true; break } }
    if ($needsId -and @($Context.FreeText).Count -ge 1) {
        $t0 = $Context.FreeText[0]
        if ($t0 -match '^[0-9,\-]+$') {
            $set = ConvertTo-PmcIdSet $t0
            if (@($set).Count -gt 0) { $Context.Args['ids'] = $set }
        }
        elseif ($t0 -match '^\d+$') {
            # list index handled in handlers via map; still pass as singleton id candidate
            $Context.Args['ids'] = @([int]$t0)
        }
    }
    # Normalize priority string to int for convenience (add priorityInt)
    if ($Context.Args.ContainsKey('priority')) {
        $pv = $Context.Args['priority']
        if ($pv -is [string] -and $pv -match '^p([1-3])$') { $Context.Args['priorityInt'] = [int]$matches[1] }
    }
    # Normalize due to yyyy-MM-dd if parseable (add dueIso)
    if ($Context.Args.ContainsKey('due')) {
        $d = ConvertTo-PmcDate $Context.Args['due']
        if ($d) { $Context.Args['dueIso'] = $d.ToString('yyyy-MM-dd') }
    }

    # Resolve project names when schema expects a ProjectName
    $needsProject = $false
    foreach ($def in $schema) { if ($def['Type'] -eq 'ProjectName') { $needsProject = $true; break } }
    if ($needsProject -and $Context.Args.ContainsKey('project')) {
        try { $data = Get-PmcDataAlias; $p = Resolve-Project -Data $data -Name $Context.Args['project']; if ($p) { $Context.Args['projectNameResolved'] = $p.name } } catch {
            # Project resolution failed - continue without resolved name
        }
    }

    # Parse duration tokens for commands that expect Duration
    $needsDuration = $false
    foreach ($def in $schema) { if ($def['Type'] -eq 'Duration') { $needsDuration = $true; break } }
    if ($needsDuration) {
        $durTok = $null
        foreach ($t in $Context.FreeText) {
            if ($t -match '^\d+(?:\.\d+)?$' -or $t -match '^\d+(?:\.\d+)?h$' -or $t -match '^\d+m$') { $durTok = $t; break }
        }
        if ($durTok) {
            try { $mins = ConvertTo-PmcDurationMinutes $durTok; if ($mins -gt 0) { $Context.Args['durationMinutes'] = $mins } } catch {
                # Duration parsing failed - continue without duration
            }
        }
    }
}

function Test-PmcContext {
    param([PmcCommandContext]$Context)
    $key = "$($Context.Domain) $($Context.Action)".ToLower()
    $schema = if ($Script:PmcParameterMap.ContainsKey($key)) { $Script:PmcParameterMap[$key] } else { @() }
    if (-not $schema -or @($schema).Count -eq 0) { return $true }
    $errors = @()
    # Check required schema elements
    foreach ($def in $schema) {
        $name = [string]$def['Name']
        $type = [string]$def['Type']
        $required = $false; try { $required = [bool]$def['Required'] } catch {
            # Schema definition access failed - assume not required
        }
        if (-not $required) { continue }
        switch ($type) {
            'FreeText' {
                if (-not $Context.FreeText -or @($Context.FreeText).Count -eq 0) { $errors += "Missing required text" }
            }
            'TaskID' {
                $hasIds = ($Context.Args.ContainsKey('ids') -and @($Context.Args['ids']).Count -gt 0)
                $hasToken = (@($Context.FreeText).Count -ge 1)
                if (-not $hasIds -and -not $hasToken) { $errors += "Missing required id(s)" }
            }
            'ProjectName' {
                if (-not $Context.Args.ContainsKey('project')) { $errors += "Missing required @project" }
            }
            'Priority' {
                if (-not $Context.Args.ContainsKey('priority') -and -not $Context.Args.ContainsKey('priorityInt')) { $errors += "Missing required priority (p1/p2/p3)" }
            }
            'DateString' {
                if (-not $Context.Args.ContainsKey('due') -and -not $Context.Args.ContainsKey('dueIso')) { $errors += "Missing required date" }
            }
            'DateRange' {
                # If required, ensure at least one recognizable token exists
                $has = $false
                foreach ($t in $Context.FreeText) {
                    if ($t -match '^(?i)today|yesterday|week$' -or $t -match '^\d{4}-\d{2}-\d{2}$') { $has=$true; break }
                }
                if (-not $has) { $errors += "Missing required date range" }
            }
            'Duration' {
                if (-not $Context.Args.ContainsKey('durationMinutes')) {
                    $hasLike = $false
                    foreach ($t in $Context.FreeText) { if ($t -match '^\d+(?:\.\d+)?$' -or $t -match '^\d+(?:\.\d+)?h$' -or $t -match '^\d+m$') { $hasLike=$true; break } }
                    if (-not $hasLike) { $errors += "Missing required duration (e.g., 1.5 hours or 90m)" }
                }
            }
            default { }
        }
    }
    # Basic tag validation if tags present
    if ($Context.Args.ContainsKey('tags')) {
        foreach ($tag in @($Context.Args['tags'])) { if (-not $tag -or ($tag -match '\s')) { $errors += ("Invalid tag '{0}'" -f $tag) } }
    }
    if (@($errors).Count -gt 0) {
        foreach ($e in $errors) { Write-Host ("Error: {0}" -f $e) -ForegroundColor Red }
        return $false
    }
    return $true
}

===== END FILE: module/Pmc.Strict/src/Execution.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/Focus.ps1 =====
# Focus/Context System Implementation
# Based on t2.ps1 focus functionality

# State-only: no global context initialization

function Set-PmcFocus {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "Focus" -Message "Starting focus set" -Data @{ FreeText = $Context.FreeText }

    $data = Get-PmcDataAlias
    $focusText = ($Context.FreeText -join ' ').Trim()

    if ([string]::IsNullOrWhiteSpace($focusText)) {
        Write-PmcStyled -Style 'Warning' -Text "Usage: focus set <project-name>"
        return
    }

    # Find matching project
    $project = $data.projects | Where-Object { $_.name -and ($_.name.ToLower() -eq $focusText.ToLower()) } | Select-Object -First 1

    if (-not $project) {
        Write-PmcStyled -Style 'Warning' -Text ("Project '{0}' not found. Creating new project context." -f $focusText)
        # Auto-create project if it doesn't exist
        $project = [pscustomobject]@{
            name = $focusText
            description = "Auto-created via focus $(Get-Date -Format yyyy-MM-dd)"
            created = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
        }
        $data.projects += $project
    }

    # Persist context in data
    if (-not $data.PSObject.Properties['currentContext']) {
        $data | Add-Member -NotePropertyName currentContext -NotePropertyValue $project.name -Force
    } else {
        $data.currentContext = $project.name
    }

    # Mirror to centralized state
    Set-PmcState -Section 'Focus' -Key 'Current' -Value $project.name

    Save-StrictData $data 'focus set'

    Write-PmcStyled -Style 'Success' -Text ("🎯 Focus set to: '{0}'" -f $project.name)

    # Show context summary
    $contextTasks = @($data.tasks | Where-Object {
        $_ -ne $null -and (Pmc-HasProp $_ 'project') -and $_.project -eq $project.name -and (Pmc-HasProp $_ 'status') -and $_.status -eq 'pending'
    })

    Write-PmcStyled -Style 'Info' -Text ("   Pending tasks: {0}" -f $contextTasks.Count)

    if ($contextTasks.Count -gt 0) {
        $overdue = @($contextTasks | Where-Object { (Pmc-HasProp $_ 'due') -and $_.due -and ([datetime]$_.due) -lt (Get-Date).Date })
        $today = @($contextTasks | Where-Object { (Pmc-HasProp $_ 'due') -and $_.due -and ([datetime]$_.due) -eq (Get-Date).Date })

        if ($overdue.Count -gt 0) { Write-PmcStyled -Style 'Error' -Text ("   ⚠️  Overdue: {0}" -f $overdue.Count) }
        if ($today.Count -gt 0)   { Write-PmcStyled -Style 'Warning' -Text ("   📅 Due today: {0}" -f $today.Count) }
    }

    Write-PmcDebug -Level 2 -Category "Focus" -Message "Focus set successfully" -Data @{ Project = $project.name; PendingTasks = $contextTasks.Count }
}

function Clear-PmcFocus {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "Focus" -Message "Starting focus clear"

    $data = Get-PmcDataAlias

    # Clear persisted context
    if ($data.PSObject.Properties['currentContext']) {
        $data.currentContext = 'inbox'
    }

    # Mirror to centralized state
    Set-PmcState -Section 'Focus' -Key 'Current' -Value 'inbox'

    Save-StrictData $data 'focus clear'

    Write-PmcStyled -Style 'Success' -Text "🎯 Project focus cleared. Back to inbox."

    Write-PmcDebug -Level 2 -Category "Focus" -Message "Focus cleared successfully"
}

function Get-PmcFocusStatus {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "Focus" -Message "Starting focus status"

    $data = Get-PmcDataAlias

    Write-PmcStyled -Style 'Info' -Text "`nℹ️  CURRENT CONTEXT"
    Write-PmcStyled -Style 'Border' -Text "─────────────────────"

    # Resolve context via helper (handles uninitialized global state)
    $currentContext = Get-PmcCurrentContext

    if (-not $currentContext -or $currentContext -eq 'inbox') {
        Write-PmcStyled -Style 'Muted' -Text "  No active focus (inbox mode)"

        # Show inbox summary
    $inboxTasks = @($data.tasks | Where-Object {
            $_ -ne $null -and ((-not (Pmc-HasProp $_ 'project')) -or $_.project -eq 'inbox') -and (Pmc-HasProp $_ 'status') -and $_.status -eq 'pending'
        })
        Write-PmcStyled -Style 'Body' -Text ("  Inbox tasks: {0}" -f $inboxTasks.Count)
        return
    }

    Write-PmcStyled -Style 'Warning' -Text ("  Active Focus: {0}" -f $currentContext)

    # Find the project
    $project = $data.projects | Where-Object { $_.name -eq $currentContext } | Select-Object -First 1

    if ($project) {
        $desc = if ((Pmc-HasProp $project 'description') -and $project.description) { [string]$project.description } else { 'None' }
        Write-PmcStyled -Style 'Muted' -Text ("  Description: {0}" -f $desc)
    }

    # Show context statistics
    $contextTasks = @($data.tasks | Where-Object { (Pmc-HasProp $_ 'project') -and $_.project -eq $currentContext -and (Pmc-HasProp $_ 'status') -and $_.status -eq 'pending' })

    Write-PmcStyled -Style 'Body' -Text ("  Pending Tasks: {0}" -f $contextTasks.Count)

    if ($contextTasks.Count -gt 0) {
        $overdue = @($contextTasks | Where-Object { (Pmc-HasProp $_ 'due') -and $_.due -and [datetime]$_.due -lt (Get-Date).Date })
        $today = @($contextTasks | Where-Object { (Pmc-HasProp $_ 'due') -and $_.due -and ([datetime]$_.due) -eq (Get-Date).Date })
        $upcoming = @($contextTasks | Where-Object { (Pmc-HasProp $_ 'due') -and $_.due -and ([datetime]$_.due) -gt (Get-Date).Date -and ([datetime]$_.due) -le (Get-Date).Date.AddDays(7) })
        $nodue = @($contextTasks | Where-Object { -not (Pmc-HasProp $_ 'due') -or -not $_.due })

        Write-PmcStyled -Style 'Info' -Text "`n  Task Breakdown:"
        if ($overdue.Count -gt 0)  { Write-PmcStyled -Style 'Error'   -Text ("    ⚠️  Overdue: {0}" -f $overdue.Count) }
        if ($today.Count -gt 0)    { Write-PmcStyled -Style 'Warning' -Text ("    📅 Due today: {0}" -f $today.Count) }
        if ($upcoming.Count -gt 0) { Write-PmcStyled -Style 'Success' -Text ("    📋 Upcoming (7d): {0}" -f $upcoming.Count) }
        if ($nodue.Count -gt 0)    { Write-PmcStyled -Style 'Muted'   -Text ("    📝 No due date: {0}" -f $nodue.Count) }

        # Show blocked tasks in context
        $blocked = @($contextTasks | Where-Object { (Pmc-HasProp $_ 'blocked') -and $_.blocked })
        if ($blocked.Count -gt 0) { Write-PmcStyled -Style 'Error' -Text ("    🔒 Blocked: {0}" -f $blocked.Count) }

        # Show high priority tasks
        $highPriority = @($contextTasks | Where-Object { $_.priority -and $_.priority -le 2 })
        if ($highPriority.Count -gt 0) { Write-PmcStyled -Style 'Highlight' -Text ("    ⭐ High priority: {0}" -f $highPriority.Count) }
    }

    # Show recent activity in context
    $recentLogs = @($data.timelogs | Where-Object {
        $_.project -eq $currentContext -and
        [datetime]$_.date -ge (Get-Date).Date.AddDays(-7)
    })

    if ($recentLogs.Count -gt 0) {
        $totalMinutes = ($recentLogs | Measure-Object minutes -Sum).Sum
        $totalHours = [Math]::Round($totalMinutes / 60, 1)
        Write-PmcStyled -Style 'Info' -Text ("  Recent time (7d): {0} hours" -f $totalHours)
    }

    Write-PmcStyled -Style 'Muted' -Text ("`nTip: Use 'task list @{0}' to see all tasks in this context" -f $currentContext)

    Write-PmcDebug -Level 2 -Category "Focus" -Message "Focus status shown successfully" -Data @{ Context = $currentContext; TaskCount = $contextTasks.Count }
}

# Helper function to get current context
function Get-PmcCurrentContext {
    # State-only source of truth
    $cur = Get-PmcState -Section 'Focus' -Key 'Current'
    if ($null -eq $cur -or [string]::IsNullOrWhiteSpace([string]$cur)) { return 'inbox' }
    return $cur
}

# Helper function to filter tasks by current context
function Get-PmcContextTasks {
    param([switch]$PendingOnly)

    $data = Get-PmcDataAlias
    $context = Get-PmcCurrentContext

    $tasks = $data.tasks

    if ($context -ne 'inbox') {
        $tasks = $tasks | Where-Object { $_.project -eq $context }
    } else {
        $tasks = $tasks | Where-Object { -not $_.project -or $_.project -eq 'inbox' }
    }

    if ($PendingOnly) {
        $tasks = $tasks | Where-Object { $_.status -eq 'pending' }
    }

    return @($tasks)
}

===== END FILE: module/Pmc.Strict/src/Focus.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/Help.ps1 =====
function Get-PmcSchema {
    param([string]$Domain,[string]$Action)
    $key = "$($Domain.ToLower()) $($Action.ToLower())"
    if ($Script:PmcParameterMap.ContainsKey($key)) { return $Script:PmcParameterMap[$key] }
    return @()
}

function Get-PmcHelp {
    $rows = @()
    foreach ($d in ($Script:PmcCommandMap.Keys | Sort-Object)) {
        foreach ($a in ($Script:PmcCommandMap[$d].Keys | Sort-Object)) {
            $key = "$d $a"; $desc = if ($Script:PmcCommandMeta.ContainsKey($key)) { $Script:PmcCommandMeta[$key].Desc } else { '' }
            $rows += [pscustomobject]@{ Domain=$d; Action=$a; Description=$desc }
        }
    }
    return $rows
}

function Show-PmcHelpDomain { param([PmcCommandContext]$Context)
    if (-not $Context -or $Context.FreeText.Count -lt 1) { Write-PmcStyled -Style 'Warning' -Text "Usage: help domain <domain>"; return }
    $domain = $Context.FreeText[0].ToLower()
    if (-not $Script:PmcCommandMap.ContainsKey($domain)) { Write-PmcStyled -Style 'Error' -Text "Unknown domain '$domain'"; return }
    $actions = @()
    foreach ($a in ($Script:PmcCommandMap[$domain].Keys | Sort-Object)) {
        $key = "$domain $a"
        $desc = if ($Script:PmcCommandMeta.ContainsKey($key)) { $Script:PmcCommandMeta[$key].Desc } else { '' }
        $actions += @{ action=$a; desc=$desc }
    }
    $cols = @(
        @{ key='action'; title='Action'; width=16 },
        @{ key='desc'; title='Description'; width=56 }
    )
    Show-PmcHeader -Title ("Help — {0}" -f $domain)
    Show-PmcTable -Columns $cols -Rows $actions
}

function Show-PmcHelpCommand { param([PmcCommandContext]$Context)
    if (-not $Context -or $Context.FreeText.Count -lt 2) { Write-PmcStyled -Style 'Warning' -Text "Usage: help command <domain> <action>"; return }
    $domain = $Context.FreeText[0].ToLower()
    $action = $Context.FreeText[1].ToLower()
    $key = "$domain $action"
    if (-not $Script:PmcCommandMap.ContainsKey($domain)) { Write-PmcStyled -Style 'Error' -Text "Unknown domain '$domain'"; return }
    if (-not $Script:PmcCommandMap[$domain].ContainsKey($action)) { Write-PmcStyled -Style 'Error' -Text "Unknown action '$action' for domain '$domain'"; return }

    $desc = if ($Script:PmcCommandMeta.ContainsKey($key)) { $Script:PmcCommandMeta[$key].Desc } else { '' }
    Show-PmcHeader -Title ("Help — {0} {1}" -f $domain, $action)
    if ($desc) { Show-PmcTip $desc }

    $schema = Get-PmcSchema -Domain $domain -Action $action
    if (-not $schema -or @($schema).Count -eq 0) { Write-PmcStyled -Style 'Muted' -Text '  (no arguments)'; return }
    $rows = @()
    foreach ($def in $schema) {
        $rows += @{
            arg = [string]$def['Name']
            prefix = [string]$def['Prefix']
            type = [string]$def['Type']
            required = if ($def['Required']) { 'yes' } else { '' }
            desc = [string]$def['Description']
        }
    }
    $cols = @(
        @{ key='arg'; title='Arg'; width=14 },
        @{ key='prefix'; title='Prefix'; width=8 },
        @{ key='type'; title='Type'; width=14 },
        @{ key='required'; title='Req'; width=4 },
        @{ key='desc'; title='Description'; width=48 }
    )
    Show-PmcTable -Columns $cols -Rows $rows
}

function Show-PmcCommandList {
    $rows = Get-PmcHelp
    foreach ($r in ($rows | Sort-Object Domain, Action)) {
        Write-PmcStyled -Style 'Body' -Text ("{0} {1}  {2}" -f $r.Domain, $r.Action, $r.Description)
    }
}
function Show-PmcHelpAll { Show-PmcHelpUI }

function Show-PmcHelpUI {
    $rows = Get-PmcHelp | Sort-Object Domain, Action
    $domains = @($rows | Select-Object -ExpandProperty Domain -Unique)
    foreach ($d in $domains) {
        Show-PmcHeader -Title ("Help — {0}" -f $d)
        $vm = @()
        foreach ($r in ($rows | Where-Object { $_.Domain -eq $d })) {
            $vm += @{ action=$r.Action; desc=$r.Description }
        }
        $cols = @(
            @{ key='action'; title='Action'; width=16 },
            @{ key='desc'; title='Description'; width=56 }
        )
        Show-PmcTable -Columns $cols -Rows $vm
        Write-Host ""
    }
    Show-PmcTip "Examples:"
    Show-PmcTip "  task add buy milk @inbox p2 due:today"
    Show-PmcTip "  task agenda"
    Show-PmcTip "  time report week --withids out:time.csv"
    Show-PmcTip "  project set-fields @work ID2=WORK CAAName=Ops"
}

## Internal module state for list index mapping (centralized state)
Set-PmcLastTaskListMap @{}
Set-PmcLastTimeListMap @{}

## Data helpers (module storage)
# Get-PmcDataAlias defined in Storage.ps1
function Save-StrictData { param($data,[string]$Action='') Save-PmcData -data $data -Action $Action }

function ConvertTo-PmcDate {
    param([string]$token)
    if ([string]::IsNullOrWhiteSpace($token)) { return $null }
    if ($token -match '^(?i)today$') { return (Get-Date).Date }
    if ($token -match '^(?i)yesterday$') { return (Get-Date).Date.AddDays(-1) }
    try { return [datetime]::ParseExact($token,'yyyy-MM-dd',$null) } catch {
        # Date parsing failed - return null for graceful fallback
    }
    # Parse-NaturalDate not available - basic parsing only
    return $null
}

function ConvertTo-PmcMinutes {
    param([string]$duration)
    # Parse-DurationToMinutes not available - basic parsing only
    # Allow bare numbers as hours (e.g., 1, 1.5, 0.25)
    if ($duration -match '^(\d+(?:\.\d+)?)$') { return [int]([double]$matches[1] * 60) }
    if ($duration -match '^(\d+(?:\.\d+)?)[hH]$') { return [int]([double]$matches[1] * 60) }
    if ($duration -match '^(\d+)[mM]$') { return [int]$matches[1] }
    return 0
}

# Alias for compatibility
function ConvertTo-PmcDurationMinutes {
    param([string]$duration)
    return ConvertTo-PmcMinutes $duration
}

# ===== TASKS =====
function Add-PmcTask { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    $text = ($Context.FreeText -join ' ').Trim()
    if (-not $text) { Write-PmcStyled -Style 'Warning' -Text "Usage: task add <text> [@project] [p1|p2|p3] [due:YYYY-MM-DD] [#tag...]"; return }
    $projName = if ($Context.Args.ContainsKey('project')) { $Context.Args['project'] } else { $null }
    $priority = 0; if ($Context.Args.ContainsKey('priority')) { if ($Context.Args['priority'] -match '^p([1-3])$') { $priority = [int]$matches[1] } }
    $due = $null; if ($Context.Args.ContainsKey('due')) { $due = ConvertTo-PmcDate $Context.Args['due'] }
    $tags = @(); if ($Context.Args.ContainsKey('tags')) { $tags = @($Context.Args['tags']) }
    $projectField = 'inbox'
    if ($projName) {
        $p = Resolve-Project -Data $data -Name $projName
        if ($p) { $projectField = $p.name } else { $projectField = $projName }
    }
    $id = Get-PmcNextTaskId $data
    $task = @{
        id = $id
        text = $text
        project = $projectField
        priority = $priority
        status = 'pending'
        created = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
        tags = $tags
    }
    if ($due) { $task.due = $due.ToString('yyyy-MM-dd') }
    $data.tasks += $task
    Save-StrictData $data 'task add'
    Write-PmcStyled -Style 'Success' -Text ("Added task #${id}: {0}" -f $text)
}

function Get-PmcTaskList { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    $tasks = @($data.tasks | Where-Object { try { $_ -ne $null -and $_.status -eq 'pending' } catch { $false } })
    $tasks = $tasks | Sort-Object `
        @{Expression={ if (Pmc-HasProp $_ 'priority'){ 4 - [int]$_.priority } else { 0 } }}, `
        @{Expression={ if (Pmc-HasProp $_ 'due'){ try { [datetime]$_.due } catch { [datetime]::MaxValue } } else { [datetime]::MaxValue } }}
    $mapList = @{}
    Set-PmcLastTaskListMap $mapList
    if ($tasks.Count -eq 0) { Show-PmcHeader -Title 'TASKS'; Show-PmcTip 'No pending tasks'; return }
    $rows = @(); $i=1
    foreach ($t in $tasks) {
        $mapList[$i] = $t.id
        Set-PmcLastTaskListMap $mapList
        $priVal = ''
        if ((Pmc-HasProp $t 'priority') -and $t.priority) { $priVal = 'p' + $t.priority }
        $dueVal = ''
        if ((Pmc-HasProp $t 'due') -and $t.due) { try { $dueVal = ([datetime]$t.due).ToString('MM/dd') } catch {
            # Date formatting failed - dueVal remains empty
        } }
        $textVal = if (Pmc-HasProp $t 'text') { $t.text } else { '' }
        # Indicate project when assigned (non-inbox)
        try {
            if ($t.PSObject.Properties['project'] -and $t.project -and $t.project -ne 'inbox') {
                $textVal = ("{0}  @{1}" -f $textVal, $t.project)
            }
        } catch {}
        $rows += @{ idx = ('[{0,2}]' -f $i); text = $textVal; pri = $priVal; due = $dueVal }
        $i++
    }
    $cols = @(
        @{ key='idx'; title='#'; width=5; align='right' },
        @{ key='text'; title='Task'; width=46 },
        @{ key='pri'; title='Pri'; width=4 },
        @{ key='due'; title='Due'; width=8 }
    )
    Show-PmcTable -Columns $cols -Rows $rows -Title 'TASKS'
    Show-PmcTip "Use 'task view <#>', 'task done <#>', 'task edit <#>'"
}

function Show-PmcTask { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    if ($Context.FreeText.Count -lt 1) { Write-PmcStyled -Style 'Warning' -Text "Usage: task view <id|#>"; return }
    $token = $Context.FreeText[0]
    $id = $null
    if ($token -match '^\d+$') { $id = [int]$token }
    $idxMap = Get-PmcLastTaskListMap
    if (-not $id -and $idxMap.ContainsKey($token)) { $id = [int]$idxMap[$token] }
    if (-not $id -and $token -match '^\d+$' -and $idxMap.ContainsKey([int]$token)) { $id = [int]$idxMap[[int]$token] }
    if (-not $id) { Write-PmcStyled -Style 'Error' -Text "Invalid id/index"; return }
    $t = $data.tasks | Where-Object { $_ -ne $null -and $_.id -eq $id } | Select-Object -First 1
    if (-not $t) { Write-PmcStyled -Style 'Error' -Text "Task #$id not found"; return }
    Write-PmcStyled -Style 'Info' -Text ("\nTask #{0}" -f $t.id)
    Write-PmcStyled -Style 'Body' -Text ("  Text:    {0}" -f (Pmc-GetProp $t 'text' ''))
    Write-PmcStyled -Style 'Body' -Text ("  Project: {0}" -f (Pmc-GetProp $t 'project' '(none)'))
    Write-Host ("  Priority:{0}" -f (Pmc-GetProp $t 'priority' 0))
    Write-Host ("  Due:     {0}" -f (Pmc-GetProp $t 'due' ''))
    Write-Host ("  Status:  {0}" -f (Pmc-GetProp $t 'status' 'pending'))
}

function Complete-PmcTask { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    if ($Context.FreeText.Count -lt 1 -and -not $Context.Args.ContainsKey('ids')) { Write-Host "Usage: task done <id|#|set>" -ForegroundColor Yellow; return }
    $raw = if ($Context.FreeText.Count -gt 0) { $Context.FreeText[0] } else { '' }
    $ids = @(); if ($Context.Args.ContainsKey('ids')) { $ids=@($Context.Args['ids']) }
    if (@($ids).Count -eq 0 -and $raw -match '^[0-9,\-]+$') { $ids = ConvertTo-PmcIdSet $raw }
    if (@($ids).Count -eq 0 -and $raw -match '^\d+$') { $n=[int]$raw; $idxMap=Get-PmcLastTaskListMap; if ($idxMap.ContainsKey($n)) { $ids=@($idxMap[$n]) } else { $ids=@($n) } }
    if (@($ids).Count -eq 0) { Write-Host "Invalid id/index/set" -ForegroundColor Red; return }
    $done=0; foreach ($id in $ids) {
        $t = $data.tasks | Where-Object { $_ -ne $null -and $_.PSObject.Properties.Match('id').Count -gt 0 -and $_.id -eq $id } | Select-Object -First 1
        if ($t) {
            $t.status = 'completed'
            $ts = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
            if (Pmc-HasProp $t 'completed') { $t.completed = $ts } else { Add-Member -InputObject $t -MemberType NoteProperty -Name 'completed' -Value $ts -Force }
            $done++
        }
    }
    if ($done -gt 0) { Save-StrictData $data 'task done'; Write-Host ("Completed {0} task(s)" -f $done) -ForegroundColor Green } else { Write-Host 'No tasks completed' -ForegroundColor Yellow }
}

function Remove-PmcTask { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    if ($Context.FreeText.Count -lt 1 -and -not $Context.Args.ContainsKey('ids')) { Write-Host "Usage: task delete <id|#|set>" -ForegroundColor Yellow; return }
    $raw = if ($Context.FreeText.Count -gt 0) { $Context.FreeText[0] } else { '' }
    $ids = @(); if ($Context.Args.ContainsKey('ids')) { $ids=@($Context.Args['ids']) }
    if (@($ids).Count -eq 0 -and $raw -match '^[0-9,\-]+$') { $ids = ConvertTo-PmcIdSet $raw }
    if (@($ids).Count -eq 0 -and $raw -match '^\d+$') { $n=[int]$raw; $idxMap=Get-PmcLastTaskListMap; if ($idxMap.ContainsKey($n)) { $ids=@($idxMap[$n]) } else { $ids=@($n) } }
    if (@($ids).Count -eq 0) { Write-Host "Invalid id/index/set" -ForegroundColor Red; return }
    $before=@($data.tasks).Count
    $data.tasks = @($data.tasks | Where-Object { $_ -ne $null -and $_.PSObject.Properties.Match('id').Count -gt 0 -and ($ids -notcontains $_.id) })
    $removed = $before - @($data.tasks).Count
    if ($removed -gt 0) { Save-StrictData $data 'task delete'; Write-Host ("Deleted {0} task(s)" -f $removed) -ForegroundColor Green } else { Write-Host 'No tasks deleted' -ForegroundColor Yellow }
}

function Set-PmcTask { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    if ($Context.FreeText.Count -lt 1) { Write-Host "Usage: task update <id|#|set> [@project] [p1|p2|p3] [due:YYYY-MM-DD] [#tag...|-#tag...] [new text]" -ForegroundColor Yellow; return }
    $raw=$Context.FreeText[0]; $ids=@()
    if ($raw -match '^[0-9,\-]+$') { $ids = ConvertTo-PmcIdSet $raw }
    if (@($ids).Count -eq 0 -and $raw -match '^\d+$') { $n=[int]$raw; $idxMap=Get-PmcLastTaskListMap; if ($idxMap.ContainsKey($n)) { $ids=@($idxMap[$n]) } else { $ids=@($n) } }
    if (@($ids).Count -eq 0) { Write-Host "Invalid id/index/set" -ForegroundColor Red; return }
    $proj=$null; $pri=$null; $due=$null
    if ($Context.Args.ContainsKey('project')) { $proj = $Context.Args['project'] }
    if ($Context.Args.ContainsKey('priority')) { if ($Context.Args['priority'] -match '^p([1-3])$') { $pri = [int]$matches[1] } }
    if ($Context.Args.ContainsKey('due')) { $d = ConvertTo-PmcDate $Context.Args['due']; if ($d) { $due = $d.ToString('yyyy-MM-dd') } }
    $addTags=@(); if ($Context.Args.ContainsKey('tags')) { $addTags=@($Context.Args['tags']) }
    $removeTags=@(); if ($Context.Args.ContainsKey('removeTags')) { $removeTags=@($Context.Args['removeTags']) }
    $newText = if ($Context.FreeText.Count -gt 1) { ($Context.FreeText[1..($Context.FreeText.Count-1)] -join ' ') } else { $null }
    $updated=0
    foreach ($id in $ids) {
        $t = $data.tasks | Where-Object { $_ -ne $null -and $_.id -eq $id } | Select-Object -First 1
        if (-not $t) { Write-Host "Task #$id not found" -ForegroundColor Yellow; continue }
        if ($proj) { $t.project = $proj }
        if ($pri) { $t.priority = $pri }
        if ($due) { $t.due = $due }
        if (($addTags.Count -gt 0) -or ($removeTags.Count -gt 0)) {
            if (-not $t.PSObject.Properties['tags']) { $t | Add-Member -NotePropertyName tags -NotePropertyValue @() -Force }
            $curr=@($t.tags)
            foreach ($tg in $addTags) { if ($curr -notcontains $tg) { $curr += $tg } }
            foreach ($rt in $removeTags) { $curr = @($curr | Where-Object { $_ -ne $rt }) }
            $t.tags = $curr
        }
        if ($newText) { $t.text = $newText }
        $updated++
    }
    if ($updated -gt 0) { Save-StrictData $data 'task update'; Write-Host ("Updated {0} task(s)" -f $updated) -ForegroundColor Green }
}

function Move-PmcTask { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    if (($Context.FreeText.Count -lt 1 -and -not $Context.Args.ContainsKey('ids')) -or -not $Context.Args.ContainsKey('project')) { Write-Host "Usage: task move <id|#|set> @project" -ForegroundColor Yellow; return }
    $raw = if ($Context.FreeText.Count -gt 0) { $Context.FreeText[0] } else { '' }
    $ids = @(); if ($Context.Args.ContainsKey('ids')) { $ids=@($Context.Args['ids']) }
    if (@($ids).Count -eq 0 -and $raw -match '^[0-9,\-]+$') { $ids = ConvertTo-PmcIdSet $raw }
    if (@($ids).Count -eq 0 -and $raw -match '^\d+$') { $n=[int]$raw; if ($Script:PmcLastTaskListMap.ContainsKey($n)) { $ids=@($Script:PmcLastTaskListMap[$n]) } else { $ids=@($n) } }
    if (@($ids).Count -eq 0) { Write-Host "Invalid id/index/set" -ForegroundColor Red; return }
    $proj = $Context.Args['project']
    $moved=0; foreach ($id in $ids) { $t = $data.tasks | Where-Object { $_ -ne $null -and $_.PSObject.Properties.Match('id').Count -gt 0 -and $_.id -eq $id } | Select-Object -First 1; if ($t) { $t.project=$proj; $moved++ } }
    if ($moved -gt 0) { Save-StrictData $data 'task move'; Write-Host ("Moved {0} task(s) to @{1}" -f $moved,$proj) -ForegroundColor Green } else { Write-Host 'No tasks moved' -ForegroundColor Yellow }
}

function Set-PmcTaskPostponed { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    if ( (@($Context.FreeText).Count -lt 2 -and -not $Context.Args.ContainsKey('ids')) ) { Write-Host "Usage: task postpone <id|#|set> <+Nd|-Nd|YYYY-MM-DD>" -ForegroundColor Yellow; return }
    $raw = if ($Context.FreeText.Count -gt 0) { $Context.FreeText[0] } else { '' }
    $delta = if ($Context.FreeText.Count -gt 1) { $Context.FreeText[1] } else { '' }
    $ids=@(); if ($Context.Args.ContainsKey('ids')) { $ids=@($Context.Args['ids']) } elseif ($raw -match '^[0-9,\-]+$') { $ids = ConvertTo-PmcIdSet $raw }
    if (@($ids).Count -eq 0 -and $raw -match '^\d+$') { $n=[int]$raw; $idxMap=Get-PmcLastTaskListMap; if ($idxMap.ContainsKey($n)) { $ids=@($idxMap[$n]) } else { $ids=@($n) } }
    if (@($ids).Count -eq 0) { Write-Host "Invalid id/index/set" -ForegroundColor Red; return }
    $sign=$null; $days=0; $parsed=$null
    if ($delta -match '^([+-])(\d+)d$') { $sign=$matches[1]; $days=[int]$matches[2] } else { $parsed = ConvertTo-PmcDate $delta; if (-not $parsed) { Write-Host 'Invalid delta/date' -ForegroundColor Red; return } }
    $changed=0
    foreach ($id in $ids) {
        $t = $data.tasks | Where-Object { $_ -ne $null -and $_.id -eq $id } | Select-Object -First 1
        if (-not $t) { continue }
        $base = if ($t.due) { [datetime]$t.due } else { (Get-Date).Date }
        $nd = if ($sign) { if ($sign -eq '+') { $base.AddDays($days) } else { $base.AddDays(-$days) } } else { $parsed }
        if ($nd) { $t.due = $nd.ToString('yyyy-MM-dd'); $changed++ }
    }
    if ($changed -gt 0) { Save-StrictData $data 'task postpone'; Write-Host ("Postponed {0} task(s)" -f $changed) -ForegroundColor Green }
}

function Copy-PmcTask { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    if ($Context.FreeText.Count -lt 1 -and -not $Context.Args.ContainsKey('ids')) { Write-Host "Usage: task duplicate <id|#|set>" -ForegroundColor Yellow; return }
    $raw = if ($Context.FreeText.Count -gt 0) { $Context.FreeText[0] } else { '' }
    $ids=@(); if ($Context.Args.ContainsKey('ids')) { $ids=@($Context.Args['ids']) } elseif ($raw -match '^[0-9,\-]+$') { $ids=ConvertTo-PmcIdSet $raw }
    if (@($ids).Count -eq 0 -and $raw -match '^\d+$') { $n=[int]$raw; if ($Script:PmcLastTaskListMap.ContainsKey($n)) { $ids=@($Script:PmcLastTaskListMap[$n]) } else { $ids=@($n) } }
    if (@($ids).Count -eq 0) { Write-Host "Invalid id/index/set" -ForegroundColor Red; return }
    $count=0
    foreach ($id in $ids) {
        $t = $data.tasks | Where-Object { $_ -ne $null -and $_.id -eq $id } | Select-Object -First 1
        if (-not $t) { continue }
        $newId = Get-PmcNextTaskId $data
        $copy = [pscustomobject]@{}
        foreach ($p in $t.PSObject.Properties) { if ($p.Name -ne 'id' -and $p.Name -ne 'completed') { Add-Member -InputObject $copy -NotePropertyName $p.Name -NotePropertyValue $p.Value -Force } }
        $copy | Add-Member -NotePropertyName id -NotePropertyValue $newId -Force
        $copy | Add-Member -NotePropertyName status -NotePropertyValue 'pending' -Force
        $data.tasks += $copy; $count++
    }
    if ($count -gt 0) { Save-StrictData $data 'task duplicate'; Write-Host ("Duplicated {0} task(s)" -f $count) -ForegroundColor Green } else { Write-Host 'No tasks duplicated' -ForegroundColor Yellow }
}

function Add-PmcTaskNote { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    if ( (@($Context.FreeText).Count -lt 2 -and -not $Context.Args.ContainsKey('ids')) ) { Write-Host "Usage: task note <id|#|set> <text>" -ForegroundColor Yellow; return }
    $raw = if ($Context.FreeText.Count -gt 0) { $Context.FreeText[0] } else { '' }
    $text = if ($Context.FreeText.Count -gt 1) { ($Context.FreeText[1..($Context.FreeText.Count-1)] -join ' ') } else { '' }
    $ids=@(); if ($Context.Args.ContainsKey('ids')) { $ids=@($Context.Args['ids']) } elseif ($raw -match '^[0-9,\-]+$') { $ids=ConvertTo-PmcIdSet $raw }
    if (@($ids).Count -eq 0 -and $raw -match '^\d+$') { $n=[int]$raw; if ($Script:PmcLastTaskListMap.ContainsKey($n)) { $ids=@($Script:PmcLastTaskListMap[$n]) } else { $ids=@($n) } }
    if (@($ids).Count -eq 0) { Write-Host "Invalid id/index/set" -ForegroundColor Red; return }
    $count=0
    foreach ($id in $ids) { $t = $data.tasks | Where-Object { $_ -ne $null -and $_.PSObject.Properties.Match('id').Count -gt 0 -and $_.id -eq $id } | Select-Object -First 1; if ($t) { if (-not $t.PSObject.Properties['notes']) { $t | Add-Member -NotePropertyName notes -NotePropertyValue @() -Force }; $t.notes = @($t.notes + @([pscustomobject]@{ text=$text; created=(Get-Date).ToString('yyyy-MM-dd HH:mm:ss') })); $count++ } }
    if ($count -gt 0) { Save-StrictData $data 'task note'; Write-Host ("Added note to {0} task(s)" -f $count) -ForegroundColor Green }
}

function Edit-PmcTask { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    if ($Context.FreeText.Count -lt 1) { Write-Host "Usage: task edit <id|#>" -ForegroundColor Yellow; return }
    $token = $Context.FreeText[0]
    $id = $null
    if ($token -match '^\d+$') { $id = [int]$token }
    if (-not $id -and $Script:PmcLastTaskListMap.ContainsKey($token)) { $id = [int]$Script:PmcLastTaskListMap[$token] }
    if (-not $id -and $token -match '^\d+$' -and $Script:PmcLastTaskListMap.ContainsKey([int]$token)) { $id = [int]$Script:PmcLastTaskListMap[[int]$token] }
    if (-not $id) { Write-Host "Invalid id/index" -ForegroundColor Red; return }
    $t = $data.tasks | Where-Object { $_ -ne $null -and $_.id -eq $id } | Select-Object -First 1
    if (-not $t) { Write-Host "Task #$id not found" -ForegroundColor Red; return }

    Write-PmcDebug -Level 1 -Category 'EDITOR' -Message ("Task editor start: #${id}")

    $fields = @(
        @{ Key='text'; Label='Text' },
        @{ Key='project'; Label='Project' },
        @{ Key='priority'; Label='Priority (0-3)' },
        @{ Key='due'; Label='Due (YYYY-MM-DD)' },
        @{ Key='tags'; Label='Tags (space or comma separated)' }
    )
    $sel = 0; $modified = $false

    function render-task([pscustomobject]$task,[int]$idx) {
        Clear-Host
        Show-PmcHeader -Title ("EDIT TASK #{0}" -f $task.id)
        for ($i=0; $i -lt $fields.Count; $i++) {
            $f = $fields[$i]
            $val = ''
            if ($f.Key -eq 'tags') {
                if ($task.PSObject.Properties['tags'] -and $task.tags) { $val = ($task.tags -join ', ') }
            } else {
                if ($task.PSObject.Properties[$f.Key]) { $val = [string]$task.($f.Key) }
            }
            $prefix = if ($i -eq $idx) { '► ' } else { '  ' }
            Write-Host ("{0}{1,-28} {2}" -f $prefix, ($f.Label + ':'), $val)
        }
        Write-Host ""
        Write-PmcStyled -Style 'Muted' -Text "  ↑/↓ select, Enter edit, Q/Esc save and exit"
    }

    while ($true) {
        render-task $t $sel
        $key = $null
        try { $key = [Console]::ReadKey($true) } catch { break }
        switch ($key.Key) {
            'UpArrow' { if ($sel -gt 0) { $sel-- }; continue }
            'DownArrow' { if ($sel -lt ($fields.Count-1)) { $sel++ }; continue }
            'Enter' {
                $f = $fields[$sel]
                $prompt = $f.Label
                $current = ''
                if ($f.Key -eq 'tags') { if ($t.PSObject.Properties['tags'] -and $t.tags) { $current = ($t.tags -join ',') } }
                elseif ($t.PSObject.Properties[$f.Key]) { $current = [string]$t.($f.Key) }
                $inp = Read-Host ("$prompt [$current]")
                if ($null -ne $inp -and $inp -ne '') {
                    switch ($f.Key) {
                        'priority' { try { $p=[int]$inp; if ($p -ge 0 -and $p -le 3) { $t.priority=$p; $modified=$true } } catch {} }
                        'due' { try { $d=[datetime]::ParseExact($inp,'yyyy-MM-dd',$null); $t.due=$d.ToString('yyyy-MM-dd'); $modified=$true } catch { Write-Host 'Invalid date' -ForegroundColor Yellow } }
                        'tags' { $arr = @($inp -split '[,\s]+' | Where-Object { $_ }); $t | Add-Member -NotePropertyName tags -NotePropertyValue $arr -Force; $modified=$true }
                        default { $t | Add-Member -NotePropertyName $f.Key -NotePropertyValue $inp -Force; $modified=$true }
                    }
                }
                continue
            }
            'Q' { break }
            'Escape' { break }
            default { continue }
        }
        break
    }

    if ($modified) {
        Save-StrictData $data 'task edit'
        Write-Host ("Saved task #{0}" -f $id) -ForegroundColor Green
    } else {
        Write-Host 'No changes' -ForegroundColor Gray
    }
    Write-PmcDebug -Level 1 -Category 'EDITOR' -Message ("Task editor end: #${id} modified=${modified}")
}

function Edit-PmcProject { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    $projName = if ($Context.Args.ContainsKey('project')) { $Context.Args['project'] } else { ($Context.FreeText -join ' ').Trim() }
    if (-not $projName) { Write-Host "Usage: project edit @project" -ForegroundColor Yellow; return }
    $proj = ($data.projects | Where-Object { $_ -ne $null -and $_.name -eq $projName } | Select-Object -First 1)
    if (-not $proj) { Write-Host ("Project '{0}' not found" -f $projName) -ForegroundColor Red; return }

    Write-PmcDebug -Level 1 -Category 'EDITOR' -Message ("Project editor start: '{0}'" -f $proj.name)
    $fields = @(
        @{ Key='name'; Label='Name' },
        @{ Key='description'; Label='Description' },
        @{ Key='ID2'; Label='ID2' },
        @{ Key='CAAName'; Label='CAAName' },
        @{ Key='ProjFolder'; Label='ProjFolder' },
        @{ Key='AssignedDate'; Label='AssignedDate' },
        @{ Key='DueDate'; Label='DueDate' },
        @{ Key='BFDate'; Label='BFDate' },
        @{ Key='RequestName'; Label='RequestName' },
        @{ Key='T2020'; Label='T2020' }
    )
    $sel = 0; $modified = $false

    function render-proj([pscustomobject]$p,[int]$idx) {
        Clear-Host
        Show-PmcHeader -Title ("EDIT PROJECT: {0}" -f $p.name)
        for ($i=0; $i -lt $fields.Count; $i++) {
            $f = $fields[$i]
            $val = if ($p.PSObject.Properties[$f.Key]) { [string]$p.($f.Key) } else { '' }
            $prefix = if ($i -eq $idx) { '► ' } else { '  ' }
            Write-Host ("{0}{1,-16} {2}" -f $prefix, ($f.Label + ':'), $val)
        }
        Write-Host ""
        Write-PmcStyled -Style 'Muted' -Text "  ↑/↓ select, Enter edit, Q/Esc save and exit"
    }

    while ($true) {
        render-proj $proj $sel
        $key = $null
        try { $key = [Console]::ReadKey($true) } catch { break }
        switch ($key.Key) {
            'UpArrow' { if ($sel -gt 0) { $sel-- }; continue }
            'DownArrow' { if ($sel -lt ($fields.Count-1)) { $sel++ }; continue }
            'Enter' {
                $f = $fields[$sel]
                $current = if ($proj.PSObject.Properties[$f.Key]) { [string]$proj.($f.Key) } else { '' }
                $inp = Read-Host ("$($f.Label) [$current]")
                if ($null -ne $inp -and $inp -ne '') { $proj | Add-Member -NotePropertyName $f.Key -NotePropertyValue $inp -Force; $modified=$true }
                continue }
            'Q' { break }
            'Escape' { break }
            default { continue }
        }
        break
    }

    if ($modified) {
        Save-StrictData $data 'project update'
        Write-Host ("Saved project: {0}" -f $proj.name) -ForegroundColor Green
    } else {
        Write-Host 'No changes' -ForegroundColor Gray
    }
    Write-PmcDebug -Level 1 -Category 'EDITOR' -Message ("Project editor end: '{0}' modified={1}" -f $proj.name, $modified)
}

function Find-PmcTask { param([PmcCommandContext]$Context)
    $q = ($Context.FreeText -join ' ').Trim(); if (-not $q) { Write-Host "Usage: task search <query>" -ForegroundColor Yellow; return }
    $data = Get-PmcDataAlias
    $hits = @($data.tasks | Where-Object { try { $_.text -and ($_.text.ToLower().Contains($q.ToLower())) } catch { $false } })
    Write-Host "\nSEARCH: '$q'" -ForegroundColor Cyan
    if ($hits.Count -eq 0) { Write-Host 'No matches' -ForegroundColor Yellow; return }
    $i=1; $map=@{}; Set-PmcLastTaskListMap $map
    foreach ($t in $hits) { $map[$i]=$t.id; Set-PmcLastTaskListMap $map; Write-Host ("  [{0,2}] (#{1}) {2}" -f $i,$t.id,$t.text) -ForegroundColor White; $i++ }
}

function Set-PmcTaskPriority { param([PmcCommandContext]$Context)
    $lvlText = ($Context.FreeText -join ' ').Trim(); if (-not $lvlText -match '^[1-3]$') { Write-Host "Usage: task priority <1|2|3>" -ForegroundColor Yellow; return }
    $lvl = [int]$lvlText
    $data = Get-PmcDataAlias
    $hits = @($data.tasks | Where-Object { try { $_.priority -eq $lvl -and $_.status -eq 'pending' } catch { $false } })
    Write-Host ("\nPRIORITY p{0}" -f $lvl) -ForegroundColor Cyan
    if ($hits.Count -eq 0) { Write-Host 'No tasks' -ForegroundColor Yellow; return }
    $i=1; $map=@{}; Set-PmcLastTaskListMap $map
    foreach ($t in $hits) { $map[$i]=$t.id; Set-PmcLastTaskListMap $map; Write-Host ("  [{0,2}] (#{1}) {2}" -f $i,$t.id,$t.text) -ForegroundColor White; $i++ }
}

# ===== VIEWS =====
function Show-PmcTaskAgenda { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    $today = (Get-Date).Date
    $pending = @($data.tasks | Where-Object { try { $_ -ne $null -and $_.status -eq 'pending' } catch { $false } })
    $overdue = @($pending | Where-Object { $_.due -and ([datetime]$_.due) -lt $today })
    $todayTasks = @($pending | Where-Object { $_.due -and ([datetime]$_.due) -eq $today })
    $upcoming = @($pending | Where-Object { $_.due -and ([datetime]$_.due) -gt $today -and ([datetime]$_.due) -le $today.AddDays(7) })
    $nodue = @($pending | Where-Object { -not $_.due })
    Set-PmcLastTaskListMap @{}
    $i=1
    function render-section([string]$title, [array]$items) {
        if (@($items).Count -eq 0) { return }
        $rows=@()
        foreach ($t in ($items | Sort-Object @{Expression={ if ($_.PSObject.Properties['priority']){ 4 - [int]$_.priority } else { 0 } }}, @{Expression={ if ($_.PSObject.Properties['due']){ try { [datetime]$_.due } catch { [datetime]::MaxValue } } else { [datetime]::MaxValue } }})) {
            $map = Get-PmcLastTaskListMap
            $map[$i] = $t.id
            Set-PmcLastTaskListMap $map
            $priVal = ''
            if ($t.PSObject.Properties.Match('priority').Count -gt 0 -and $t.priority) { $priVal = 'p' + $t.priority }
            $dueVal = ''
            if ($t.PSObject.Properties.Match('due').Count -gt 0 -and $t.due) { try { $dueVal = ([datetime]$t.due).ToString('MM/dd') } catch {
                # Date formatting failed - dueVal remains empty
            } }
            $projName = if ($t.PSObject.Properties.Match('project').Count -gt 0 -and $t.project) { $t.project } else { '(none)' }
            $taskText = if ($t.PSObject.Properties.Match('text').Count -gt 0) { $t.text } else { '' }
            $rows += @{ idx = ('[{0,2}]' -f $i); id = ('#' + $t.id); pri = $priVal; task = $taskText; project = $projName; due = $dueVal }
            $i++
        }
        $cols = @(
            @{ key='idx'; title='#'; width=5; align='right' },
            @{ key='id'; title='ID'; width=6 },
            @{ key='pri'; title='Pri'; width=4 },
            @{ key='task'; title='Task'; width=40 },
            @{ key='project'; title='Project'; width=18 },
            @{ key='due'; title='Due'; width=8 }
        )
        Show-PmcTable -Columns $cols -Rows $rows -Title $title
    }
    Show-PmcHeader -Title ("AGENDA: {0}" -f $today.ToString('yyyy-MM-dd'))
    render-section 'OVERDUE' $overdue
    render-section 'TODAY' $todayTasks
    render-section 'UPCOMING (7d)' $upcoming
    render-section 'NO DUE' $nodue
    Show-PmcTip "Use 'task view <#>', 'task done <#>', 'task edit <#>'"
}

function Show-PmcTaskWeek { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    $today = (Get-Date).Date
    $start = $today.AddDays(-[int]$today.DayOfWeek)
    $end = $start.AddDays(7)
    Show-PmcHeader -Title ("WEEK: {0} - {1}" -f $start.ToString('yyyy-MM-dd'), $end.AddDays(-1).ToString('yyyy-MM-dd'))
    $rows=@()
    for ($d=0; $d -lt 7; $d++) {
        $day=$start.AddDays($d)
        $items = @($data.tasks | Where-Object { try { $_.status -eq 'pending' -and $_.PSObject.Properties.Match('due').Count -gt 0 -and $_.due -and ([datetime]$_.due) -eq $day } catch { $false } })
        $text = if (@($items).Count -gt 0) { (@($items | Select-Object -First 3 | ForEach-Object { $_.text })) -join '; ' } else { '' }
        $rows += @{ day=$day.ToString('ddd MM/dd'); count=@($items).Count; tasks=$text }
    }
    $cols = @(
        @{ key='day'; title='Day'; width=12 },
        @{ key='count'; title='Count'; width=7; align='right' },
        @{ key='tasks'; title='Tasks'; width=50 }
    )
    Show-PmcTable -Columns $cols -Rows $rows
}

function Show-PmcTaskMonth { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    $today = Get-Date
    $year=$today.Year; $month=$today.Month
    $first = Get-Date -Year $year -Month $month -Day 1
    $days = [DateTime]::DaysInMonth($year,$month)
    $end = $first.AddDays($days)
    Show-PmcHeader -Title (Get-Date -Year $year -Month $month -Day 1 -Format 'MMMM yyyy')
    $rows=@()
    for ($d=1; $d -le $days; $d++) {
        $day = Get-Date -Year $year -Month $month -Day $d
        $items = @($data.tasks | Where-Object { try { $_.status -eq 'pending' -and $_.PSObject.Properties.Match('due').Count -gt 0 -and $_.due -and ([datetime]$_.due) -eq $day.Date } catch { $false } })
        if (@($items).Count -gt 0) { $rows += @{ date=$day.ToString('MM/dd ddd'); count=@($items).Count; sample=(@($items | Select-Object -First 2 | ForEach-Object { $_.text }) -join '; ') } }
    }
    if (@($rows).Count -eq 0) { Show-PmcTip 'No scheduled tasks this month'; return }
    $cols = @(
        @{ key='date'; title='Date'; width=12 },
        @{ key='count'; title='Count'; width=7; align='right' },
        @{ key='sample'; title='Tasks'; width=50 }
    )
    Show-PmcTable -Columns $cols -Rows $rows
}

# ===== PROJECTS =====
function Add-PmcProject { param([PmcCommandContext]$Context)
    $name = ($Context.FreeText -join ' ').Trim()
    if ([string]::IsNullOrWhiteSpace($name)) { Write-Host "Usage: project add <name>" -ForegroundColor Yellow; return }
    $data = Get-PmcDataAlias
    if ($data.projects | Where-Object { $_.name -eq $name }) { Write-Host "Project '$name' already exists" -ForegroundColor Yellow; return }
    $proj = [pscustomobject]@{ name=$name; description="Created $(Get-Date -Format yyyy-MM-dd)"; aliases=@(); created=(Get-Date).ToString('yyyy-MM-dd HH:mm:ss') }
    $data.projects += $proj; Save-StrictData $data 'project add'
    Write-Host "Project '$name' created." -ForegroundColor Green
}

function Get-PmcProjectList { param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category 'COMMAND' -Message "PROJECT LIST DEBUG: Starting Get-PmcProjectList"
    try {
        $data = Get-PmcDataAlias
        Write-PmcDebug -Level 1 -Category 'COMMAND' -Message "PROJECT LIST DEBUG: Got data, projects count: $($data.projects.Count)"
        Write-PmcDebug -Level 1 -Category 'COMMAND' -Message "PROJECT LIST DEBUG: First project type: $($data.projects[0].GetType().Name)"
        Write-PmcDebug -Level 1 -Category 'COMMAND' -Message "PROJECT LIST DEBUG: First project properties: $($data.projects[0].PSObject.Properties.Name -join ', ')"

        $rows=@(); foreach ($p in ($data.projects | Sort-Object name)) {
            Write-PmcDebug -Level 1 -Category 'COMMAND' -Message "PROJECT LIST DEBUG: Processing project name='$($p.name)'"
            $taskCount = (@($data.tasks | Where-Object { $_ -ne $null -and $_.PSObject.Properties.Match('project').Count -gt 0 -and $_.PSObject.Properties.Match('status').Count -gt 0 -and $_.project -eq $p.name -and $_.status -eq 'pending' }).Count)
            $desc = if ((Pmc-HasProp $p 'description') -and $p.description) { [string]$p.description } else { '' }
            $rows += @{ project=$p.name; tasks=$taskCount; desc=$desc }
        }
        Write-PmcDebug -Level 1 -Category 'COMMAND' -Message "PROJECT LIST DEBUG: Created $($rows.Count) rows"

        $cols = @(
            @{ key='project'; title='Project'; width=22 },
            @{ key='tasks'; title='Tasks'; width=7; align='right' },
            @{ key='desc'; title='Description'; width=40 }
        )
        Show-PmcTable -Columns $cols -Rows $rows -Title 'PROJECTS'
    } catch {
        Write-PmcDebug -Level 1 -Category 'COMMAND' -Message "PROJECT LIST ERROR: $_ | StackTrace: $($_.ScriptStackTrace)"
        Write-Host "Error: $_" -ForegroundColor Red
    }
}

function Show-PmcProject { param([PmcCommandContext]$Context)
    $q = ($Context.FreeText -join ' ').Trim()
    if ([string]::IsNullOrWhiteSpace($q)) { Write-Host "Usage: project view <name>" -ForegroundColor Yellow; return }
    # Show-ProjectDetails not available - basic view only
    $data = Get-PmcDataAlias
    $p = Resolve-Project -Data $data -Name $q
    if (-not $p) { Show-PmcError ("Project '{0}' not found" -f $q); return }
    Write-Host ("\nProject: {0}" -f $p.name) -ForegroundColor Cyan
    Write-Host ("  Description: {0}" -f (if ((Pmc-HasProp $p 'description') -and $p.description) { [string]$p.description } else { '' }))
}

function Rename-PmcProject { param([PmcCommandContext]$Context)
    $parts = ($Context.FreeText -join ' ') -split '\s+', 2
    if ($parts.Count -lt 2) { Write-Host "Usage: project rename <old> <new>" -ForegroundColor Yellow; return }
    $old = $parts[0]; $new = $parts[1]
    $data = Get-PmcDataAlias
    $proj = Resolve-Project -Data $data -Name $old
    if (-not $proj) { Show-PmcError ("Project '{0}' not found" -f $old); return }
    if ($data.projects | Where-Object { $_.name -eq $new -and $_.name -ne $old }) { Write-Host "Project '$new' already exists" -ForegroundColor Red; return }
    $proj.name = $new
    foreach ($t in $data.tasks) { if ($t.project -eq $old) { $t.project = $new } }
    $ctx = Get-PmcCurrentContext
    if ($ctx -eq $old) { $data.currentContext = $new; $global:CurrentContext = $new; Set-PmcState -Section 'Focus' -Key 'Current' -Value $new }
    Save-StrictData $data 'project rename'
    Write-Host "Renamed project '$old' to '$new'" -ForegroundColor Green
}

function Remove-PmcProject {
    [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact='High')]
    param(
        [PmcCommandContext]$Context
    )
    $name = ($Context.FreeText -join ' ').Trim()
    if ([string]::IsNullOrWhiteSpace($name)) { Write-Host "Usage: project delete <name>" -ForegroundColor Yellow; return }
    if ($name -in @('inbox','personal','work')) { Write-Host "Cannot delete default project '$name'" -ForegroundColor Red; return }
    $data = Get-PmcDataAlias
    $proj = Resolve-Project -Data $data -Name $name
    if (-not $proj) { Show-PmcError ("Project '{0}' not found" -f $name); return }
    $tasks = @($data.tasks | Where-Object { $_ -ne $null -and $_.PSObject.Properties.Match('project').Count -gt 0 -and $_.project -eq $name })
    $timeLogs = @($data.timelogs | Where-Object { $_ -ne $null -and $_.PSObject.Properties.Match('project').Count -gt 0 -and $_.project -eq $name })
    Write-Host "Deleting '$name' will remove: tasks=$($tasks.Count), time logs=$($timeLogs.Count)" -ForegroundColor Yellow
    # Require explicit confirmation to avoid accidental data loss
    $confirmMsg = "Delete project '$name' and all associated data?"
    if (-not $PSCmdlet.ShouldProcess($name, $confirmMsg)) { return }
    # Additional human-in-the-loop confirmation when not suppressed by -Confirm:$false
    $shouldPrompt = ($ConfirmPreference -ne 'None')
    if ($shouldPrompt) {
        $typed = Read-Host "Type the project name exactly to confirm deletion"
        if ($typed -ne $name) {
            Write-Host "Canceled" -ForegroundColor Gray
            return
        }
    }
    $data.tasks = @($data.tasks | Where-Object { $_.project -ne $name })
    $data.timelogs = @($data.timelogs | Where-Object { $_.project -ne $name })
    $data.projects = @($data.projects | Where-Object { $_.name -ne $name })
    $ctx = Get-PmcCurrentContext
    if ($ctx -eq $name) { $global:CurrentContext='inbox'; $data.currentContext='inbox'; Set-PmcState -Section 'Focus' -Key 'Current' -Value 'inbox' }
    Save-StrictData $data 'project delete'
    Write-Host "Deleted project '$name'" -ForegroundColor Green
}

# Archive project
function Set-PmcProjectArchived { param([PmcCommandContext]$Context)
    $name = ($Context.FreeText -join ' ').Trim()
    if ([string]::IsNullOrWhiteSpace($name)) { Write-Host "Usage: project archive <name>" -ForegroundColor Yellow; return }
    $data = Get-PmcDataAlias
    $proj = Resolve-Project -Data $data -Name $name
    if (-not $proj) { Show-PmcError ("Project '{0}' not found" -f $name); return }
    if ((Pmc-HasProp $proj 'isArchived') -and $proj.isArchived) { Write-Host "Project '$name' is already archived" -ForegroundColor Yellow; return }
    $proj.isArchived = $true
    $proj.archivedDate = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
    if ($data.currentContext -eq $name) { $data.currentContext = 'inbox' }
    Save-StrictData $data 'project archive'
    Write-Host "Archived project '$name'" -ForegroundColor Green
}

# Set project fields
function Set-PmcProjectFields { param([PmcCommandContext]$Context)
    $projName = if ($Context.Args.ContainsKey('project')) { $Context.Args['project'] } else { $null }
    if (-not $projName) { Write-Host "Usage: project set-fields @project Key=Value ..." -ForegroundColor Yellow; return }
    $data = Get-PmcDataAlias
    $proj = Resolve-Project -Data $data -Name $projName
    if (-not $proj) { Show-PmcError ("Project '{0}' not found" -f $projName); return }
    $pairs = ($Context.FreeText -join ' ').Trim()
    if (-not $pairs) { Write-Host "No fields provided (expected Key=Value tokens)" -ForegroundColor Yellow; return }
    $updates = 0
    foreach ($tok in ($pairs -split '\s+')) {
        if ($tok -match '^(\w+)=(.+)$') {
            $k=$matches[1]; $v=$matches[2]
            try { if ($proj.PSObject.Properties[$k]) { $proj.$k = $v } else { $proj | Add-Member -NotePropertyName $k -NotePropertyValue $v -Force } $updates++ } catch {
                # Project property update failed - skip this field
            }
        }
    }
    Save-StrictData $data 'project set-fields'
    Show-PmcSuccess ("Updated {0} field(s) on '{1}'" -f $updates,$proj.name)
}

function Show-PmcProjectFields { param([PmcCommandContext]$Context)
    $projName = if ($Context.Args.ContainsKey('project')) { $Context.Args['project'] } else { $null }
    if (-not $projName) { Write-Host "Usage: project show-fields @project" -ForegroundColor Yellow; return }
    $data = Get-PmcDataAlias
    $proj = Resolve-Project -Data $data -Name $projName
    if (-not $proj) { Show-PmcError ("Project '{0}' not found" -f $projName); return }
    Write-Host ("\nPROJECT FIELDS: {0}" -f $proj.name) -ForegroundColor Cyan
    foreach ($p in $proj.PSObject.Properties) {
        Write-Host ("  {0}: {1}" -f $p.Name, ($p.Value)) -ForegroundColor White
    }
}

# Thin wrapper: project update @name Key=Value ... (alias of set-fields with explicit name)
function Set-PmcProject { param([PmcCommandContext]$Context)
    $projName = if ($Context.Args.ContainsKey('project')) { $Context.Args['project'] } else { $null }
    if (-not $projName) { Write-Host "Usage: project update @project Key=Value ..." -ForegroundColor Yellow; return }
    $data = Get-PmcDataAlias
    $proj = Resolve-Project -Data $data -Name $projName
    if (-not $proj) { Show-PmcError ("Project '{0}' not found" -f $projName); return }
    $pairs = ($Context.FreeText -join ' ').Trim()
    if (-not $pairs) { Write-Host "No fields provided (expected Key=Value tokens)" -ForegroundColor Yellow; return }
    $updates = 0
    foreach ($tok in ($pairs -split '\s+')) {
        if ($tok -match '^(\w+)=(.+)$') {
            $k=$matches[1]; $v=$matches[2]
            try { if ($proj.PSObject.Properties[$k]) { $proj.$k = $v } else { $proj | Add-Member -NotePropertyName $k -NotePropertyValue $v -Force } $updates++ } catch {
                # Project property update failed - skip this field
            }
        }
    }
    Save-StrictData $data 'project update'
    Show-PmcSuccess ("Updated {0} field(s) on '{1}'" -f $updates,$proj.name)
}

# Project insights
function Get-PmcProjectStats { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    $name = if ($Context.Args.ContainsKey('project')) { $Context.Args['project'] } else { '' }
    if ([string]::IsNullOrWhiteSpace($name)) { Write-Host "Usage: project stats @project" -ForegroundColor Yellow; return }
    $proj = Resolve-Project -Data $data -Name $name
    if (-not $proj) { Show-PmcError ("Project '{0}' not found" -f $name); return }
    $tasks = @($data.tasks | Where-Object { $_ -ne $null -and $_.PSObject.Properties.Match('project').Count -gt 0 -and $_.project -eq $proj.name })
    $pending = @($tasks | Where-Object { $_.PSObject.Properties.Match('status').Count -gt 0 -and $_.status -eq 'pending' })
    $done = @($tasks | Where-Object { $_.PSObject.Properties.Match('status').Count -gt 0 -and $_.status -eq 'completed' })
    $overdueCount = 0
    foreach ($t in $pending) {
        if ($t.PSObject.Properties.Match('due').Count -gt 0 -and $t.due) {
            try { if ([datetime]$t.due -lt (Get-Date).Date) { $overdueCount++ } } catch {
                # Date comparison failed - skip overdue check for this task
            }
        }
    }
    $blocked = @($pending | Where-Object { $_.PSObject.Properties.Match('blocked').Count -gt 0 -and $_.blocked })
    $cols = @(@{key='metric';title='Metric';width=18}, @{key='value';title='Value';width=8;align='right'})
    $rows = @(
        @{ metric='Pending'; value=(@($pending).Count) },
        @{ metric='Completed'; value=(@($done).Count) },
        @{ metric='Overdue'; value=$overdueCount },
        @{ metric='Blocked'; value=(@($blocked).Count) }
    )
    Show-PmcTable -Columns $cols -Rows $rows -Title ("PROJECT STATS: {0}" -f $proj.name)
}

function Show-PmcProjectInfo { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    $name = if ($Context.Args.ContainsKey('project')) { $Context.Args['project'] } else { '' }
    if ([string]::IsNullOrWhiteSpace($name)) { Write-Host "Usage: project info @project" -ForegroundColor Yellow; return }
    $proj = Resolve-Project -Data $data -Name $name
    if (-not $proj) { Show-PmcError ("Project '{0}' not found" -f $name); return }
    Write-Host ("\nProject: {0}" -f $proj.name) -ForegroundColor Cyan
    foreach ($p in $proj.PSObject.Properties) { Write-Host ("  {0}: {1}" -f $p.Name, $p.Value) }
}

function Get-PmcRecentProjects { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    $recent = @()
    foreach ($p in $data.projects) {
        $latest = ($data.tasks | Where-Object { $_ -ne $null -and $_.PSObject.Properties.Match('project').Count -gt 0 -and $_.project -eq $p.name } | Sort-Object { try { [datetime]$_.created } catch { [datetime]::MinValue } } -Descending | Select-Object -First 1)
        if ($latest) { $recent += @{ project=$p.name; last=($latest.created ?? '') } }
    }
    if ($recent.Count -eq 0) { Write-Host 'No recent projects' -ForegroundColor Yellow; return }
    Show-PmcTable -Columns @(@{key='project';title='Project';width=22}, @{key='last';title='Last Activity';width=20}) -Rows ($recent | Sort-Object last -Descending) -Title 'RECENT PROJECTS'
}

# ===== TIME =====
function Get-PmcTimeList { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    if (-not $data.timelogs) { $data.timelogs = @() }
    $logs = @($data.timelogs | Where-Object { $_ -ne $null } | Sort-Object date, time | Select-Object -Last 50)
    Set-PmcLastTimeListMap @{}
    Write-Host "\nTIME LOGS (recent)" -ForegroundColor Cyan
    Write-Host "────────────────────" -ForegroundColor DarkGray
    if ($logs.Count -eq 0) { Write-Host "No time entries found" -ForegroundColor Yellow; return }
    $i=1
    foreach ($l in $logs) {
        $tlm = Get-PmcLastTimeListMap
        $tlm[$i] = $l.id
        Set-PmcLastTimeListMap $tlm
        $hrs = try { [Math]::Round([double]$l.minutes/60,2) } catch { 0 }
        $desc = ''
        if ($l.PSObject.Properties['notes'] -and $l.notes) { $desc = $l.notes }
        elseif ($l.PSObject.Properties['description'] -and $l.description) { $desc = $l.description }
        Write-Host ("  [{0,2}] {1} {2} {3} {4}h {5}" -f $i, $l.date, ($l.time ?? ''), ($l.project ?? '(none)'), $hrs, $desc) -ForegroundColor White
        $i++
    }
    Write-Host "  Tip: Use 'time edit <#>' or 'time delete <#>'" -ForegroundColor DarkGray
}

function Add-PmcTimeEntry { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    # Re-tokenize to detect '#' codes reliably (parser may consume '#')
    $tokens = ConvertTo-PmcTokens $Context.Raw
    $projName = if ($Context.Args.ContainsKey('project')) { $Context.Args['project'] } else { $null }
    $id1Code = $null
    foreach ($tok in $tokens) { if (-not $id1Code -and $tok -match '^#(\d{2,5})$') { $id1Code = $matches[1] } }

    # Enforce exactly one of project or id1 code
    $hasProj = ([string]::IsNullOrWhiteSpace($projName) -eq $false)
    $hasId1 = ([string]::IsNullOrWhiteSpace($id1Code) -eq $false)
    if (($hasProj -and $hasId1) -or (-not $hasProj -and -not $hasId1)) {
        Write-Host "Specify exactly one of: @project OR #<id1code> (2-5 digits)" -ForegroundColor Yellow
        return
    }

    $proj = $null
    if ($hasProj) {
        $proj = Resolve-Project -Data $data -Name $projName
        if (-not $proj) { Show-PmcError ("Unknown project: {0}" -f $projName); return }
    }

    # parse date and duration from FreeText
    $dateTok = $null; $durTok = $null; $descParts = @()
    foreach ($t in $Context.FreeText) {
        if (-not $dateTok -and ($t -match '^(?i)today$' -or $t -match '^(?i)yesterday$' -or $t -match '^\d{4}-\d{2}-\d{2}$')) { $dateTok = $t; continue }
        if (-not $durTok -and ($t -match '^\d+(?:\.\d+)?$' -or $t -match '^\d+(?:\.\d+)?h$' -or $t -match '^\d+m$')) { $durTok = $t; continue }
        # Skip any '#' id1 token remnants in FreeText (already captured from tokens)
        if ($t -match '^#\d{2,5}$') { continue }
        $descParts += $t
    }
    $date = if ($dateTok) { ConvertTo-PmcDate $dateTok } else { (Get-Date).Date }
    $minutes = if ($durTok) { ConvertTo-PmcDurationMinutes $durTok } else { 0 }
    if ($minutes -le 0) { Write-Host "Invalid or missing duration (e.g., 1.5)" -ForegroundColor Yellow; return }
    $log = @{
        minutes = $minutes
        date = $date.ToString('yyyy-MM-dd')
        time = (Get-Date).ToString('HH:mm')
        notes = ($descParts -join ' ')
        id = (Get-PmcNextTimeLogId $data)
    }
    if ($hasProj) { $log.project = $proj.name } else { $log.id1 = $id1Code }
    $data.timelogs += $log
    Save-StrictData $data 'time log'
    # CSV export (module-owned)
    try {
        $cfg = Get-PmcConfig
        $enabled = $true; if ($cfg.Behavior -and $cfg.Behavior.EnableCsvLedger -ne $null) { $enabled = [bool]$cfg.Behavior.EnableCsvLedger }
        if ($enabled) {
            $csvPath = if ($cfg.Paths -and $cfg.Paths.CsvLedgerPath) { [string]$cfg.Paths.CsvLedgerPath } else { 'time_ledger.csv' }
            if ([string]::IsNullOrWhiteSpace($csvPath)) { $csvPath = 'time_ledger.csv' }
            $outPath = Get-PmcSafePath $csvPath
            $dir = Split-Path $outPath -Parent; if (-not (Test-Path $dir)) { New-Item -ItemType Directory -Path $dir -Force | Out-Null }
            if (-not (Test-Path $outPath)) { 'Date,Time,Project,Duration_Minutes,Duration_Hours,Description,LogID' | Set-Content -Path $outPath -Encoding UTF8 }
            $hrs = [Math]::Round($log.minutes/60,2)
            $desc = if ($log.notes) { '"' + ($log.notes -replace '"','""') + '"' } else { '' }
            ($log.date + ',' + ($log.time ?? '') + ',' + $log.project + ',' + $log.minutes + ',' + $hrs + ',' + $desc + ',' + $log.id) | Add-Content -Path $outPath -Encoding UTF8
        }
    } catch {
        # Time log export failed - continue with summary message
    }
    $hours = [Math]::Round($minutes/60,2)
    Show-PmcSuccess ("Logged {0} hours to '{1}'" -f $hours, $proj.name)
}

function Edit-PmcTimeEntry { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    if ($Context.FreeText.Count -lt 1) { Write-Host "Usage: time edit <id|#>" -ForegroundColor Yellow; return }
    $token = $Context.FreeText[0]
    $lookupId = $null
    if ($token -match '^\d+$') { $lookupId = [int]$token }
    $tmap = Get-PmcLastTimeListMap
    if (-not $lookupId -and $tmap.ContainsKey($token)) { $lookupId = $tmap[$token] }
    if (-not $lookupId -and $token -match '^\d+$' -and $tmap.ContainsKey([int]$token)) { $lookupId = $tmap[[int]$token] }
    if (-not $lookupId) { Write-Host "Invalid id/index" -ForegroundColor Red; return }
    $log = $data.timelogs | Where-Object { $_ -ne $null -and $_.id -eq $lookupId } | Select-Object -First 1
    if (-not $log) { Write-Host "Time log #$lookupId not found" -ForegroundColor Red; return }
    # Minimal interactive edit
    $newDate = Read-Host ("Date [$($log.date)]")
    $newTime = Read-Host ("Time [$($log.time ?? '')]")
    $newProj = Read-Host ("Project [$($log.project)]")
    $newHrs  = Read-Host ("Hours (e.g., 1.5) [$([math]::Round($log.minutes/60.0, 2))]")
    $newDesc = Read-Host ("Description [$($log.notes ?? '')]")
    if ($newDate) { $log.date = $newDate }
    if ($newTime) { $log.time = $newTime }
    if ($newProj) { $log.project = $newProj }
    if ($newHrs) { try { $log.minutes = [int]([double]$newHrs * 60) } catch {
        # Hours conversion failed - minutes field unchanged
    } }
    if ($null -ne $newDesc) { if ($newDesc) { $log.notes = $newDesc } else { $log.PSObject.Properties.Remove('notes') | Out-Null } }
    Save-StrictData $data 'time edit'
    Write-Host "Saved time log #$($log.id)" -ForegroundColor Green
}

function Parse-PmcDateRange {
    param([string[]]$Tokens)
    $today = (Get-Date).Date
    $start = $today; $end = $today.AddDays(1); $label = 'today'
    foreach ($tok in $Tokens) {
        $t = $tok.ToLower()
        switch ($t) {
            'today' {
                # Clamp to current weekday; we still render Mon–Fri
                $start=$today; $end=$today.AddDays(1); $label='today'; continue }
            'yesterday' { $start=$today.AddDays(-1); $end=$today; $label='yesterday'; continue }
            'week' {
                $monday = $today.AddDays(-( (([int]$today.DayOfWeek + 6) % 7) ))
                $start=$monday; $end=$monday.AddDays(5); $label='this week'; continue }
            'lastweek' {
                $monday = $today.AddDays(-( (([int]$today.DayOfWeek + 6) % 7) ) - 7)
                $start=$monday; $end=$monday.AddDays(5); $label='last week'; continue }
            'nextweek' {
                $monday = $today.AddDays(-( (([int]$today.DayOfWeek + 6) % 7) ) + 7)
                $start=$monday; $end=$monday.AddDays(5); $label='next week'; continue }
            default {
                if ($t -match '^(\d{4}-\d{2}-\d{2})\.\.(\d{4}-\d{2}-\d{2})$') {
                    $start=[datetime]::ParseExact($matches[1],'yyyy-MM-dd',$null)
                    $end=[datetime]::ParseExact($matches[2],'yyyy-MM-dd',$null).AddDays(1)
                    $label=("{0}..{1}" -f $matches[1],$matches[2])
                } elseif ($t -match '^\d{4}-\d{2}-\d{2}$') {
                    $d=[datetime]::ParseExact($t,'yyyy-MM-dd',$null)
                    $start=$d; $end=$d.AddDays(1); $label=$t
                }
            }
        }
    }
    return @{ Start=$start; End=$end; Label=$label }
}

function Remove-PmcTimeEntry { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    if ($Context.FreeText.Count -lt 1) { Write-Host "Usage: time delete <id|#>" -ForegroundColor Yellow; return }
    $token = $Context.FreeText[0]
    $lookupId = $null
    if ($token -match '^\d+$') { $lookupId = [int]$token }
    $tmap = Get-PmcLastTimeListMap
    if (-not $lookupId -and $tmap.ContainsKey($token)) { $lookupId = $tmap[$token] }
    if (-not $lookupId -and $token -match '^\d+$' -and $tmap.ContainsKey([int]$token)) { $lookupId = $tmap[[int]$token] }
    if (-not $lookupId) { Write-Host "Invalid id/index" -ForegroundColor Red; return }
    $log = $data.timelogs | Where-Object { $_ -ne $null -and $_.id -eq $lookupId } | Select-Object -First 1
    if (-not $log) { Write-Host "Time log #$lookupId not found" -ForegroundColor Red; return }
    $data.timelogs = @($data.timelogs | Where-Object { $_.id -ne $lookupId })
    Save-StrictData $data 'time delete'
    Write-Host "Deleted time log #$lookupId" -ForegroundColor Green
}

function Get-PmcTimeReport { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    Write-PmcDebug -Level 1 -Category 'REPORT' -Message 'TIME REPORT: start'
    # Parse flags and tokens: range, --withids, out:, byid2:
    $withIds = $false; $outPath=$null; $byId2=$null; $jsonPath=$null; $rich=$false
    foreach ($tok in $Context.FreeText) {
        if ($tok -match '^--withids$') { $withIds=$true; continue }
        if ($tok -match '^out:(.+)$') { $outPath=$matches[1]; continue }
        if ($tok -match '^byid2:(.+)$') { $byId2=$matches[1]; continue }
        if ($tok -match '^json:(.+)$') { $jsonPath=$matches[1]; continue }
        if ($tok -match '^--richcsv$') { $rich=$true; continue }
    }
    if (-not $rich) { try { $cfg = Get-PmcConfig; if ($cfg.Behavior -and $cfg.Behavior.ReportRichCsv) { $rich = [bool]$cfg.Behavior.ReportRichCsv } } catch { } }
    $rangeInfo = Parse-PmcDateRange -Tokens $Context.FreeText
    # Anchor to Monday→Friday week based on selected start
    $anchor = $rangeInfo.Start.Date
    $monday = $anchor.AddDays(-((( [int]$anchor.DayOfWeek + 6) % 7)))
    $friday = $monday.AddDays(4)
    $start = $monday; $end = $friday.AddDays(1); $label = 'week'
    Write-PmcDebug -Level 2 -Category 'REPORT' -Message 'Range selected (Mon–Fri)' -Data @{ Monday=$start; Friday=$friday }
    $logs = @($data.timelogs | Where-Object { try { ([datetime]$_.date -ge $start) -and ([datetime]$_.date -lt $end) } catch { $false } })
    if ($Context.Args.ContainsKey('project')) { $p = $Context.Args['project']; $logs = $logs | Where-Object { $_.project -eq $p } }
    if ($byId2) {
        $allow = @($data.projects | Where-Object { $_.PSObject.Properties['ID2'] -and $_.ID2 -eq $byId2 } | ForEach-Object { $_.name })
        if (@($allow).Count -gt 0) { $logs = $logs | Where-Object { $allow -contains $_.project } }
    }
    if ($logs.Count -eq 0) { Write-Host "No time logged for range" -ForegroundColor Yellow; return }
    # Build fixed Mon–Fri day list (always 5 columns)
    $days = @($start, $start.AddDays(1), $start.AddDays(2), $start.AddDays(3), $start.AddDays(4))
    $cols = @(
        @{ key='name'; title='Name'; width=22 },
        @{ key='id1'; title='ID1'; width=6 },
        @{ key='id2'; title='ID2'; width=8 }
    )
    for ($i=0; $i -lt $days.Count; $i++) { $cols += @{ key=("d$($i)"); title=$days[$i].ToString('ddd'); width=6; align='right' } }
    $cols += @{ key='total'; title='Total'; width=8; align='right' }

    # Partition logs into project-tied and generic (id1)
    $projectRows = @{}
    $codeRows = @{}
    foreach ($l in $logs) {
        $d = try { [datetime]$l.date } catch { $null }
        if (-not $d) { continue }
        if ($d.DayOfWeek -notin @([DayOfWeek]::Monday,[DayOfWeek]::Tuesday,[DayOfWeek]::Wednesday,[DayOfWeek]::Thursday,[DayOfWeek]::Friday)) { continue }
        $keyDay = $d.ToString('yyyy-MM-dd')
        if ($l.PSObject.Properties['project'] -and $l.project) {
            $k = [string]$l.project
            if (-not $projectRows.ContainsKey($k)) { $projectRows[$k] = @{} }
            if (-not $projectRows[$k].ContainsKey($keyDay)) { $projectRows[$k][$keyDay] = 0 }
            $projectRows[$k][$keyDay] += [int]$l.minutes
        } elseif ($l.PSObject.Properties['id1'] -and $l.id1) {
            $k = [string]$l.id1
            if (-not $codeRows.ContainsKey($k)) { $codeRows[$k] = @{} }
            if (-not $codeRows[$k].ContainsKey($keyDay)) { $codeRows[$k][$keyDay] = 0 }
            $codeRows[$k][$keyDay] += [int]$l.minutes
        }
    }

    $rows = @(); $grand = 0
    # Project rows
    foreach ($pname in (@($projectRows.Keys) | Sort-Object)) {
        $proj = ($data.projects | Where-Object { $_.name -eq $pname } | Select-Object -First 1)
        $id2 = if ($proj -and $proj.PSObject.Properties['ID2']) { [string]$proj.ID2 } else { '' }
        $row = @{ name=$pname; id1=''; id2=$id2 }
        $sum = 0
        for ($i=0; $i -lt $days.Count; $i++) {
            $dStr = $days[$i].ToString('yyyy-MM-dd')
            $mins = if ($projectRows[$pname].ContainsKey($dStr)) { [int]$projectRows[$pname][$dStr] } else { 0 }
            $sum += $mins
            $row[("d$($i)")] = ([Math]::Round($mins/60,2)).ToString('0.##')
        }
        $row['total'] = ([Math]::Round($sum/60,2)).ToString('0.##')
        $grand += $sum
        $rows += $row
    }
    # Generic code rows
    foreach ($code in (@($codeRows.Keys) | Sort-Object)) {
        $row = @{ name=''; id1=[string]$code; id2='' }
        $sum = 0
        for ($i=0; $i -lt $days.Count; $i++) {
            $dStr = $days[$i].ToString('yyyy-MM-dd')
            $mins = if ($codeRows[$code].ContainsKey($dStr)) { [int]$codeRows[$code][$dStr] } else { 0 }
            $sum += $mins
            $row[("d$($i)")] = ([Math]::Round($mins/60,2)).ToString('0.##')
        }
        $row['total'] = ([Math]::Round($sum/60,2)).ToString('0.##')
        $grand += $sum
        $rows += $row
    }

    Show-PmcHeader -Title ("TIME REPORT (Mon–Fri): {0} → {1}" -f $days[0].ToString('yyyy-MM-dd'), $days[-1].ToString('yyyy-MM-dd'))
    Show-PmcTable -Columns $cols -Rows $rows
    Show-PmcTip ("TOTAL: {0} h" -f ([Math]::Round($grand/60,2)))
    if ($withIds) {
        $detailRows=@()
        foreach ($l in ($logs | Sort-Object date, time)) { $detailRows += @{ date=$l.date; time=($l.time ?? ''); project=$l.project; hours=([Math]::Round($l.minutes/60,2)).ToString('0.##'); notes=($l.notes ?? '') } }
        $dcols = @(
            @{ key='date'; title='Date'; width=10 },
            @{ key='time'; title='Time'; width=6 },
            @{ key='project'; title='Project'; width=18 },
            @{ key='hours'; title='Hours'; width=7; align='right' },
            @{ key='notes'; title='Description'; width=40 }
        )
        Show-PmcTable -Columns $dcols -Rows $detailRows -Title 'DETAILS'
    }
    if ($outPath) {
        try {
            $out = Get-PmcSafePath $outPath
            if (-not (Test-Path (Split-Path $out -Parent))) { New-Item -ItemType Directory -Path (Split-Path $out -Parent) -Force | Out-Null }
            # Header
            $header = 'Date,Time,Project,Duration_Minutes,Duration_Hours,Description,LogID'
            if ($rich) { $header += ',ID2,CAAName' }
            if (-not (Test-Path $out)) { $header | Set-Content -Path $out -Encoding UTF8 } else { Clear-Content -Path $out; Add-Content -Path $out -Value $header -Encoding UTF8 }
            foreach ($l in $logs) {
                $hrs=[Math]::Round($l.minutes/60,2)
                $desc = if ($l.notes) { '"' + ($l.notes -replace '"','""') + '"' } else { '' }
                $id2=''; $caa=''
                if ($rich) {
                    try { $proj = ($data.projects | Where-Object { $_.name -eq $l.project } | Select-Object -First 1); if ($proj) { if ($proj.PSObject.Properties['ID2']) { $id2=$proj.ID2 }; if ($proj.PSObject.Properties['CAAName']) { $caa=$proj.CAAName } } } catch {
                        # Project lookup failed - ID2 and CAAName remain empty
                    }
                }
                $line = ($l.date + ',' + ($l.time ?? '') + ',' + $l.project + ',' + $l.minutes + ',' + $hrs + ',' + $desc + ',' + $l.id)
                if ($rich) { $line += (',' + $id2 + ',' + $caa) }
                $line | Add-Content -Path $out -Encoding UTF8
            }
            Show-PmcTip ("Exported to: {0}" -f $out)
        } catch { Write-Host "Export failed: $_" -ForegroundColor Red }
    }
    if ($jsonPath) {
        try {
            $out = Get-PmcSafePath $jsonPath
            if (-not (Test-Path (Split-Path $out -Parent))) { New-Item -ItemType Directory -Path (Split-Path $out -Parent) -Force | Out-Null }
            $arr = @(); foreach ($l in ($logs | Sort-Object date, time)) { $arr += [pscustomobject]@{ date=$l.date; time=($l.time ?? ''); project=$l.project; minutes=$l.minutes; hours=[Math]::Round($l.minutes/60,2); notes=($l.notes ?? ''); id=$l.id } }
            $arr | ConvertTo-Json -Depth 6 | Set-Content -Path $out -Encoding UTF8
            Show-PmcTip ("Exported JSON to: {0}" -f $out)
        } catch { Write-Host "JSON export failed: $_" -ForegroundColor Red }
    }
    Save-StrictData $data 'time report'
    Write-PmcDebug -Level 1 -Category 'REPORT' -Message 'TIME REPORT: done'
}

# ===== ACTIVITY =====
function Get-PmcActivityList { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    $rows = @()
    foreach ($a in ($data.activityLog | Select-Object -Last 50)) { $rows += @{ ts=$a.timestamp; user=($a.user ?? ''); action=$a.action } }
    if (@($rows).Count -eq 0) { Show-PmcHeader -Title 'ACTIVITY'; Show-PmcTip 'No activity entries'; return }
    $cols = @(
        @{ key='ts'; title='Timestamp'; width=20 },
        @{ key='user'; title='User'; width=10 },
        @{ key='action'; title='Action'; width=40 }
    )
    Show-PmcTable -Columns $cols -Rows $rows -Title 'ACTIVITY (last 50)'
}

# ===== TIMER =====
function Start-PmcTimer { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    $projName = if ($Context.Args.ContainsKey('project')) { $Context.Args['project'] } else { $null }
    $project = if ($projName) { $projName } else { 'inbox' }
    $desc = ($Context.FreeText -join ' ')
    if (-not ($data.PSObject.Properties['timer'])) { Add-Member -InputObject $data -MemberType NoteProperty -Name timer -Value @{} }
    $data.timer = @{
        active = $true
        project = $project
        description = $desc
        startTime = Get-Date
        startTimeString = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
    }
    Save-StrictData $data 'timer start'
    Write-Host "⏱️  Timer started for '$project'" -ForegroundColor Green
}

function Stop-PmcTimer { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    if (-not $data.timer -or -not $data.timer.active) { Write-Host "No active timer" -ForegroundColor Yellow; return }
    $endTime = Get-Date
    $startTime = [datetime]$data.timer.startTime
    $duration = $endTime - $startTime
    $minutes = [Math]::Round($duration.TotalMinutes,1)
    # Clear timer (do not persist session to timelogs)
    $info = $data.timer
    $data.timer = @{ active = $false }
    Save-StrictData $data 'timer stop'
    Write-Host ("⏹️  Timer stopped: {0}m on {1}" -f $minutes, ($info.project)) -ForegroundColor Cyan
}

function Get-PmcTimerStatus { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    if (-not $data.timer -or -not $data.timer.active) { Write-Host "  No active timer" -ForegroundColor Gray; return }
    $startTime = [datetime]$data.timer.startTime
    $elapsed = (Get-Date) - $startTime
    Write-Host "  Timer running" -ForegroundColor Green
    Write-Host "  Project: $($data.timer.project)"
    if ($data.timer.description) { Write-Host "  Description: $($data.timer.description)" }
    Write-Host ("  Elapsed: {0}h {1}m {2}s" -f $elapsed.Hours,$elapsed.Minutes,$elapsed.Seconds) -ForegroundColor Cyan
}

# ===== CONFIG / TEMPLATE / RECURRING (placeholders) =====
function Show-PmcConfig { param([PmcCommandContext]$Context)
    $cfg = Get-PmcConfig
    ($cfg | ConvertTo-Json -Depth 8) | Write-Host
}
function Edit-PmcConfig { param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category 'CONFIG' -Message 'config edit start'
    $cfg = Get-PmcConfig
    $json = $cfg | ConvertTo-Json -Depth 10
    $tmp = [System.IO.Path]::GetTempFileName() + '.json'
    $json | Set-Content -Path $tmp -Encoding UTF8

    # Determine editor (no fallback editing in-place; fail if none)
    $editor = $null
    if ($IsWindows) { $editor = 'notepad' }
    elseif ($env:EDITOR) { $editor = $env:EDITOR }

    if (-not $editor) {
        Write-PmcDebug -Level 1 -Category 'CONFIG' -Message 'No editor configured (set $env:EDITOR)'
        Write-Host "No editor configured. Set \$env:EDITOR or run on Windows (uses notepad)." -ForegroundColor Red
        Write-Host ("Temporary file is at: {0}" -f $tmp) -ForegroundColor Yellow
        return
    }

    try {
        Write-PmcDebug -Level 2 -Category 'CONFIG' -Message ("Launching editor: {0}" -f $editor)
        & $editor $tmp
    } catch {
        Write-PmcDebug -Level 1 -Category 'CONFIG' -Message ("Editor launch failed: {0}" -f $_)
        Write-Host ("Failed to launch editor '{0}'. Edit this file manually then rerun: {1}" -f $editor, $tmp) -ForegroundColor Red
        return
    }

    try {
        $new = Get-Content $tmp -Raw | ConvertFrom-Json -AsHashtable
    } catch {
        Write-PmcDebug -Level 1 -Category 'CONFIG' -Message 'Invalid JSON on save'
        Write-Host "Invalid JSON; config unchanged" -ForegroundColor Red
        return
    }

    Save-PmcConfig $new
    Write-PmcDebug -Level 1 -Category 'CONFIG' -Message 'config updated'
    Write-Host "Config updated" -ForegroundColor Green
}
function Set-PmcConfigValue { param([PmcCommandContext]$Context)
    $all = ($Context.FreeText -join ' ').Trim()
    if (-not $all) { Write-Host "Usage: config set <Path> <Value>  e.g., config set Behavior.UseStrictModule true" -ForegroundColor Yellow; return }
    $parts = $all -split '\s+', 2
    if ($parts.Count -lt 2) { Write-Host "Usage: config set <Path> <Value>" -ForegroundColor Yellow; return }
    $path = $parts[0]; $valRaw = $parts[1]
    # Convert value to native types if obvious
    $val = $valRaw
    if ($valRaw -match '^(?i)true|false$') { $val = [bool]::Parse($valRaw) }
    elseif ($valRaw -match '^-?\d+$') { $val = [int]$valRaw }
    $cfg = Get-PmcConfig
    # Walk nested hashtables by dot path
    $target = $cfg
    $keys = $path -split '\.'
    for ($i=0; $i -lt $keys.Length-1; $i++) {
        $k = $keys[$i]
        if (-not $target.ContainsKey($k)) { $target[$k] = @{} }
        $target = $target[$k]
    }
    $leaf = $keys[-1]
    $target[$leaf] = $val
    Save-PmcConfig $cfg
    Write-Host ("Set {0} = {1}" -f $path, $val) -ForegroundColor Green
}

function Save-PmcTemplate { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    $name = $null; $body=''
    $text = ($Context.FreeText -join ' ').Trim()
    if (-not $text) { Write-Host "Usage: template save <name> <body...>" -ForegroundColor Yellow; return }
    $parts = $text -split '\s+', 2
    $name = $parts[0]; if ($parts.Count -gt 1) { $body = $parts[1] }
    if (-not $data.templates) { $data.templates = @{} }
    $data.templates[$name] = $body
    Save-StrictData $data 'template save'
    Write-Host "Saved template '$name'" -ForegroundColor Green
}
function Invoke-PmcTemplate { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    $name = ($Context.FreeText -join ' ').Trim()
    if ([string]::IsNullOrWhiteSpace($name)) { Write-Host "Usage: template apply <name>" -ForegroundColor Yellow; return }
    if (-not $data.templates -or -not $data.templates[$name]) { Write-Host "Template '$name' not found" -ForegroundColor Red; return }
    # Extremely simple: add a single task with template body as text
    $id = Get-PmcNextTaskId $data
    $data.tasks += @{ id=$id; text=$data.templates[$name]; project='inbox'; priority=0; status='pending'; created=(Get-Date).ToString('yyyy-MM-dd HH:mm:ss') }
    Save-StrictData $data 'template apply'
    Write-Host "Applied template '$name' -> task #$id" -ForegroundColor Green
}
function Get-PmcTemplateList { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    Write-Host "\nTEMPLATES" -ForegroundColor Cyan
    Write-Host "─────────" -ForegroundColor DarkGray
    if (-not $data.templates -or @($data.templates.Keys).Count -eq 0) { Write-Host 'No templates' -ForegroundColor Yellow; return }
    foreach ($k in $data.templates.Keys) { Write-Host ("  - {0}" -f $k) }
}
function Remove-PmcTemplate { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    $name = ($Context.FreeText -join ' ').Trim()
    if (-not $name) { Write-Host "Usage: template remove <name>" -ForegroundColor Yellow; return }
    if (-not $data.templates -or -not $data.templates[$name]) { Write-Host "Template '$name' not found" -ForegroundColor Red; return }
    $data.templates.Remove($name) | Out-Null
    Save-StrictData $data 'template remove'
    Write-Host "Removed template '$name'" -ForegroundColor Green
}

function Add-PmcRecurringTask { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    $text = ($Context.FreeText -join ' ').Trim()
    if (-not $text) { Write-Host "Usage: recurring add <pattern> <body...>" -ForegroundColor Yellow; return }
    $parts = $text -split '\s+', 2
    $pattern = $parts[0]; $body = if ($parts.Count -gt 1) { $parts[1] } else { '' }
    if (-not $data.recurringTemplates) { $data.recurringTemplates = @() }
    $data.recurringTemplates += @{ pattern=$pattern; body=$body; created=(Get-Date).ToString('yyyy-MM-dd HH:mm:ss') }
    Save-StrictData $data 'recurring add'
    Write-Host "Added recurring pattern '$pattern'" -ForegroundColor Green
}
function Get-PmcRecurringTaskList { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    Write-Host "\nRECURRING" -ForegroundColor Cyan
    Write-Host "──────────" -ForegroundColor DarkGray
    if (-not $data.recurringTemplates -or @($data.recurringTemplates).Count -eq 0) { Write-Host 'No recurring templates' -ForegroundColor Yellow; return }
    $i=1
    foreach ($r in $data.recurringTemplates) { Write-Host ("  [{0,2}] {1} :: {2}" -f $i, $r.pattern, ($r.body ?? '')) ; $i++ }
}

# ===== DEPENDENCIES =====
function Add-PmcDependency { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    if ($Context.FreeText.Count -lt 2 -and -not $Context.Args.ContainsKey('ids')) { Show-PmcWarning 'Usage: dep add <id|#> <requiresId|set>'; return }
    $raw = if ($Context.FreeText.Count -gt 0) { $Context.FreeText[0] } else { '' }
    $targetIds=@(); if ($Context.Args.ContainsKey('ids')) { $targetIds=@($Context.Args['ids']) } elseif ($raw -match '^[0-9,\-]+$') { $targetIds=ConvertTo-PmcIdSet $raw }
    if (@($targetIds).Count -eq 0 -and $raw -match '^\d+$') { $n=[int]$raw; $idxMap=Get-PmcLastTaskListMap; if ($idxMap.ContainsKey($n)) { $targetIds=@($idxMap[$n]) } else { $targetIds=@($n) } }
    if (@($targetIds).Count -eq 0) { Show-PmcError 'Invalid id/index for target'; return }
    $reqTok = if ($Context.FreeText.Count -gt 1) { $Context.FreeText[1] } else { '' }
    if (-not $reqTok) { Show-PmcError 'Missing requires id(s)'; return }
    $requires = @(); if ($reqTok -match '^[0-9,\-]+$') { $requires = ConvertTo-PmcIdSet $reqTok }
    if (@($requires).Count -eq 0) { Show-PmcError 'Invalid requires id(s)'; return }
    $added=0
    foreach ($tid in $targetIds) {
        $t = $data.tasks | Where-Object { $_.id -eq $tid } | Select-Object -First 1
        if (-not $t) { continue }
        if (-not $t.PSObject.Properties['requires']) { $t | Add-Member -NotePropertyName requires -NotePropertyValue @() -Force }
        $current = @($t.requires | ForEach-Object { [int]$_ })
        foreach ($rid in $requires) { if ($rid -ne $tid -and -not ($current -contains $rid)) { $current += $rid; $added++ } }
        $t.requires = $current
    }
    if ($added -gt 0) { Save-StrictData $data 'dep add'; Show-PmcSuccess ("Added {0} dependency link(s)" -f $added) } else { Show-PmcWarning 'No dependencies added' }
}

function Remove-PmcDependency { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    if ($Context.FreeText.Count -lt 2 -and -not $Context.Args.ContainsKey('ids')) { Show-PmcWarning 'Usage: dep remove <id|#> <requiresId|set>'; return }
    $raw = if ($Context.FreeText.Count -gt 0) { $Context.FreeText[0] } else { '' }
    $targetIds=@(); if ($Context.Args.ContainsKey('ids')) { $targetIds=@($Context.Args['ids']) } elseif ($raw -match '^[0-9,\-]+$') { $targetIds=ConvertTo-PmcIdSet $raw }
    if (@($targetIds).Count -eq 0 -and $raw -match '^\d+$') { $n=[int]$raw; $idxMap=Get-PmcLastTaskListMap; if ($idxMap.ContainsKey($n)) { $targetIds=@($idxMap[$n]) } else { $targetIds=@($n) } }
    if (@($targetIds).Count -eq 0) { Show-PmcError 'Invalid id/index for target'; return }
    $reqTok = if ($Context.FreeText.Count -gt 1) { $Context.FreeText[1] } else { '' }
    if (-not $reqTok) { Show-PmcError 'Missing requires id(s)'; return }
    $requires = @(); if ($reqTok -match '^[0-9,\-]+$') { $requires = ConvertTo-PmcIdSet $reqTok }
    if (@($requires).Count -eq 0) { Show-PmcError 'Invalid requires id(s)'; return }
    $removed=0
    foreach ($tid in $targetIds) {
        $t = $data.tasks | Where-Object { $_.id -eq $tid } | Select-Object -First 1
        if (-not $t -or -not $t.PSObject.Properties['requires']) { continue }
        $before = @($t.requires)
        $t.requires = @($t.requires | Where-Object { $requires -notcontains [int]$_ })
        $removed += ([Math]::Max(0, $before.Count - $t.requires.Count))
    }
    if ($removed -gt 0) { Save-StrictData $data 'dep remove'; Show-PmcSuccess ("Removed {0} dependency link(s)" -f $removed) } else { Show-PmcWarning 'No dependencies removed' }
}

function Show-PmcDependencies { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    if ($Context.FreeText.Count -lt 1 -and -not $Context.Args.ContainsKey('ids')) { Show-PmcWarning 'Usage: dep show <id|#>'; return }
    $raw = if ($Context.FreeText.Count -gt 0) { $Context.FreeText[0] } else { '' }
    $ids=@(); if ($Context.Args.ContainsKey('ids')) { $ids=@($Context.Args['ids']) } elseif ($raw -match '^[0-9,\-]+$') { $ids=ConvertTo-PmcIdSet $raw }
    if (@($ids).Count -eq 0 -and $raw -match '^\d+$') { $n=[int]$raw; $idxMap=Get-PmcLastTaskListMap; if ($idxMap.ContainsKey($n)) { $ids=@($idxMap[$n]) } else { $ids=@($n) } }
    if (@($ids).Count -eq 0) { Show-PmcError 'Invalid id/index'; return }
    foreach ($tid in $ids) {
        $t = $data.tasks | Where-Object { $_.id -eq $tid } | Select-Object -First 1
        if (-not $t) { Show-PmcWarning ("Task #{0} not found" -f $tid); continue }
        $rows=@()
        $req = if ($t.PSObject.Properties['requires']) { @($t.requires | ForEach-Object { [int]$_ }) } else { @() }
        foreach ($rid in $req) {
            $dep = $data.tasks | Where-Object { $_.id -eq $rid } | Select-Object -First 1
            $rows += @{ id=('#'+$rid); text=($dep.text ?? '(missing)'); status=($dep.status ?? '') }
        }
        Show-PmcTable -Columns @(@{key='id';title='Requires';width=8}, @{key='text';title='Task';width=44}, @{key='status';title='Status';width=8}) -Rows $rows -Title ("BLOCKERS FOR #{0}" -f $tid)
    }
}

function Show-PmcDependencyGraph { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    $edges=@()
    foreach ($t in $data.tasks) {
        if ($t -and $t.PSObject.Properties['requires'] -and $t.requires) {
            foreach ($rid in $t.requires) { $edges += ,@([int]$rid, [int]$t.id) }
        }
    }
    if (@($edges).Count -eq 0) { Show-PmcTip 'No dependencies found'; return }
    Show-PmcHeader -Title 'DEPENDENCY GRAPH (rid -> id)'
    foreach ($e in $edges) { Write-Host ("  #{0} -> #{1}" -f $e[0], $e[1]) }
}

# NOTE: Legacy placeholder stubs were removed below to avoid overriding real implementations.

# Show-PmcAgenda is implemented in Views.ps1

function Show-PmcWeekTasks { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Title' -Text "This Week's Tasks"
    Write-PmcStyled -Style 'Info' -Text "No tasks scheduled for this week."
}

function Show-PmcMonthTasks { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Title' -Text "This Month's Tasks"
    Write-PmcStyled -Style 'Info' -Text "No tasks scheduled for this month."
}

# ALL REMAINING MISSING COMMAND HANDLERS - BASIC STUBS (REMOVED)

function Add-PmcAlias { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Success' -Text "Alias added."
}

function Remove-PmcAlias { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Success' -Text "Alias removed."
}

function Show-PmcDependencies { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Info' -Text "No dependencies found."
}

function Set-PmcFocus { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Success' -Text "Focus set."
}

function Clear-PmcFocus { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Success' -Text "Focus cleared."
}

function Get-PmcFocusStatus { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Info' -Text "No focus set."
}

function Invoke-PmcUndo { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Info' -Text "Nothing to undo."
}

function Invoke-PmcRedo { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Info' -Text "Nothing to redo."
}

function New-PmcBackup { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Success' -Text "Backup created."
}

function Clear-PmcCompletedTasks { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Success' -Text "Completed tasks cleared."
}

# VIEW DOMAIN HANDLERS
function Show-PmcTodayTasks { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Title' -Text "Today's Tasks"
    Write-PmcStyled -Style 'Info' -Text "No tasks due today."
}

function Show-PmcTomorrowTasks { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Title' -Text "Tomorrow's Tasks"
    Write-PmcStyled -Style 'Info' -Text "No tasks due tomorrow."
}

function Show-PmcOverdueTasks { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Title' -Text "Overdue Tasks"
    Write-PmcStyled -Style 'Info' -Text "No overdue tasks."
}

function Show-PmcUpcomingTasks { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Title' -Text "Upcoming Tasks"
    Write-PmcStyled -Style 'Info' -Text "No upcoming tasks."
}

function Show-PmcBlockedTasks { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Title' -Text "Blocked Tasks"
    Write-PmcStyled -Style 'Info' -Text "No blocked tasks."
}

function Show-PmcNoDueDateTasks { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Title' -Text "Tasks Without Due Date"
    Write-PmcStyled -Style 'Info' -Text "No tasks without due dates."
}

function Show-PmcProjectsView { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Title' -Text "Projects Dashboard"
    Write-PmcStyled -Style 'Info' -Text "No projects found."
}

function Show-PmcNextTasks { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Title' -Text "Next Actions"
    Write-PmcStyled -Style 'Info' -Text "No next actions."
}

# ALL REMAINING DOMAINS
function Import-PmcExcelData { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Info' -Text "Excel import not configured."
}

function Show-PmcExcelPreview { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Info' -Text "No Excel data to preview."
}

function Get-PmcLatestExcelFile { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Info' -Text "No Excel files found."
}

function Reset-PmcTheme { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Success' -Text "Theme reset to default."
}

function Edit-PmcTheme { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Info' -Text "Theme editor not implemented."
}

function Get-PmcThemeList { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Info' -Text "Default theme available."
}

function Apply-PmcTheme { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Success' -Text "Theme applied."
}

function Show-PmcThemeInfo { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Info' -Text "Current theme: default"
}

 

function Import-PmcTasks { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Info' -Text "Task import not implemented."
}

function Export-PmcTasks { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Info' -Text "Task export not implemented."
}

function Get-PmcAliasList { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Info' -Text "No aliases defined."
}

function Show-PmcCommands { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Title' -Text "Available Commands"
    Write-PmcStyled -Style 'Info' -Text "Use 'help' for detailed command list."
}

function Show-PmcCommandBrowser { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Info' -Text "Command browser not implemented."
}

function Show-PmcHelpExamples { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Info' -Text "Help examples not implemented."
}

function Show-PmcHelpGuide { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Info' -Text "Help guide not implemented."
}

# SHORTCUT-ONLY FUNCTIONS
function Get-PmcStats { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Title' -Text "Productivity Statistics"
    Write-PmcStyled -Style 'Info' -Text "No statistics available."
}

function Show-PmcBurndown { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Title' -Text "Burndown Chart"
    Write-PmcStyled -Style 'Info' -Text "No burndown data available."
}

function Get-PmcVelocity { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Title' -Text "Velocity Report"
    Write-PmcStyled -Style 'Info' -Text "No velocity data available."
}

function Set-PmcTheme { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Success' -Text "Theme updated."
}

function Show-PmcPreferences { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Info' -Text "Preferences editor not implemented."
}

function Invoke-PmcShortcutNumber { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Info' -Text "Shortcut number function not implemented."
}

function Start-PmcReview { param([PmcCommandContext]$Context)
    Write-PmcStyled -Style 'Info' -Text "Review workflow not implemented."
}

===== END FILE: module/Pmc.Strict/src/Help.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/HelpUI.ps1 =====
# HelpUI.ps1 - Rich Help System with Categorized Command Browser
# Enhanced with t2.ps1's sophisticated help experience

Set-StrictMode -Version Latest

# Help system state - now managed by centralized state
# State initialization moved to State.ps1

# Initialize help state variables at module level
$Script:PmcHelpState = @{
    CurrentCategory = 'All'
    SelectedCommand = 0
    ViewMode = 'Categories'
}

# Search results cache for help
$Script:PmcHelpSearchResults = @()
# Command categories for organized browsing - populated from State.ps1
$commandCategories = @{
    'Task Management' = @(
        @{ Command = 'task add'; Desc = 'Add new task with metadata'; Example = 'task add "Fix bug" @project p1 due:tomorrow' },
        @{ Command = 'task list'; Desc = 'List pending tasks'; Example = 'task list' },
        @{ Command = 'task done'; Desc = 'Complete tasks'; Example = 'task done 1,2,3' },
        @{ Command = 'task update'; Desc = 'Update task properties'; Example = 'task update 1 @newproject p2' },
        @{ Command = 'task delete'; Desc = 'Delete tasks'; Example = 'task delete 1,2' },
        @{ Command = 'task move'; Desc = 'Move task to project'; Example = 'task move 1 @newproject' },
        @{ Command = 'task search'; Desc = 'Search tasks by text'; Example = 'task search bug' },
        @{ Command = 'task edit'; Desc = 'Interactive task editor'; Example = 'task edit 1' }
    )
    'Quick Actions' = @(
        @{ Command = 'add'; Desc = 'Quick add task'; Example = 'add "Fix login bug" @web p1' },
        @{ Command = 'done'; Desc = 'Quick complete tasks'; Example = 'done 1,2,3' },
        @{ Command = 'delete'; Desc = 'Quick delete tasks'; Example = 'delete 1' },
        @{ Command = 'list'; Desc = 'Quick list tasks'; Example = 'list' },
        @{ Command = 'agenda'; Desc = 'Show daily agenda'; Example = 'agenda' },
        @{ Command = 'today'; Desc = 'Tasks due today'; Example = 'today' },
        @{ Command = 'tomorrow'; Desc = 'Tasks due tomorrow'; Example = 'tomorrow' },
        @{ Command = 'overdue'; Desc = 'Overdue tasks'; Example = 'overdue' }
    )
    'Project Management' = @(
        @{ Command = 'project add'; Desc = 'Create new project'; Example = 'project add "Website Redesign"' },
        @{ Command = 'project list'; Desc = 'List all projects'; Example = 'project list' },
        @{ Command = 'project view'; Desc = 'View project details'; Example = 'project view web' },
        @{ Command = 'project stats'; Desc = 'Project statistics'; Example = 'project stats web' },
        @{ Command = 'project archive'; Desc = 'Archive completed project'; Example = 'project archive oldproject' },
        @{ Command = 'projects'; Desc = 'Quick project dashboard'; Example = 'projects' }
    )
    'Time Tracking' = @(
        @{ Command = 'time log'; Desc = 'Log time entry'; Example = 'time log @project 2024-01-15 2.5h "Development work"' },
        @{ Command = 'time list'; Desc = 'List time entries'; Example = 'time list' },
        @{ Command = 'time report'; Desc = 'Time reports'; Example = 'time report week' },
        @{ Command = 'timer start'; Desc = 'Start timer'; Example = 'timer start @project' },
        @{ Command = 'timer stop'; Desc = 'Stop timer'; Example = 'timer stop' },
        @{ Command = 'timer status'; Desc = 'Show timer status'; Example = 'timer status' }
    )
    'Views & Filters' = @(
        @{ Command = 'view today'; Desc = 'Tasks due today'; Example = 'view today' },
        @{ Command = 'view overdue'; Desc = 'Overdue tasks'; Example = 'view overdue' },
        @{ Command = 'view blocked'; Desc = 'Tasks with dependencies'; Example = 'view blocked' },
        @{ Command = 'view projects'; Desc = 'Project dashboard'; Example = 'view projects' },
        @{ Command = 'agenda'; Desc = 'Daily agenda view'; Example = 'agenda' },
        @{ Command = 'week'; Desc = 'Weekly view'; Example = 'week' },
        @{ Command = 'month'; Desc = 'Monthly view'; Example = 'month' }
    )
    'Advanced Features' = @(
        @{ Command = 'dep add'; Desc = 'Add task dependency'; Example = 'dep add 1 depends:2' },
        @{ Command = 'focus set'; Desc = 'Set project context'; Example = 'focus set @project' },
        @{ Command = 'system undo'; Desc = 'Undo last action'; Example = 'undo' },
        @{ Command = 'excel import'; Desc = 'Import Excel T2020 data'; Example = 'excel import' },
        @{ Command = 'stats'; Desc = 'Productivity statistics'; Example = 'stats' },
        @{ Command = 'template save'; Desc = 'Save task template'; Example = 'template save bug-report' }
    )
    'Configuration' = @(
        @{ Command = 'config show'; Desc = 'Show configuration'; Example = 'config show' },
        @{ Command = 'config edit'; Desc = 'Interactive config editor'; Example = 'config edit' },
        @{ Command = 'config icons'; Desc = 'Set icon mode'; Example = 'config icons ascii' },
        @{ Command = 'theme reset'; Desc = 'Reset theme to default'; Example = 'theme reset' }
    )
}

# Initialize Script-level command categories
$Script:PmcCommandCategories = $commandCategories

function Show-PmcSmartHelp {
    <#
    .SYNOPSIS
    Display smart help system with categorized command browser

    .DESCRIPTION
    Rich interactive help system based on t2.ps1's help experience:
    - Categorized command browser
    - Interactive navigation with arrow keys
    - Search and filter capabilities
    - Command examples and usage patterns
    - Context-sensitive help
    #>

    Clear-Host

    # Initialize help state
    if (-not $Script:PmcHelpState) {
        $Script:PmcHelpState = @{
            CurrentCategory = 'All'
            SelectedCommand = 0
            ViewMode = 'Categories'
        }
    } else {
        $Script:PmcHelpState.CurrentCategory = 'All'
        $Script:PmcHelpState.SelectedCommand = 0
        $Script:PmcHelpState.ViewMode = 'Categories'
    }

    # Initialize command categories if not set
    if (-not $Script:PmcCommandCategories) {
        $Script:PmcCommandCategories = $commandCategories
    }

    try {
        $render = {
            Clear-Host
            Show-PmcHelpHeader
            Show-PmcHelpNavigation
            Show-PmcHelpContent
            Write-Host ""
            Write-PmcStyled -Style 'Muted' -Text "  Navigation: ↑/↓ browse, Enter select, B back, C categories, S search, Q quit"
            Write-Host ""
        }

        & $render

        while ($true) {
            try {
                $key = [Console]::ReadKey($true)
            } catch {
                break
            }

            switch ($key.Key) {
                'UpArrow' {
                    if ($Script:PmcHelpState.SelectedCommand -gt 0) { $Script:PmcHelpState.SelectedCommand-- }
                    & $render; continue
                }
                'DownArrow' {
                    $max = 0
                    if ($Script:PmcHelpState.ViewMode -eq 'Categories') {
                        $max = (@($Script:PmcCommandCategories.Keys)).Count - 1
                    } elseif ($Script:PmcHelpState.ViewMode -eq 'Commands' -or $Script:PmcHelpState.ViewMode -eq 'Examples') {
                        $cmds = if ($Script:PmcHelpState.CurrentCategory -eq 'All') { $all=@(); foreach ($v in $Script:PmcCommandCategories.Values) { $all += $v }; $all } else { $Script:PmcCommandCategories[$Script:PmcHelpState.CurrentCategory] }
                        $max = $cmds.Count - 1
                    }
                    if ($Script:PmcHelpState.SelectedCommand -lt $max) { $Script:PmcHelpState.SelectedCommand++ }
                    & $render; continue
                }
                'Enter' {
                    if ($Script:PmcHelpState.ViewMode -eq 'Categories') {
                        $keys = @($Script:PmcCommandCategories.Keys)
                        if ($keys.Count -gt 0) {
                            $idx = [Math]::Max(0, [Math]::Min($Script:PmcHelpState.SelectedCommand, $keys.Count-1))
                            $Script:PmcHelpState.CurrentCategory = $keys[$idx]
                            $Script:PmcHelpState.ViewMode = 'Commands'
                            $Script:PmcHelpState.SelectedCommand = 0
                        }
                    } elseif ($Script:PmcHelpState.ViewMode -eq 'Commands') {
                        $Script:PmcHelpState.ViewMode = 'Examples'
                    } else {
                        $Script:PmcHelpState.ViewMode = 'Categories'
                    }
                    & $render; continue
                }
                'LeftArrow' { $Script:PmcHelpState.ViewMode = 'Categories'; $Script:PmcHelpState.SelectedCommand = 0; & $render; continue }
                'RightArrow' {
                    if ($Script:PmcHelpState.ViewMode -eq 'Categories') {
                        $keys = @($Script:PmcCommandCategories.Keys)
                        if ($keys.Count -gt 0) {
                            $idx = [Math]::Max(0, [Math]::Min($Script:PmcHelpState.SelectedCommand, $keys.Count-1))
                            $Script:PmcHelpState.CurrentCategory = $keys[$idx]
                            $Script:PmcHelpState.ViewMode = 'Commands'
                            $Script:PmcHelpState.SelectedCommand = 0
                            & $render; continue
                        }
                    } elseif ($Script:PmcHelpState.ViewMode -eq 'Commands') {
                        $Script:PmcHelpState.ViewMode = 'Examples'; & $render; continue
                    } else { continue }
                }
                'S' {
                    Show-PmcHelpSearch
                    & $render; continue
                }
                'B' { $Script:PmcHelpState.ViewMode = 'Categories'; $Script:PmcHelpState.SelectedCommand = 0; & $render; continue }
                'C' { $Script:PmcHelpState.ViewMode = 'Categories'; $Script:PmcHelpState.SelectedCommand = 0; & $render; continue }
                'Q' { return }
                'Escape' { return }
                default { continue }
            }
        }

    } catch {
        Write-PmcDebug -Level 1 -Category 'HELP' -Message "Smart help error: $_"
        Write-PmcStyled -Style 'Error' -Text ("Help system error: {0}" -f $_)
    }
}

function Show-PmcHelpHeader {
    Write-Host ""
    $title = "  PMC COMMAND REFERENCE"
    $width = [Math]::Max(70, $title.Length + 4)
    $border = '+' + ('-' * ($width - 2)) + '+'
    Write-PmcStyled -Style 'Border' -Text $border
    Write-PmcStyled -Style 'Title'  -Text ('| ' + $title.PadRight($width - 4) + ' |')
    Write-PmcStyled -Style 'Border' -Text $border
    Write-Host ""
}

function Show-PmcHelpNavigation {
    $categoryCount = $Script:PmcCommandCategories.Count
    $totalCommands = ($Script:PmcCommandCategories.Values | ForEach-Object { $_.Count } | Measure-Object -Sum).Sum

    Write-PmcStyled -Style 'Info' -Text "  📚 Categories: $categoryCount" -NoNewline
    Write-PmcStyled -Style 'Success' -Text "  |  📝 Commands: $totalCommands" -NoNewline
    Write-PmcStyled -Style 'Warning' -Text "  |  🔍 Mode: $($Script:PmcHelpState.ViewMode)"
    Write-Host ""
}

function Show-PmcHelpContent {
    switch ($Script:PmcHelpState.ViewMode) {
        'Categories' { Show-PmcHelpCategories }
        'Commands' { Show-PmcHelpCommands }
        'Examples' { Show-PmcHelpExamples }
        'Search' { Show-PmcHelpSearch }
        default { Show-PmcHelpCategories }
    }
}

function Show-PmcHelpCategories {
    Write-PmcStyled -Style 'Warning' -Text "  Command Categories:"
    Write-PmcStyled -Style 'Border' -Text "  ─────────────────"

    $categoryIndex = 0
    foreach ($category in $Script:PmcCommandCategories.GetEnumerator()) {
        $commandCount = $category.Value.Count
        $isSelected = ($categoryIndex -eq $Script:PmcHelpState.SelectedCommand)

        $prefix = "    "
        if ($isSelected) { $prefix = "  ► " }
        $color = "Gray"
        if ($isSelected) { $color = "White" }
        $bgColor = $null
        if ($isSelected) { $bgColor = "DarkBlue" }

        $displayText = "$($category.Key) ($commandCount commands)"

        $style = 'Body'
        if ($isSelected) { $style = 'Header' }
        Write-PmcStyled -Style $style -Text ("$prefix$displayText")

        $categoryIndex++
    }

    Write-Host ""
    Write-PmcStyled -Style 'Muted' -Text "  💡 Press Enter to view commands in selected category"
}

function Show-PmcHelpCommands {
    if ($Script:PmcHelpState.CurrentCategory -eq '__SEARCH__') {
        $commands = @($Script:PmcHelpSearchResults)
    }
    elseif ($Script:PmcHelpState.CurrentCategory -eq 'All') {
        $commands = @()
        foreach ($category in $Script:PmcCommandCategories.Values) {
            $commands += $category
        }
    } else {
        $commands = $Script:PmcCommandCategories[$Script:PmcHelpState.CurrentCategory]
    }

    if (-not $commands) {
        Write-PmcStyled -Style 'Warning' -Text "  No commands found"
        return
    }

    $categoryText = "All Commands"
    if ($Script:PmcHelpState.CurrentCategory -eq '__SEARCH__') { $categoryText = 'Search Results' }
    elseif ($Script:PmcHelpState.CurrentCategory -ne 'All') { $categoryText = $Script:PmcHelpState.CurrentCategory }
    Write-PmcStyled -Style 'Warning' -Text "  ${categoryText}:"
    Write-PmcStyled -Style 'Border' -Text "  $('─' * ($categoryText.Length + 1))"

    for ($i = 0; $i -lt $commands.Count; $i++) {
        $cmd = $commands[$i]
        $isSelected = ($i -eq $Script:PmcHelpState.SelectedCommand)

        $prefix = "    "
        if ($isSelected) { $prefix = "  ► " }
        $color = "Cyan"
        if ($isSelected) { $color = "White" }
        $bgColor = $null
        if ($isSelected) { $bgColor = "DarkBlue" }

        $displayText = "{0,-18} {1}" -f $cmd.Command, $cmd.Desc

        $style2 = 'Info'
        if ($isSelected) { $style2 = 'Header' }
        Write-PmcStyled -Style $style2 -Text ("$prefix$displayText")
    }

    Write-Host ""
    Write-PmcStyled -Style 'Muted' -Text "  💡 Press Enter to view examples for selected command"
    Write-PmcStyled -Style 'Muted' -Text "  💡 Press B to go back to categories"
}

function Show-PmcHelpSearch {
    try {
        $query = Read-Host "  Search commands (text)"
        if (-not $query) { return }

        $all = @()
        foreach ($category in $Script:PmcCommandCategories.Values) { $all += $category }
        $q = $query.ToLowerInvariant()
        $Script:PmcHelpSearchResults = @(
            $all | Where-Object {
                try {
                    $_.Command.ToLower().Contains($q) -or ($_.Desc -and $_.Desc.ToLower().Contains($q))
                } catch { $false }
            }
        )

        $Script:PmcHelpState.CurrentCategory = '__SEARCH__'
        $Script:PmcHelpState.ViewMode = 'Commands'
        $Script:PmcHelpState.SelectedCommand = 0
    } catch {
        Write-PmcDebug -Level 1 -Category 'HELP' -Message ("Search failed: {0}" -f $_)
    }
}

function Show-PmcHelpExamples {
    if ($Script:PmcHelpState.CurrentCategory -eq 'All') {
        $commands = @()
        foreach ($category in $Script:PmcCommandCategories.Values) {
            $commands += $category
        }
    } else {
        $commands = $Script:PmcCommandCategories[$Script:PmcHelpState.CurrentCategory]
    }

    if (-not $commands -or $Script:PmcHelpState.SelectedCommand -ge $commands.Count) {
        Write-PmcStyled -Style 'Warning' -Text "  Command not found"
        return
    }

    $cmd = $commands[$Script:PmcHelpState.SelectedCommand]

    Write-PmcStyled -Style 'Warning' -Text "  Command: $($cmd.Command)"
    Write-PmcStyled -Style 'Border' -Text ("  $('─' * ("Command: " + $($cmd.Command)).Length)")
    Write-Host ""
    Write-PmcStyled -Style 'Body' -Text "  Description: $($cmd.Desc)"
    Write-Host ""
    Write-PmcStyled -Style 'Success' -Text "  Example:"
    Write-PmcStyled -Style 'Info' -Text ("    {0}" -f $cmd.Example)
    Write-Host ""

    # Add syntax help for the command
    $syntaxHints = Get-PmcCommandSyntax -Command $cmd.Command
    if ($syntaxHints) {
        Write-PmcStyled -Style 'Success' -Text "  Syntax:"
        foreach ($hint in $syntaxHints) {
            Write-PmcStyled -Style 'Info' -Text ("    {0}" -f $hint)
        }
        Write-Host ""
    }

    Write-PmcStyled -Style 'Muted' -Text "  💡 Press B to go back to command list"
}

function Get-PmcCommandSyntax {
    param([string]$Command)

    $syntax = @()

    switch ($Command.ToLower()) {
        'task add' {
            $syntax = @(
                'task add "<description>" [@project] [p1-p3] [due:date] [#tags]',
                '  @project    - Assign to project (e.g., @web, @mobile)',
                '  p1-p3 / !!! - Set priority (p1=high, p3=low)',
                '  due:date    - Set due date (due:today, due:+1w, due:2024-12-25)',
                '  #tags       - Add tags (#bug, #feature, #urgent)'
            )
        }
        'add' {
            $syntax = @(
                'add "<description>" [@project] [p1-p3] [due:date] [#tags]',
                'Quick shortcut for task add with same parameters'
            )
        }
        'time log' {
            $syntax = @(
                'time log @project [date] [hours] ["description"]',
                '  @project     - Project to log time against',
                '  date         - Date in YYYY-MM-DD format (default: today)',
                '  hours        - Hours worked (e.g., 2.5h, 90m)',
                '  description  - Work description in quotes'
            )
        }
        'focus set' {
            $syntax = @(
                'focus set @project',
                'Sets project context for subsequent commands'
            )
        }
        default {
            # Generic syntax for most commands
            if ($Command.Contains(' ')) {
                $parts = $Command -split ' ', 2
                $syntax = @("$($parts[0]) $($parts[1]) [arguments...]")
            } else {
                $syntax = @("$Command [arguments...]")
            }
        }
    }

    return $syntax
}

function Show-PmcHelpAllView {
    <#
    .SYNOPSIS
    Show comprehensive help listing all commands with descriptions

    .DESCRIPTION
    Display all available PMC commands organized by category
    Similar to t2.ps1's 'help all' command
    #>

    Clear-Host
    Show-PmcHelpHeader

    Write-PmcStyled -Style 'Warning' -Text "  All PMC Commands by Category:"
    Write-PmcStyled -Style 'Border' -Text "  --------------------------------"
    Write-Host ""

    foreach ($category in $Script:PmcCommandCategories.GetEnumerator()) {
        Write-PmcStyled -Style 'Info' -Text ("  [$($category.Key)]")
        Write-Host ""

        foreach ($cmd in $category.Value) {
            Write-PmcStyled -Style 'Muted' -Text ("    {0,-20} {1}" -f $cmd.Command, $cmd.Desc)
        }
        Write-Host ""
    }

    # Add metadata syntax reference
    Write-PmcStyled -Style 'Warning' -Text "  Metadata Syntax:"
    Write-Host ""
    Write-PmcStyled -Style 'Muted' -Text "    @project      Assign to project"
    Write-PmcStyled -Style 'Muted' -Text "    p1, p2, p3    Set priority (high to low)"
    Write-PmcStyled -Style 'Muted' -Text "    due:date      Set due date (today, +1w, 2024-12-25)"
    Write-PmcStyled -Style 'Muted' -Text "    #tag          Add tags"
    Write-Host ""

    Write-Host "  💡 Use 'help' for interactive browser" -ForegroundColor DarkGray
    Write-Host ""
}

function Get-PmcCommandByName {
    param([string]$CommandName)

    foreach ($category in $Script:PmcCommandCategories.Values) {
        $found = $category | Where-Object { $_.Command -eq $CommandName }
        if ($found) { return $found }
    }
    return $null
}

function Search-PmcCommands {
    param([string]$SearchTerm)

    $results = @()

    foreach ($categoryEntry in $Script:PmcCommandCategories.GetEnumerator()) {
        foreach ($cmd in $categoryEntry.Value) {
            if ($cmd.Command.Contains($SearchTerm) -or $cmd.Desc.Contains($SearchTerm)) {
                $results += [PSCustomObject]@{
                    Command = $cmd.Command
                    Description = $cmd.Desc
                    Category = $categoryEntry.Key
                    Example = $cmd.Example
                }
            }
        }
    }

    return $results
}

function Show-PmcQuickHelp {
    <#
    .SYNOPSIS
    Show quick reference of most common commands

    .DESCRIPTION
    Display essential commands for new users
    Similar to t2.ps1's basic help output
    #>

    Write-Host ""
    Write-Host "  📚 Quick Command Reference" -ForegroundColor Cyan
    Write-Host "  ─────────────────────────" -ForegroundColor DarkCyan
    Write-Host ""
    Write-Host "  Essential Commands:" -ForegroundColor Yellow
    Write-Host "    add <task>           Add a new task" -ForegroundColor White
    Write-Host "    done <ids>           Complete tasks" -ForegroundColor White
    Write-Host "    list                 Show all tasks" -ForegroundColor White
    Write-Host "    agenda               Show daily agenda" -ForegroundColor White
    Write-Host "    projects             Show project dashboard" -ForegroundColor White
    Write-Host ""
    Write-Host "  Metadata Examples:" -ForegroundColor Yellow
    Write-Host "    add \"Fix bug\" @web p1 due:tomorrow #urgent" -ForegroundColor Cyan
    Write-Host "    time log @project 2h \"Development work\"" -ForegroundColor Cyan
    Write-Host ""
    Write-PmcStyled -Style 'Muted' -Text "  💡 Use 'help all' for complete command list"
    Write-PmcStyled -Style 'Muted' -Text "  💡 Use 'help' for interactive command browser"
    Write-Host ""
}

# Command implementations that integrate with PMC's command system
function Show-PmcHelpAll {
    [CmdletBinding()]
    param([PmcCommandContext]$Context)
    Show-PmcHelpAllView
}

function Show-PmcCommandList {
    [CmdletBinding()]
    param([PmcCommandContext]$Context)
    Show-PmcHelpAllView
}

===== END FILE: module/Pmc.Strict/src/HelpUI.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/ImportExport.ps1 =====
# Generic import/export of tasks (CSV/JSON)

function Export-PmcTasks {
    param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    $outCsv = $null; $outJson = $null
    # Parse tokens like out:foo.csv json:bar.json
    foreach ($t in $Context.FreeText) {
        if ($t -match '^(?i)out:(.+)$') { $outCsv = $matches[1] }
        elseif ($t -match '^(?i)csv:(.+)$') { $outCsv = $matches[1] }
        elseif ($t -match '^(?i)json:(.+)$') { $outJson = $matches[1] }
    }
    if (-not $outCsv -and -not $outJson) { $outCsv = 'exports/tasks.csv' }

    $tasks = @($data.tasks)
    if ($outCsv) {
        try {
            $path = Get-PmcSafePath $outCsv
            if (-not (Test-Path (Split-Path $path -Parent))) { New-Item -ItemType Directory -Path (Split-Path $path -Parent) -Force | Out-Null }
            $rows = @()
            foreach ($t in $tasks) {
                $rows += [pscustomobject]@{
                    ID = $t.id
                    Text = $t.text
                    Project = (if ($t.project) { $t.project } else { 'inbox' })
                    Priority = (if ($t.priority) { $t.priority } else { 0 })
                    Due = (if ($t.due) { $t.due } else { '' })
                    Status = (if ($t.status) { $t.status } else { 'pending' })
                    Created = (if ($t.created) { $t.created } else { '' })
                }
            }
            $rows | Export-Csv -Path $path -NoTypeInformation -Encoding UTF8
            Show-PmcSuccess ("Exported CSV: {0}" -f $path)
        } catch { Show-PmcError ("CSV export failed: {0}" -f $_) }
    }
    if ($outJson) {
        try {
            $path = Get-PmcSafePath $outJson
            if (-not (Test-Path (Split-Path $path -Parent))) { New-Item -ItemType Directory -Path (Split-Path $path -Parent) -Force | Out-Null }
            $tasks | ConvertTo-Json -Depth 8 | Set-Content -Path $path -Encoding UTF8
            Show-PmcSuccess ("Exported JSON: {0}" -f $path)
        } catch { Show-PmcError ("JSON export failed: {0}" -f $_) }
    }
}

function Import-PmcTasks {
    param([PmcCommandContext]$Context)
    $pathArg = ($Context.FreeText -join ' ').Trim()
    if ([string]::IsNullOrWhiteSpace($pathArg)) { Write-Host "Usage: import tasks <path.csv|path.json>" -ForegroundColor Yellow; return }
    $path = Get-PmcSafePath $pathArg
    if (-not (Test-Path $path)) { Show-PmcError ("File not found: {0}" -f $path); return }
    $data = Get-PmcDataAlias
    $added = 0
    if ($path -match '\.json$') {
        try { $items = Get-Content $path -Raw | ConvertFrom-Json } catch { Show-PmcError "Invalid JSON"; return }
        foreach ($r in $items) {
            $text = if ($r.PSObject.Properties['text'] -and $r.text) { $r.text } elseif ($r.PSObject.Properties['Text'] -and $r.Text) { $r.Text } else { $null }
            if (-not $text) { continue }
            $id = Get-PmcNextTaskId $data
            $projVal = if ($r.PSObject.Properties['project'] -and $r.project) { $r.project } elseif ($r.PSObject.Properties['Project'] -and $r.Project) { $r.Project } else { 'inbox' }
            $priVal = if ($r.PSObject.Properties['priority'] -and $r.priority) { $r.priority } elseif ($r.PSObject.Properties['Priority'] -and $r.Priority) { $r.Priority } else { 0 }
            $t = @{ id=$id; text=$text; project=$projVal; priority=$priVal; status='pending'; created=(Get-Date).ToString('yyyy-MM-dd HH:mm:ss') }
            if (($r.PSObject.Properties['due'] -and $r.due) -or ($r.PSObject.Properties['Due'] -and $r.Due)) { try { $t.due = ([datetime]((if ($r.due) { $r.due } else { $r.Due }))).ToString('yyyy-MM-dd') } catch {
                # Date parsing failed - skip due date assignment
            } }
            $data.tasks += $t; $added++
        }
        Save-StrictData $data 'import tasks'
        Show-PmcSuccess ("Imported {0} task(s) from JSON" -f $added)
        return
    }
    if ($path -match '\.csv$') {
        $rows = @(); try { $rows = Import-Csv -Path $path } catch { Show-PmcError ("Failed to read CSV: {0}" -f $_); return }
        foreach ($r in $rows) {
            $text = if ($r.PSObject.Properties['Text'] -and $r.Text) { $r.Text } elseif ($r.PSObject.Properties['Task'] -and $r.Task) { $r.Task } else { $null }
            if (-not $text) { continue }
            $proj = if ($r.PSObject.Properties['Project'] -and $r.Project) { $r.Project } else { 'inbox' }
            $pri = try { [int]$r.Priority } catch { 0 }
            $due = $null; try { if ($r.Due) { $due = [datetime]$r.Due } } catch {
                # Date parsing failed - due will remain null
            }
            $id = Get-PmcNextTaskId $data
            $task = @{ id=$id; text=$text; project=$proj; priority=$pri; status='pending'; created=(Get-Date).ToString('yyyy-MM-dd HH:mm:ss') }
            if ($due) { $task.due = $due.ToString('yyyy-MM-dd') }
            $data.tasks += $task; $added++
        }
        Save-StrictData $data 'import tasks'
        Show-PmcSuccess ("Imported {0} task(s) from CSV" -f $added)
        return
    }
    Show-PmcWarning 'Unsupported file type (use .csv or .json)'
}

===== END FILE: module/Pmc.Strict/src/ImportExport.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/Interactive.ps1 =====
# t2.ps1-Style Interactive Engine for PMC
# Complete implementation with inline cycling, history, undo/redo, and comprehensive instrumentation
# IMPORTANT: Completions MUST be plain strings. PSObjects/PSCustomObject and
# PSReadLine-style completion objects are not supported by this custom Console.ReadKey
# engine. Using objects breaks input flow and causes type/serialization errors.

Set-StrictMode -Version Latest

# Completions are simple strings throughout the system
# Classes remain defined in the main .psm1 file if needed elsewhere

# Centralized interactive state accessors (state-only)
function Pmc-GetEditor { $e = Get-PmcState -Section 'Interactive' -Key 'Editor'; if ($null -eq $e) { $e = [PmcEditorState]::new(); Set-PmcState -Section 'Interactive' -Key 'Editor' -Value $e }; return $e }
function Pmc-SetEditor($e) { Set-PmcState -Section 'Interactive' -Key 'Editor' -Value $e }
function Pmc-GetCache { $c = Get-PmcState -Section 'Interactive' -Key 'CompletionCache'; if ($null -eq $c) { $c=@{}; Set-PmcState -Section 'Interactive' -Key 'CompletionCache' -Value $c }; return $c }
function Pmc-SetCache($c) { Set-PmcState -Section 'Interactive' -Key 'CompletionCache' -Value $c }
function Pmc-ClearCache { $c = Pmc-GetCache; $c.Clear() | Out-Null; Pmc-SetCache $c }
function Pmc-GetGhost { $g = Get-PmcState -Section 'Interactive' -Key 'GhostTextEnabled'; if ($null -eq $g) { $g=$true; Set-PmcState -Section 'Interactive' -Key 'GhostTextEnabled' -Value $g }; return [bool]$g }
function Pmc-SetGhost([bool]$g) { Set-PmcState -Section 'Interactive' -Key 'GhostTextEnabled' -Value $g }
function Pmc-GetInfoMap { $m = Get-PmcState -Section 'Interactive' -Key 'CompletionInfoMap'; if ($null -eq $m) { $m=@{}; Set-PmcState -Section 'Interactive' -Key 'CompletionInfoMap' -Value $m }; return $m }
function Pmc-SetInfoMap($m) { Set-PmcState -Section 'Interactive' -Key 'CompletionInfoMap' -Value $m }

# Fuzzy matching utilities (subsequence with ranking)
function Invoke-PmcFuzzyFilter {
    param(
        [string[]] $Items,
        [string] $Query
    )
    if (-not $Items) { return @() }
    if ([string]::IsNullOrWhiteSpace($Query)) { return ,@($Items) }

    $q = $Query.ToLowerInvariant()
    $scored = @()
    foreach ($it in $Items) {
        $s = [string]$it
        $t = $s.ToLowerInvariant()
        $rank = $null
        if ($t.StartsWith($q)) { $rank = 0 }
        elseif ($t.Contains($q)) { $rank = 1 }
        elseif (Test-PmcSubsequence -Haystack $t -Needle $q) { $rank = 2 }
        if ($rank -ne $null) { $scored += [pscustomobject]@{ Item=$s; Rank=$rank } }
    }
    $ordered = $scored | Sort-Object Rank, @{Expression={$_.Item.Length}; Ascending=$true}, Item
    return @($ordered | Select-Object -ExpandProperty Item)
}

function Test-PmcSubsequence {
    param([string] $Haystack, [string] $Needle)
    if ([string]::IsNullOrEmpty($Needle)) { return $true }
    $i = 0; $j = 0
    while ($i -lt $Haystack.Length -and $j -lt $Needle.Length) {
        if ($Haystack[$i] -eq $Needle[$j]) { $j++ }
        $i++
    }
    return ($j -eq $Needle.Length)
}

function Initialize-PmcCompletionInfoMap {
    $map = @{}

    # Domain descriptions
    $map['task']      = @{ Description = 'Task management';       Category = 'Domain' }
    $map['project']   = @{ Description = 'Project management';     Category = 'Domain' }
    $map['time']      = @{ Description = 'Time logging/reporting'; Category = 'Domain' }
    $map['timer']     = @{ Description = 'Timers';                 Category = 'Domain' }
    $map['view']      = @{ Description = 'Predefined views';       Category = 'Domain' }
    $map['focus']     = @{ Description = 'Focus mode';             Category = 'Domain' }
    $map['system']    = @{ Description = 'System ops';             Category = 'Domain' }
    $map['config']    = @{ Description = 'Configuration';          Category = 'Domain' }
    $map['excel']     = @{ Description = 'Excel I/O';              Category = 'Domain' }
    $map['theme']     = @{ Description = 'Theme settings';         Category = 'Domain' }
    $map['activity']  = @{ Description = 'Activity log';           Category = 'Domain' }
    $map['template']  = @{ Description = 'Templates';              Category = 'Domain' }
    $map['recurring'] = @{ Description = 'Recurring rules';        Category = 'Domain' }
    $map['alias']     = @{ Description = 'Aliases';                Category = 'Domain' }
    $map['dep']       = @{ Description = 'Dependencies';           Category = 'Domain' }
    $map['import']    = @{ Description = 'Import data';            Category = 'Domain' }
    $map['export']    = @{ Description = 'Export data';            Category = 'Domain' }
    $map['show']      = @{ Description = 'Show info';              Category = 'Domain' }
    $map['interactive']= @{ Description = 'Interactive mode';      Category = 'Domain' }
    $map['help']      = @{ Description = 'Help';                   Category = 'Domain' }

    # Domain:Action descriptions (keyed as "domain:action")
    $pairs = @(
        'task:add=Add new task','task:list=List tasks','task:done=Mark task done','task:edit=Edit task','task:delete=Delete task','task:view=View task','task:search=Search tasks',
        'project:add=Add project','project:list=List projects','project:view=View project','project:update=Update project','project:rename=Rename project','project:delete=Delete project','project:archive=Archive project','project:set-fields=Set custom fields','project:show-fields=Show custom fields','project:stats=Project statistics','project:info=Project info','project:recent=Recent projects',
        'time:log=Log time','time:list=List entries','time:report=Report','time:edit=Edit entries',
        'timer:start=Start timer','timer:stop=Stop timer','timer:status=Timer status',
        'view:today=Today view','view:tomorrow=Tomorrow view','view:overdue=Overdue tasks','view:upcoming=Upcoming','view:blocked=Blocked','view:noduedate=No due date','view:projects=Projects overview','view:next=Next actions',
        'focus:set=Set focus','focus:clear=Clear focus','focus:status=Focus status',
        'system:undo=Undo last action','system:redo=Redo last action','system:backup=Create backup','system:clean=Clean data',
        'config:show=Show config','config:edit=Edit config','config:set=Set config','config:icons=Icon config',
        'excel:import=Import from Excel','excel:view=View excel output','excel:export=Export to Excel',
        'theme:set=Set theme','theme:list=List themes','theme:create=Create theme','theme:edit=Edit theme',
        'activity:log=Log activity','activity:list=List activity','activity:report=Activity report',
        'template:create=Create template','template:list=List templates','template:apply=Apply template','template:edit=Edit template','template:delete=Delete template',
        'recurring:add=Add recurring rule','recurring:list=List recurring rules','recurring:edit=Edit recurring rule','recurring:delete=Delete recurring rule','recurring:process=Process recurring',
        'alias:add=Add alias','alias:list=List aliases','alias:edit=Edit alias','alias:delete=Delete alias',
        'dep:add=Add dependency','dep:list=List dependencies','dep:remove=Remove dependency','dep:check=Check dependencies',
        'import:excel=Import from Excel','import:csv=Import from CSV','import:json=Import from JSON','import:outlook=Import from Outlook',
        'export:excel=Export to Excel','export:csv=Export to CSV','export:json=Export to JSON','export:ical=Export to iCal',
        'show:status=Show status','show:config=Show config','show:help=Show help','show:version=Show version',
        'interactive:enable=Enable interactive','interactive:disable=Disable interactive','interactive:status=Interactive status',
        'help:commands=Help commands','help:examples=Help examples','help:guide=Help guide','help:quick=Quick help'
    )
    foreach ($pair in $pairs) {
        $kv = $pair.Split('=')
        $map[$kv[0]] = @{ Description = $kv[1]; Category = 'Action' }
    }

    # Common argument suggestions
    $map['due:today'] = @{ Description = 'Due today';    Category = 'Argument' }
    $map['due:tomorrow'] = @{ Description = 'Due tomorrow'; Category = 'Argument' }
    $map['due:friday'] = @{ Description = 'Due Friday';  Category = 'Argument' }
    $map['due:+1w'] = @{ Description = 'Due +1 week';    Category = 'Argument' }
    $map['due:+1m'] = @{ Description = 'Due +1 month';   Category = 'Argument' }
    $map['p1'] = @{ Description = 'Priority 1'; Category = 'Argument' }
    $map['p2'] = @{ Description = 'Priority 2'; Category = 'Argument' }
    $map['p3'] = @{ Description = 'Priority 3'; Category = 'Argument' }
    $map['#urgent'] = @{ Description = 'Urgent tag'; Category = 'Argument' }
    $map['#bug']    = @{ Description = 'Bug tag'; Category = 'Argument' }
    $map['#feature']= @{ Description = 'Feature tag'; Category = 'Argument' }
    $map['#review'] = @{ Description = 'Review tag'; Category = 'Argument' }

    Pmc-SetInfoMap $map
}

function Get-PmcCompletionInfo {
    param(
        [string] $Domain,
        [string] $Action,
        [string] $Text
    )
    if ($Action) {
        $d = if ($Domain) { $Domain.ToLower() } else { $null }
        $a = $Action.ToLower()
        $key = "${d}:${a}"
        return (Pmc-GetInfoMap)[$key]
    }
    if ($Text) { return (Pmc-GetInfoMap)[$Text.ToLower()] }
    return $null
}

# High-level renderer that computes transient help text before delegating to Render-Line
function Render-Interactive {
    param(
        [string] $Buffer,
        [int] $CursorPos,
        [int] $IndicatorIndex = 0,
        [int] $IndicatorCount = 0,
        [bool] $InCompletion = $false
    )

    $helpText = $null
    if (-not $InCompletion) {
        try {
            $ctx = Parse-CompletionContext -Buffer $Buffer -CursorPos $CursorPos
            if ($ctx.Mode -eq [PmcCompletionMode]::Domain) {
                if ($ctx.CurrentToken) {
                    $info = Get-PmcCompletionInfo -Text $ctx.CurrentToken
                    if ($info) { $helpText = $info.Description }
                }
            } elseif ($ctx.Mode -eq [PmcCompletionMode]::Action) {
                if ($ctx.Tokens.Count -gt 0 -and $ctx.CurrentToken) {
                    $info = Get-PmcCompletionInfo -Domain $ctx.Tokens[0] -Action $ctx.CurrentToken
                    $summary = Pmc-FormatSchemaSummary -Domain $ctx.Tokens[0] -Action $ctx.CurrentToken
                    if ($summary) { $helpText = $summary }
                    elseif ($info) { $helpText = $info.Description }
                }
            } elseif ($ctx.Mode -eq [PmcCompletionMode]::Arguments) {
                $dom = if ($ctx.Tokens.Count -gt 0) { $ctx.Tokens[0] } else { $null }
                $act = if ($ctx.Tokens.Count -gt 1) { $ctx.Tokens[1] } else { $null }
                if ($dom -and $act) {
                    $summary = Pmc-FormatSchemaSummary -Domain $dom -Action $act
                    if ($summary) { $helpText = $summary }
                } elseif ($ctx.CurrentToken) {
                    $info = Get-PmcCompletionInfo -Text $ctx.CurrentToken
                    if ($info) { $helpText = $info.Description }
                }
            }
        } catch {}
    }

    Render-Line -Buffer $Buffer -CursorPos $CursorPos -IndicatorIndex $IndicatorIndex -IndicatorCount $IndicatorCount -InCompletion $InCompletion -HelpText $helpText
}

# Build a compact argument summary from schema for inline guidance
function Pmc-FormatSchemaSummary {
    param([string]$Domain,[string]$Action)
    if (-not $Domain -or -not $Action) { return $null }
    try {
        $schema = Get-PmcSchema -Domain $Domain -Action $Action
        if (-not $schema -or @($schema).Count -eq 0) { return $null }
        $parts = @()
        foreach ($def in $schema) {
            $name = [string]$def['Name']
            $type = [string]$def['Type']
            $prefix = [string]$def['Prefix']
            $req = [bool]$def['Required']
            $allowsMulti = [bool]$def['AllowsMultiple']

            $token = $null
            switch ($type) {
                'ProjectName' { $token = '@project' }
                'Priority'    { $token = 'p1|p2|p3' }
                'DateString'  { $token = 'due:YYYY-MM-DD' }
                'TagName'     { $token = if ($allowsMulti) { '#tag...' } else { '#tag' } }
                'TaskID'      { $token = '<id>' }
                'Duration'    { $token = '<duration>' }
                'DateRange'   { $token = '<range>' }
                default {
                    if ($prefix) { $token = "$prefix$name" }
                    elseif ($name -match '^(?i)text$') { $token = '<text>' }
                    else { $token = "<$name>" }
                }
            }

            if (-not $req) { $token = "[$token]" }
            $parts += $token
        }
        if ($parts.Count -gt 0) { return ('Args: ' + ($parts -join ' ')) }
    } catch {}
    return $null
}

# Helper function removed - we now use simple strings instead of PSCustomObjects
# This eliminates the dual completion path issue where PSCustomObjects were being created

# Debug helper: log state transitions at Debug2
function Write-StateChange {
    param(
        [string] $KeyName,
        [hashtable] $BeforeCtx,
        [bool] $BeforeInCompletion
    )
    try {
        $ed = Pmc-GetEditor
        $afterCtx = Parse-CompletionContext -Buffer $ed.Buffer -CursorPos $ed.CursorPos
        $afterIn = $ed.InCompletion
        Write-PmcDebug -Level 2 -Category 'STATE' -Message "Key=$KeyName InCompletion: $BeforeInCompletion->$afterIn Mode: $($BeforeCtx.Mode)->$($afterCtx.Mode) BufferLen=$($ed.Buffer.Length) Cursor=$($ed.CursorPos)"
    } catch {
        # Ghost text computation failed - return empty string
    }
}

# Compute ghost hint text based on current context (pure)
function Compute-GhostText {
    param(
        [string] $Buffer,
        [hashtable] $Context
    )

    if (-not (Pmc-GetGhost)) { return "" }

    try {
        $ghost = ""
        $hasTrailingSpace = $Buffer.EndsWith(' ')

        if ($Context.Mode -eq [PmcCompletionMode]::Domain) {
            # Show domain hints when starting or when current token is incomplete
            if ([string]::IsNullOrEmpty($Context.CurrentToken) -or -not $hasTrailingSpace) {
                $ghost = " task|project|time..."
            }
        } elseif ($Context.Mode -eq [PmcCompletionMode]::Action) {
            # Show action hints when we have a domain and are ready for action
            if ($Context.Tokens.Count -ge 1 -and $hasTrailingSpace) {
                $domain = $Context.Tokens[0].ToLower()
                switch ($domain) {
                    'task' { $ghost = " add|list|done|edit" }
                    'project' { $ghost = " add|list|view|edit" }
                    'time' { $ghost = " log|report|list" }
                    'timer' { $ghost = " start|stop|status" }
                    'view' { $ghost = " today|tomorrow|overdue" }
                    'focus' { $ghost = " set|clear|status" }
                    'system' { $ghost = " undo|redo|backup" }
                    'config' { $ghost = " show|edit|set" }
                    default { $ghost = " help" }
                }
            }
        } elseif ($Context.Mode -eq [PmcCompletionMode]::Arguments) {
            # Show argument hints when we have domain and action
            if ($Context.Tokens.Count -ge 2 -and $hasTrailingSpace) {
                $ghost = " @project due:date p1-3 #tags"
            }
        }

        Write-PmcDebug -Level 3 -Category 'GHOST' -Message "Ghost computation: Mode=$($Context.Mode), Tokens=[$($Context.Tokens -join ', ')], HasTrailingSpace=$hasTrailingSpace, Ghost='$ghost'"
        return ($ghost ?? "")
    } catch {
        Write-PmcDebug -Level 1 -Category 'GHOST' -Message "Ghost computation error: $_"
        return ""
    }
}

# Get terminal dimensions for TUI layout
function Get-TerminalSize {
    try {
        return @{
            Width = [Console]::WindowWidth
            Height = [Console]::WindowHeight
        }
    } catch {
        # Fallback dimensions if console access fails
        return @{ Width = 80; Height = 24 }
    }
}

# Clear screen and position cursor for command output
function Clear-CommandOutput {
    [Console]::Write("`e[2J`e[H")  # Clear screen + move to top
    [Console]::Out.Flush()
}

# Simplified inline renderer for compatibility
function Render-Line {
    param(
        [string] $Buffer,
        [int] $CursorPos,
        [int] $IndicatorIndex = 0,
        [int] $IndicatorCount = 0,
        [bool] $InCompletion = $false,
        [string] $HelpText = $null
    )

    $prompt = "pmc> "
    $promptLen = $prompt.Length

    # Compute indicator text
    $indicatorText = ''
    if ($IndicatorCount -gt 1) {
        $displayIndex = [Math]::Max(1, $IndicatorIndex)
        $indicatorText = " ($displayIndex/$IndicatorCount)"
    }

    # Two-line HUD: input at last-1 row, help at last row
    $term = Get-TerminalSize
    $inputRow = [Math]::Max(1, $term.Height - 1)
    $helpRow = [Math]::Max(1, $term.Height)

    # Compute visible input line (truncate to width)
    $lineCore = "$prompt$Buffer$indicatorText"
    if ($lineCore.Length -gt $term.Width) {
        # Prefer to keep cursor region visible; simple right-trim for now
        $lineCore = $lineCore.Substring(0, $term.Width)
    }

    # Compute help line (truncate to width)
    $helpOut = ''
    if ($HelpText -and $HelpText.Trim().Length -gt 0) {
        $helpOut = $HelpText.Trim()
        if ($helpOut.Length -gt $term.Width) { $helpOut = $helpOut.Substring(0, $term.Width) }
    }

    # Clear the two bottom lines and render
    [Console]::Write("`e[${inputRow};1H`e[2K")
    [Console]::Write($lineCore)
    [Console]::Write("`e[${helpRow};1H`e[2K")
    if ($helpOut) { [Console]::Write($helpOut) }
    [Console]::Out.Flush()

    # Restore cursor to input line/column
    # Place caret at the insertion point (after the last typed character)
    $targetCol = [Math]::Min($term.Width, $promptLen + $CursorPos + 1)
    if ($targetCol -lt 1) { $targetCol = 1 }
    [Console]::Write("`e[${inputRow};${targetCol}H")
    [Console]::Out.Flush()

    Write-PmcDebug -Level 2 -Category 'RENDER' -Message "Bottom HUD render: bufferLen=$($Buffer.Length), cursorPos=$CursorPos, width=$($term.Width)"
}

# No conversion factory: completions are plain strings by design

# Tokenization: compute current token boundaries for replacement
function Get-TokenBoundaries {
    param(
        [string] $Buffer,
        [int] $CursorPos
    )

    if ([string]::IsNullOrEmpty($Buffer)) {
        return @{ Start = 0; End = 0; Token = "" }
    }

    # Find token boundaries around cursor
    $start = $CursorPos
    $end = $CursorPos

    # Move start backward to beginning of current token
    while ($start -gt 0 -and $Buffer[$start - 1] -ne ' ') {
        $start--
    }

    # Move end forward to end of current token
    while ($end -lt $Buffer.Length -and $Buffer[$end] -ne ' ') {
        $end++
    }

    $token = if ($start -lt $Buffer.Length -and $end -gt $start) {
        $Buffer.Substring($start, $end - $start)
    } else {
        ""
    }

    return @{
        Start = $start
        End = $end
        Token = $token
    }
}

# Parse buffer to determine completion mode and context
function Parse-CompletionContext {
    param(
        [string] $Buffer,
        [int] $CursorPos
    )

    # Use the same tokenizer as the rest of the system for consistency
    $tokens = ConvertTo-PmcTokens $Buffer
    $tokenInfo = Get-TokenBoundaries -Buffer $Buffer -CursorPos $CursorPos

    $mode = [PmcCompletionMode]::Domain
    $currentToken = $tokenInfo.Token

    # Determine completion mode based on token position and trailing space
    $hasTrailingSpace = $Buffer.EndsWith(' ')

    if ($tokens.Count -eq 0) {
        $mode = [PmcCompletionMode]::Domain
    } elseif ($tokens.Count -eq 1 -and -not $hasTrailingSpace) {
        # Still typing first token (domain)
        $mode = [PmcCompletionMode]::Domain
    } elseif ($tokens.Count -eq 1 -and $hasTrailingSpace) {
        # First token complete, ready for action
        $mode = [PmcCompletionMode]::Action
    } elseif ($tokens.Count -eq 2 -and -not $hasTrailingSpace) {
        # Still typing second token (action)
        $mode = [PmcCompletionMode]::Action
    } elseif ($tokens.Count -eq 2 -and $hasTrailingSpace) {
        # Domain and action complete, ready for arguments
        $mode = [PmcCompletionMode]::Arguments
    } elseif ($tokens.Count -ge 3) {
        # In arguments phase
        $mode = [PmcCompletionMode]::Arguments
    } else {
        $mode = [PmcCompletionMode]::FreeText
    }

    Write-PmcDebug -Level 3 -Category 'COMPLETION' -Message "Parsed context: Tokens=[$($tokens -join ', ')], Mode=$mode (tokenCount=$($tokens.Count), hasTrailingSpace=$hasTrailingSpace)"

    return @{
        Mode = $mode
        CurrentToken = $currentToken
        TokenStart = $tokenInfo.Start
        TokenEnd = $tokenInfo.End
        Tokens = $tokens
    }
}

# Domain completion provider
function Get-PmcDomainCompletions {
    param(
        [string] $Filter = ""
    )

    Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message "Getting domain completions for filter='$Filter'"

    try {
        # Simple string array - no objects, no type conversion issues
        $domains = @(
            "task", "project", "time", "timer", "view", "focus",
            "system", "config", "excel", "theme", "activity",
            "template", "recurring", "alias", "dep", "import",
            "export", "show", "interactive", "help"
        )

        # Add shortcut commands from the shortcut map
        $shortcuts = @()
        if ($Script:PmcShortcutMap -and $Script:PmcShortcutMap.Keys) {
            $shortcuts = @($Script:PmcShortcutMap.Keys)
        }

        # Combine domains and shortcuts
        $allCompletions = $domains + $shortcuts

        $result = Invoke-PmcFuzzyFilter -Items $allCompletions -Query $Filter
        Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message "Domain completions: found $(@($result).Count) items"
        return ,@($result)

    } catch {
        Write-PmcDebug -Level 1 -Category 'COMPLETION' -Message "Domain completion error: $_"
        return @()
    }
}

# Action completion provider
function Get-PmcActionCompletions {
    param([string] $Domain = "", [string] $Filter = "")

    Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message "Getting action completions for domain='$Domain', filter='$Filter'"

    try {
        $actions = @()

        switch ($Domain.ToLower()) {
            'task' {
                $actions = @("add", "list", "done", "edit", "delete", "view", "search")
            }
            'project' {
                $actions = @("add", "list", "view", "update", "rename", "delete", "archive", "set-fields", "show-fields", "stats", "info", "recent")
            }
            'time' {
                $actions = @("log", "list", "report", "edit")
            }
            'timer' {
                $actions = @("start", "stop", "status")
            }
            'view' {
                $actions = @("today", "tomorrow", "overdue", "upcoming", "blocked", "noduedate", "projects", "next")
            }
            'focus' {
                $actions = @("set", "clear", "status")
            }
            'system' {
                $actions = @("undo", "redo", "backup", "clean")
            }
            'config' {
                $actions = @("show", "edit", "set", "icons")
            }
            'excel' {
                $actions = @("import", "view", "export")
            }
            'theme' {
                $actions = @("set", "list", "create", "edit")
            }
            'activity' {
                $actions = @("log", "list", "report")
            }
            'template' {
                $actions = @("create", "list", "apply", "edit", "delete")
            }
            'recurring' {
                $actions = @("add", "list", "edit", "delete", "process")
            }
            'alias' {
                $actions = @("add", "list", "edit", "delete")
            }
            'dep' {
                $actions = @("add", "list", "remove", "check")
            }
            'import' {
                $actions = @("excel", "csv", "json", "outlook")
            }
            'export' {
                $actions = @("excel", "csv", "json", "ical")
            }
            'show' {
                $actions = @("status", "config", "help", "version")
            }
            'interactive' {
                $actions = @("enable", "disable", "status")
            }
            'help' {
                $actions = @("commands", "examples", "guide", "quick")
            }
            default {
                return @()
            }
        }

        $result = Invoke-PmcFuzzyFilter -Items $actions -Query $Filter
        Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message "Action completions: found $(@($result).Count) items"
        return ,@($result)

    } catch {
        Write-PmcDebug -Level 1 -Category 'COMPLETION' -Message "Error in Get-PmcActionCompletions: $_"
        return @()
    }
}

# Argument completion provider (projects, dates, priorities, etc.)
function Get-PmcArgumentCompletions {
    param(
        [string] $Domain,
        [string] $Action,
        [string] $Filter = ""
    )

    Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message "Getting argument completions for domain='$Domain' action='$Action' filter='$Filter'"

    try {
        $completions = @()

        # Project completions (@project)
        if ($Filter.StartsWith('@') -or [string]::IsNullOrEmpty($Filter)) {
            try {
                $data = Get-PmcData
                $projects = @($data.projects)
                $all = @()
                foreach ($project in $projects) { $all += ("@" + [string]$project.name) }
                $needle = if ($Filter -like '@*') { $Filter } else { '@' + $Filter }
                $filtered = Invoke-PmcFuzzyFilter -Items $all -Query $needle
                $completions += $filtered
            } catch {
                Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message "Project loading error: $_"
            }
        }

        # Date completions (due:)
        if ($Filter.StartsWith('due:') -or [string]::IsNullOrWhiteSpace($Filter)) {
            $dates = @("due:today", "due:tomorrow", "due:friday", "due:+1w", "due:+1m")
            $completions += (Invoke-PmcFuzzyFilter -Items $dates -Query $Filter)
        }

        # Priority completions
        if ($Filter.StartsWith('p') -or [string]::IsNullOrWhiteSpace($Filter)) {
            $priorities = @("p1", "p2", "p3")
            $completions += (Invoke-PmcFuzzyFilter -Items $priorities -Query $Filter)
        }

        # '#' handling: for time log, '#' means ID1 time codes (2-5 digits).
        # Otherwise, '#' is tag completion.
        if ($Filter.StartsWith('#') -or [string]::IsNullOrWhiteSpace($Filter)) {
            if (($Domain -eq 'time') -and ($Action -eq 'log')) {
                try {
                    $data = Get-PmcDataAlias
                    $codes = @()
                    foreach ($l in $data.timelogs) {
                        try { if ($l.PSObject.Properties['id1'] -and $l.id1 -match '^\d{2,5}$') { $codes += ('#' + [string]$l.id1) } } catch {}
                    }
                    $codes = @($codes | Select-Object -Unique)
                    if ($codes.Count -gt 0) { $completions += (Invoke-PmcFuzzyFilter -Items $codes -Query $Filter) }
                } catch {}
            } else {
                $tags = @()
                try {
                    $data = Get-PmcDataAlias
                    foreach ($t in $data.tasks) {
                        try {
                            if ($t -and $t.PSObject.Properties['tags']) {
                                foreach ($tg in @($t.tags)) { if ($tg) { $tags += ("#" + [string]$tg) } }
                            }
                        } catch {}
                    }
                } catch {}
                if ($tags.Count -eq 0) { $tags = @("#urgent", "#todo", "#review") }
                $tags = @($tags | Select-Object -Unique)
                $completions += (Invoke-PmcFuzzyFilter -Items $tags -Query $Filter)
            }
        }

        Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message "Argument completions: found $(@($completions).Count) items"
        return ,@($completions)

    } catch {
        Write-PmcDebug -Level 1 -Category 'COMPLETION' -Message "Argument completion error: $_"
        return @()
    }
}

# Get completions with caching and comprehensive instrumentation
function Get-CompletionsForState {
    param(
        [hashtable] $Context
    )

    $cacheKey = "$($Context.Mode):$($Context.CurrentToken):$($Context.Tokens -join ' ')"

    Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message "Start Tab cycle: state=$($Context.Mode), token='$($Context.CurrentToken)', tokens=$($Context.Tokens.Count)"

    # Check cache first for performance
    $cache = Pmc-GetCache
    if ($cache.ContainsKey($cacheKey)) {
        $cached = $cache[$cacheKey]
        # Cache hit - reduced verbosity
        return $cached
    }

    try {
        $completions = @()

        # Force argument completions when token starts with well-known prefixes
        $tok = $Context.CurrentToken
        $forceArg = ($tok -and ($tok.StartsWith('@') -or $tok.StartsWith('p') -or $tok.StartsWith('due:') -or $tok.StartsWith('#')))
        if ($forceArg) {
            $dom = if ($Context.Tokens.Count -gt 0) { $Context.Tokens[0] } else { '' }
            $act = if ($Context.Tokens.Count -gt 1) { $Context.Tokens[1] } else { '' }
            $completions = Get-PmcArgumentCompletions -Domain $dom -Action $act -Filter $tok
        } else {
            switch ($Context.Mode) {
                ([PmcCompletionMode]::Domain) {
                    $completions = Get-PmcDomainCompletions -Filter $Context.CurrentToken
                }
                ([PmcCompletionMode]::Action) {
                    if ($Context.Tokens.Count -gt 0) {
                        $completions = Get-PmcActionCompletions -Domain $Context.Tokens[0] -Filter $Context.CurrentToken
                    }
                }
                ([PmcCompletionMode]::Arguments) {
                    if ($Context.Tokens.Count -ge 2) {
                        $completions = Get-PmcArgumentCompletions -Domain $Context.Tokens[0] -Action $Context.Tokens[1] -Filter $Context.CurrentToken
                    }
                }
                default {
                    Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message "Unknown completion mode: $($Context.Mode)"
                }
            }
        }

        # No type conversion needed - strings are stable

        # Cache results for performance
        $cache[$cacheKey] = $completions

        # Clean cache if it gets too large (simple LRU)
        if ($cache.Keys.Count -gt 100) { $cache.Clear() }
        Pmc-SetCache $cache

        $safeCount = if ($completions -is [array]) { $completions.Count } elseif ($completions) { 1 } else { 0 }
        $safeFirst3 = try { ($completions | Select-Object -First 3) -join ', ' } catch { 'N/A' }
        Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message "Provider outputs: type=string[], length=$safeCount, first3=$safeFirst3"

        return $completions

    } catch {
        Write-PmcDebug -Level 1 -Category 'COMPLETION' -Message "Completion provider error: $_ | StackTrace: $($_.ScriptStackTrace)"
        return @()
    }
}

# Replace token in buffer with inline replacement
function Replace-TokenInBuffer {
    param(
        [string] $Buffer,
        [int] $TokenStart,
        [int] $TokenEnd,
        [string] $Replacement
    )

    if ($TokenStart -eq $TokenEnd) {
        # Insert at cursor position
        return $Buffer.Substring(0, $TokenStart) + $Replacement + $Buffer.Substring($TokenStart)
    } else {
        # Replace existing token
        return $Buffer.Substring(0, $TokenStart) + $Replacement + $Buffer.Substring($TokenEnd)
    }
}

# Ghost text system with inline positioning
# Clear ghost text (no-op with overlay model; kept for compatibility)
function Clear-GhostText { Write-Host -NoNewline "`e[0K" }

# History management
function Add-ToHistory {
    param([string] $Command)

    if ([string]::IsNullOrWhiteSpace($Command)) { return }

    # Don't add duplicate consecutive entries
    if ((Pmc-GetEditor).History.Count -gt 0 -and (Pmc-GetEditor).History[-1] -eq $Command) {
        return
    }

    (Pmc-GetEditor).History += $Command

    # Trim history if too long
    if ((Pmc-GetEditor).History.Count -gt (Pmc-GetEditor).MaxHistoryItems) {
        (Pmc-GetEditor).History = (Pmc-GetEditor).History[-(Pmc-GetEditor).MaxHistoryItems..-1]
    }

    (Pmc-GetEditor).HistoryIndex = (Pmc-GetEditor).History.Count
}

# Undo/Redo system
function Add-ToUndoStack {
    param([string] $State)

    (Pmc-GetEditor).UndoStack += $State
    (Pmc-GetEditor).RedoStack = @()  # Clear redo stack on new action

    if ((Pmc-GetEditor).UndoStack.Count -gt (Pmc-GetEditor).MaxUndoItems) {
        (Pmc-GetEditor).UndoStack = (Pmc-GetEditor).UndoStack[-(Pmc-GetEditor).MaxUndoItems..-1]
    }
}

# State snapshot for debugging exceptions
function Get-EditorStateSnapshot {
    $ed = Pmc-GetEditor
    return @{
        Buffer = $ed.Buffer
        CursorPos = $ed.CursorPos
        InCompletion = $ed.InCompletion
        CompletionCount = $ed.Completions.Count
        CompletionIndex = $ed.CompletionIndex
        Mode = $ed.Mode
        Timestamp = Get-Date
        CompletionDetails = ($ed.Completions | ForEach-Object { "$($_.GetType().Name):$($_)" }) -join '; '
    }
}

# Main command reader with comprehensive instrumentation
function Read-PmcCommand {
    Write-PmcDebug -Level 2 -Category 'INPUT' -Message "Starting Read-PmcCommand session"

    # Initialize editor state
    Pmc-SetEditor ([PmcEditorState]::new())

    # Initial prompt render
    try { Render-Interactive -Buffer '' -CursorPos 0 -InCompletion $false } catch {}

    while ($true) {
        try {
            # Defensive I/O: verify Console.ReadKey is available

            $key = [Console]::ReadKey($true)
            # Key press details reduced to completion/input summaries only

        } catch {
            Write-Host "Console.ReadKey failed: $_" -ForegroundColor Red
            Write-Host "Interactive mode not available (input redirected or no TTY)" -ForegroundColor Yellow
            break
        }

        # Save state for undo before major changes
        if ($key.Key -in @('Spacebar', 'Enter', 'Delete', 'Backspace')) {
            Add-ToUndoStack -State (Pmc-GetEditor).Buffer
        }

        try {
            switch ($key.Key) {
                'Tab' {
                    $beforeCtx = Parse-CompletionContext -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos
                    $beforeIn = (Pmc-GetEditor).InCompletion
                    $isShiftTab = ($key.Modifiers -band [ConsoleModifiers]::Shift) -eq [ConsoleModifiers]::Shift
                    $direction = if ($isShiftTab) { "reverse" } else { "forward" }
                    Write-PmcDebug -Level 2 -Category 'INPUT' -Message "Tab key pressed (Shift=$isShiftTab): buffer='$((Pmc-GetEditor).Buffer)', cursor=$((Pmc-GetEditor).CursorPos), inCompletion=$((Pmc-GetEditor).InCompletion)"
                    Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message "Tab cycle start: buffer='$((Pmc-GetEditor).Buffer)', cursor=$((Pmc-GetEditor).CursorPos), mode=initial, direction=$direction"

                    if (-not (Pmc-GetEditor).InCompletion) {
                        # First Tab: initialize completion cycling
                        (Pmc-GetEditor).OriginalBuffer = (Pmc-GetEditor).Buffer
                        $context = Parse-CompletionContext -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos
                        (Pmc-GetEditor).Mode = $context.Mode
                        (Pmc-GetEditor).CurrentToken = $context.CurrentToken
                        (Pmc-GetEditor).TokenStart = $context.TokenStart
                        (Pmc-GetEditor).TokenEnd = $context.TokenEnd

                        # Use unified completion system
                        (Pmc-GetEditor).Completions = Get-CompletionsForState -Context $context
                        $safeCompletionCount = if ((Pmc-GetEditor).Completions -is [array]) { (Pmc-GetEditor).Completions.Count } elseif ((Pmc-GetEditor).Completions) { 1 } else { 0 }
                        $safeCompletionFirst3 = try { ((Pmc-GetEditor).Completions | Select-Object -First 3) -join ', ' } catch { 'N/A' }
                        Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message "Provider outputs: type=string[], length=$safeCompletionCount, first3=$safeCompletionFirst3"

                        if ($safeCompletionCount -gt 0) {
                            (Pmc-GetEditor).InCompletion = $true
                            # For Shift+Tab on first press, start at the end
                            (Pmc-GetEditor).CompletionIndex = if ($isShiftTab) { $safeCompletionCount - 1 } else { 0 }

                            # Replace token with selected completion
                            $firstCompletion = (Pmc-GetEditor).Completions[(Pmc-GetEditor).CompletionIndex]
                            (Pmc-GetEditor).Buffer = Replace-TokenInBuffer -Buffer (Pmc-GetEditor).Buffer -TokenStart (Pmc-GetEditor).TokenStart -TokenEnd (Pmc-GetEditor).TokenEnd -Replacement $firstCompletion
                            (Pmc-GetEditor).CursorPos = (Pmc-GetEditor).TokenStart + $firstCompletion.Length

                            # Render with indicator and transient help from aux map
                            $helpInfo = $null
                            if ((Pmc-GetEditor).Mode -eq [PmcCompletionMode]::Action -and $context.Tokens.Count -gt 0) {
                                $helpInfo = Get-PmcCompletionInfo -Domain $context.Tokens[0] -Action $firstCompletion
                            } else {
                                $helpInfo = Get-PmcCompletionInfo -Text $firstCompletion
                            }
                            $helpText = if ($helpInfo) { $helpInfo.Description } else { $null }
                            Render-Line -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -IndicatorIndex 1 -IndicatorCount $safeCompletionCount -InCompletion $true -HelpText $helpText

                            Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message "Before Tab accept: index=0, selected item type=$($firstCompletion.GetType().Name), text='$($firstCompletion)'"
                            Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message "After Tab accept: new buffer='$((Pmc-GetEditor).Buffer)', phase=cycling (1/$safeCompletionCount)"
                        } else {
                        Write-Host "`r`e[0Kpmc> $((Pmc-GetEditor).Buffer) [no completions]" -NoNewline
                        Start-Sleep -Milliseconds 350
                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false
                            Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message "No completions found for context: $($context | ConvertTo-Json -Compress)"
                        }
                    } else {
                        # Cycle to next/previous completion based on direction
                        $safeCurrentCount = if ((Pmc-GetEditor).Completions -is [array]) { (Pmc-GetEditor).Completions.Count } elseif ((Pmc-GetEditor).Completions) { 1 } else { 0 }
                        if ($safeCurrentCount -gt 0) {
                        if ($isShiftTab) {
                            # Reverse direction (Shift+Tab)
                            (Pmc-GetEditor).CompletionIndex = ((Pmc-GetEditor).CompletionIndex - 1 + $safeCurrentCount) % $safeCurrentCount
                        } else {
                            # Forward direction (Tab)
                            (Pmc-GetEditor).CompletionIndex = ((Pmc-GetEditor).CompletionIndex + 1) % $safeCurrentCount
                        }
                    } else {
                        (Pmc-GetEditor).CompletionIndex = 0
                    }
                    $selectedCompletion = (Pmc-GetEditor).Completions[(Pmc-GetEditor).CompletionIndex]

                        # Replace token with cycled completion
                    (Pmc-GetEditor).Buffer = Replace-TokenInBuffer -Buffer (Pmc-GetEditor).OriginalBuffer -TokenStart (Pmc-GetEditor).TokenStart -TokenEnd (Pmc-GetEditor).TokenEnd -Replacement $selectedCompletion
                    (Pmc-GetEditor).CursorPos = (Pmc-GetEditor).TokenStart + $selectedCompletion.Length

                        # Render with indicator and transient help from aux map
                    $ctxForHelp = Parse-CompletionContext -Buffer (Pmc-GetEditor).OriginalBuffer -CursorPos (Pmc-GetEditor).TokenStart
                        $helpInfo = $null
                    if ((Pmc-GetEditor).Mode -eq [PmcCompletionMode]::Action -and $ctxForHelp.Tokens.Count -gt 0) {
                        $helpInfo = Get-PmcCompletionInfo -Domain $ctxForHelp.Tokens[0] -Action $selectedCompletion
                    } else {
                        $helpInfo = Get-PmcCompletionInfo -Text $selectedCompletion
                    }
                    $helpText = if ($helpInfo) { $helpInfo.Description } else { $null }
                    Render-Line -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -IndicatorIndex ((Pmc-GetEditor).CompletionIndex + 1) -IndicatorCount $safeCurrentCount -InCompletion $true -HelpText $helpText

                    Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message "Before Tab cycle ($direction): index=$((Pmc-GetEditor).CompletionIndex), selected item type=$($selectedCompletion.GetType().Name), text='$($selectedCompletion)'"
                    Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message "After Tab cycle ($direction): new buffer='$((Pmc-GetEditor).Buffer)', phase=cycling ($((Pmc-GetEditor).CompletionIndex + 1)/$safeCurrentCount)"
                    }
                    Write-StateChange -KeyName 'Tab' -BeforeCtx $beforeCtx -BeforeInCompletion $beforeIn
                    continue
                }

                'Spacebar' {
                    $beforeCtx = Parse-CompletionContext -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos
                    $beforeIn = (Pmc-GetEditor).InCompletion
                    Write-PmcDebug -Level 2 -Category 'INPUT' -Message "Space key pressed: buffer='$((Pmc-GetEditor).Buffer)', cursor=$((Pmc-GetEditor).CursorPos), inCompletion=$((Pmc-GetEditor).InCompletion)"

                    if ((Pmc-GetEditor).InCompletion) {
                        # Accept current completion, add space, reset for next state
                        $selectedCompletion = (Pmc-GetEditor).Completions[(Pmc-GetEditor).CompletionIndex]
                        (Pmc-GetEditor).Buffer = Replace-TokenInBuffer -Buffer (Pmc-GetEditor).OriginalBuffer -TokenStart (Pmc-GetEditor).TokenStart -TokenEnd (Pmc-GetEditor).TokenEnd -Replacement $selectedCompletion

                        if (-not (Pmc-GetEditor).Buffer.EndsWith(' ')) {
                            (Pmc-GetEditor).Buffer += ' '
                        }
                        (Pmc-GetEditor).CursorPos = (Pmc-GetEditor).Buffer.Length

                        # Reset completion state
                        (Pmc-GetEditor).InCompletion = $false
                        (Pmc-GetEditor).Completions = @()
                        (Pmc-GetEditor).CompletionIndex = -1

                        # Get new context after state change for logging
                        $afterCtx = Parse-CompletionContext -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos

                        # Redraw and show ghost for next phase
                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false

                        Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message "Before Space accept: index=$((Pmc-GetEditor).CompletionIndex), selected item type=$($selectedCompletion.GetType().Name), text='$($selectedCompletion)'"
                        Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message "After Space accept: new buffer='$((Pmc-GetEditor).Buffer)', phase=domain/action/prefix, nextState=$($afterCtx.Mode)"
                    } else {
                        # Insert space normally
                        (Pmc-GetEditor).Buffer = (Pmc-GetEditor).Buffer.Substring(0, (Pmc-GetEditor).CursorPos) + ' ' + (Pmc-GetEditor).Buffer.Substring((Pmc-GetEditor).CursorPos)
                        (Pmc-GetEditor).CursorPos++
                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false
                    }
                    Write-StateChange -KeyName 'Space' -BeforeCtx $beforeCtx -BeforeInCompletion $beforeIn
                    continue
                }

                'Enter' {
                    $beforeCtx = Parse-CompletionContext -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos
                    $beforeIn = (Pmc-GetEditor).InCompletion
                    Write-PmcDebug -Level 2 -Category 'INPUT' -Message "Enter key pressed: buffer='$((Pmc-GetEditor).Buffer)', cursor=$((Pmc-GetEditor).CursorPos), inCompletion=$((Pmc-GetEditor).InCompletion)"

                    if ((Pmc-GetEditor).InCompletion) {
                        # Accept completion then submit
                        $selectedCompletion = (Pmc-GetEditor).Completions[(Pmc-GetEditor).CompletionIndex]
                        (Pmc-GetEditor).Buffer = Replace-TokenInBuffer -Buffer (Pmc-GetEditor).OriginalBuffer -TokenStart (Pmc-GetEditor).TokenStart -TokenEnd (Pmc-GetEditor).TokenEnd -Replacement $selectedCompletion
                        Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message "Before Enter accept: index=$((Pmc-GetEditor).CompletionIndex), selected item type=$($selectedCompletion.GetType().Name), text='$($selectedCompletion)'"
                        Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message "After Enter accept: final buffer='$((Pmc-GetEditor).Buffer)', phase=submit"
                    }

                    Clear-GhostText

                    if (-not [string]::IsNullOrWhiteSpace((Pmc-GetEditor).Buffer)) {
                        Add-ToHistory -Command (Pmc-GetEditor).Buffer
                    }

                    Write-StateChange -KeyName 'Enter' -BeforeCtx $beforeCtx -BeforeInCompletion $beforeIn
                    return (Pmc-GetEditor).Buffer
                }

                'Escape' {
                    $beforeCtx = Parse-CompletionContext -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos
                    $beforeIn = (Pmc-GetEditor).InCompletion
                    Write-PmcDebug -Level 2 -Category 'INPUT' -Message "Escape key pressed: buffer='$((Pmc-GetEditor).Buffer)', cursor=$((Pmc-GetEditor).CursorPos), inCompletion=$((Pmc-GetEditor).InCompletion)"

                    if ((Pmc-GetEditor).InCompletion) {
                        # Cancel completion, restore original buffer
                        (Pmc-GetEditor).Buffer = (Pmc-GetEditor).OriginalBuffer
                        (Pmc-GetEditor).CursorPos = (Pmc-GetEditor).OriginalBuffer.Length
                        (Pmc-GetEditor).InCompletion = $false
                        (Pmc-GetEditor).Completions = @()
                        (Pmc-GetEditor).CompletionIndex = -1
                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false
                    } else {
                        # Clear entire line
                        (Pmc-GetEditor).Buffer = ""
                        (Pmc-GetEditor).CursorPos = 0
                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false
                    }
                    Write-StateChange -KeyName 'Escape' -BeforeCtx $beforeCtx -BeforeInCompletion $beforeIn
                    continue
                }

                'Backspace' {
                    $beforeCtx = Parse-CompletionContext -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos
                    $beforeIn = (Pmc-GetEditor).InCompletion
                    Write-PmcDebug -Level 2 -Category 'INPUT' -Message "Backspace key pressed: buffer='$((Pmc-GetEditor).Buffer)', cursor=$((Pmc-GetEditor).CursorPos), inCompletion=$((Pmc-GetEditor).InCompletion)"
                    if ((Pmc-GetEditor).CursorPos -gt 0) {
                        (Pmc-GetEditor).Buffer = (Pmc-GetEditor).Buffer.Substring(0, (Pmc-GetEditor).CursorPos - 1) + (Pmc-GetEditor).Buffer.Substring((Pmc-GetEditor).CursorPos)
                        (Pmc-GetEditor).CursorPos--

                        # Exit completion mode when editing
                        if ((Pmc-GetEditor).InCompletion) {
                            (Pmc-GetEditor).InCompletion = $false
                            (Pmc-GetEditor).Completions = @()
                            (Pmc-GetEditor).CompletionIndex = -1
                        }

                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false
                    }
                    Write-StateChange -KeyName 'Backspace' -BeforeCtx $beforeCtx -BeforeInCompletion $beforeIn
                    continue
                }

                'UpArrow' {
                    $beforeCtx = Parse-CompletionContext -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos
                    $beforeIn = (Pmc-GetEditor).InCompletion
                    Write-PmcDebug -Level 2 -Category 'INPUT' -Message "UpArrow key pressed: buffer='$((Pmc-GetEditor).Buffer)', historyIndex=$((Pmc-GetEditor).HistoryIndex), historySize=$((Pmc-GetEditor).History.Count)"

                    if ((Pmc-GetEditor).History.Count -gt 0) {
                        if ((Pmc-GetEditor).HistoryIndex -gt 0) { (Pmc-GetEditor).HistoryIndex-- }
                        (Pmc-GetEditor).Buffer = (Pmc-GetEditor).History[(Pmc-GetEditor).HistoryIndex]
                        (Pmc-GetEditor).CursorPos = (Pmc-GetEditor).Buffer.Length
                        (Pmc-GetEditor).InCompletion = $false
                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false
                    }
                    Write-StateChange -KeyName 'UpArrow' -BeforeCtx $beforeCtx -BeforeInCompletion $beforeIn
                    continue
                }

                'DownArrow' {
                    $beforeCtx = Parse-CompletionContext -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos
                    $beforeIn = (Pmc-GetEditor).InCompletion
                    Write-PmcDebug -Level 2 -Category 'INPUT' -Message "DownArrow key pressed: buffer='$((Pmc-GetEditor).Buffer)', historyIndex=$((Pmc-GetEditor).HistoryIndex), historySize=$((Pmc-GetEditor).History.Count)"

                    if ((Pmc-GetEditor).History.Count -gt 0) {
                        if ((Pmc-GetEditor).HistoryIndex -lt ((Pmc-GetEditor).History.Count - 1)) {
                            (Pmc-GetEditor).HistoryIndex++
                            (Pmc-GetEditor).Buffer = (Pmc-GetEditor).History[(Pmc-GetEditor).HistoryIndex]
                        } else {
                            (Pmc-GetEditor).HistoryIndex = (Pmc-GetEditor).History.Count
                            (Pmc-GetEditor).Buffer = ""
                        }
                        (Pmc-GetEditor).CursorPos = (Pmc-GetEditor).Buffer.Length
                        (Pmc-GetEditor).InCompletion = $false
                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false
                    }
                    Write-StateChange -KeyName 'DownArrow' -BeforeCtx $beforeCtx -BeforeInCompletion $beforeIn
                    continue
                }

                'R' {
                    if (($key.Modifiers -band [ConsoleModifiers]::Control) -ne 0) {
                        Write-PmcDebug -Level 2 -Category 'INPUT' -Message "Ctrl+R key pressed: reverse history search initiated, historySize=$((Pmc-GetEditor).History.Count)"

                        Write-Host "`r`e[0K(reverse-i-search): " -NoNewline
                        $searchTerm = ""
                    $searchResults = @()
                    $searchIndex = 0

                    while ($true) {
                        $searchKey = [Console]::ReadKey($true)

                        if ($searchKey.Key -eq 'Enter' -or $searchKey.Key -eq 'Escape') {
                            if ($searchKey.Key -eq 'Enter' -and $searchResults.Count -gt 0) {
                                (Pmc-GetEditor).Buffer = $searchResults[$searchIndex]
                                (Pmc-GetEditor).CursorPos = (Pmc-GetEditor).Buffer.Length
                            }
                            Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false
                            break
                        } elseif ($searchKey.Key -eq 'Backspace' -and $searchTerm.Length -gt 0) {
                            $searchTerm = $searchTerm.Substring(0, $searchTerm.Length - 1)
                        } elseif ($searchKey.Key -eq 'R' -and $searchKey.Modifiers -eq 'Control') {
                            # Next search result
                            if ($searchResults.Count -gt 1) {
                                $searchIndex = ($searchIndex + 1) % $searchResults.Count
                            }
                        } elseif (-not [char]::IsControl($searchKey.KeyChar)) {
                            $searchTerm += $searchKey.KeyChar
                        }

                        # Update search results
                        if ($searchTerm.Length -gt 0) {
                            $searchResults = @((Pmc-GetEditor).History | Where-Object { $_ -like "*$searchTerm*" } | Select-Object -Last 10)
                            if ($searchResults.Count -eq 0) {
                                $searchResults = @()
                                $searchIndex = 0
                            } elseif ($searchIndex -ge $searchResults.Count) {
                                $searchIndex = 0
                            }
                        }

                        # Display search state
                        $displayText = if ($searchResults.Count -gt 0) { $searchResults[$searchIndex] } else { "" }
                        Write-Host "`r`e[0K(reverse-i-search)'$searchTerm': $displayText" -NoNewline
                    }

                        continue
                    } else {
                        # Regular 'R' character input
                        $editor = Pmc-GetEditor
                        $editor.Buffer = $editor.Buffer.Insert($editor.CursorPos, $key.KeyChar)
                        $editor.CursorPos++
                        Pmc-SetEditor $editor
                        Render-Interactive -Buffer $editor.Buffer -CursorPos $editor.CursorPos -InCompletion $false
                    }
                    continue
                }

                'Z' {
                    if (($key.Modifiers -band [ConsoleModifiers]::Control) -ne 0) {
                        Write-PmcDebug -Level 2 -Category 'INPUT' -Message "Ctrl+Z key pressed: undo, undoStackSize=$((Pmc-GetEditor).UndoStack.Count), redoStackSize=$((Pmc-GetEditor).RedoStack.Count)"

                        if ((Pmc-GetEditor).UndoStack.Count -gt 0) {
                            (Pmc-GetEditor).RedoStack += (Pmc-GetEditor).Buffer
                            (Pmc-GetEditor).Buffer = (Pmc-GetEditor).UndoStack[-1]
                            (Pmc-GetEditor).UndoStack = (Pmc-GetEditor).UndoStack[0..((Pmc-GetEditor).UndoStack.Count - 2)]
                            (Pmc-GetEditor).CursorPos = (Pmc-GetEditor).Buffer.Length
                            (Pmc-GetEditor).InCompletion = $false
                            Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false
                        }
                        continue
                    } else {
                        # Regular 'Z' character input
                        (Pmc-GetEditor).Buffer = (Pmc-GetEditor).Buffer.Insert((Pmc-GetEditor).CursorPos, $key.KeyChar)
                        (Pmc-GetEditor).CursorPos++
                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false
                    }
                    continue
                }

                'Y' {
                    if (($key.Modifiers -band [ConsoleModifiers]::Control) -ne 0) {
                        Write-PmcDebug -Level 2 -Category 'INPUT' -Message "Ctrl+Y key pressed: redo, undoStackSize=$((Pmc-GetEditor).UndoStack.Count), redoStackSize=$((Pmc-GetEditor).RedoStack.Count)"

                        if ((Pmc-GetEditor).RedoStack.Count -gt 0) {
                            (Pmc-GetEditor).UndoStack += (Pmc-GetEditor).Buffer
                            (Pmc-GetEditor).Buffer = (Pmc-GetEditor).RedoStack[-1]
                            (Pmc-GetEditor).RedoStack = (Pmc-GetEditor).RedoStack[0..((Pmc-GetEditor).RedoStack.Count - 2)]
                            (Pmc-GetEditor).CursorPos = (Pmc-GetEditor).Buffer.Length
                            (Pmc-GetEditor).InCompletion = $false
                            Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false
                        }
                        continue
                    } else {
                        # Regular 'Y' character input
                        (Pmc-GetEditor).Buffer = (Pmc-GetEditor).Buffer.Insert((Pmc-GetEditor).CursorPos, $key.KeyChar)
                        (Pmc-GetEditor).CursorPos++
                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false
                    }
                    continue
                }

                default {
                    $beforeCtx = Parse-CompletionContext -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos
                    $beforeIn = (Pmc-GetEditor).InCompletion
                    # Regular character input
                    if (-not [char]::IsControl($key.KeyChar)) {
                        # Character input reduced verbosity
                        # Exit completion mode when typing new characters
                        if ((Pmc-GetEditor).InCompletion) {
                            (Pmc-GetEditor).InCompletion = $false
                            (Pmc-GetEditor).Completions = @()
                            (Pmc-GetEditor).CompletionIndex = -1
                        }

                        (Pmc-GetEditor).Buffer = (Pmc-GetEditor).Buffer.Substring(0, (Pmc-GetEditor).CursorPos) + $key.KeyChar + (Pmc-GetEditor).Buffer.Substring((Pmc-GetEditor).CursorPos)
                        (Pmc-GetEditor).CursorPos++
                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false
                    }
                    Write-StateChange -KeyName 'Char' -BeforeCtx $beforeCtx -BeforeInCompletion $beforeIn
                    continue
                }
            }

        } catch {
            $snapshot = Get-EditorStateSnapshot
            Write-PmcDebug -Level 1 -Category 'INPUT' -Message "EXCEPTION: Input processing error: $_ | FULL STATE DUMP: $($snapshot | ConvertTo-Json -Depth 5 -Compress) | StackTrace: $($_.ScriptStackTrace)"
            Write-PmcDebug -Level 1 -Category 'INPUT' -Message "EXCEPTION CONTEXT: Key=$($key.Key), KeyChar='$($key.KeyChar)', Modifiers=$($key.Modifiers)"
            Write-Host "Input processing failed: $_" -ForegroundColor Red
            break
        }
    }
}

# Initialize interactive mode
function Enable-PmcInteractiveMode {
    Write-PmcDebug -Level 1 -Category 'INTERACTIVE' -Message "Enabling PMC interactive mode with full t2.ps1 feature set"

    try {
        try { if (Get-Module PSReadLine -ErrorAction SilentlyContinue) { Remove-Module PSReadLine -Force -ErrorAction SilentlyContinue } } catch {}
        try { [Console]::OutputEncoding = [System.Text.Encoding]::UTF8 } catch {}
        try { [Console]::CursorVisible = $true } catch {}
        # Clear completion cache
        Pmc-ClearCache

        # Initialize auxiliary completion info map (idempotent)
        $iMap = Pmc-GetInfoMap
        if (-not $iMap -or $iMap.Keys.Count -eq 0) {
            Initialize-PmcCompletionInfoMap
        }

        # Initialize editor state
        Pmc-SetEditor ([PmcEditorState]::new())

        Write-PmcStyled -Style 'Success' -Text "✓ Interactive mode enabled (Console.ReadKey)"
        return $true

    } catch {
        Write-PmcDebug -Level 1 -Category 'INTERACTIVE' -Message "Failed to enable interactive mode: $_"
        Write-PmcStyled -Style 'Error' -Text ("Failed to enable interactive mode: {0}" -f $_)
        return $false
    }
}

function Disable-PmcInteractiveMode {
    Write-PmcDebug -Level 1 -Category 'INTERACTIVE' -Message "Disabling PMC interactive mode"

    try {
        Pmc-ClearCache
        Pmc-SetEditor ([PmcEditorState]::new())
        Write-PmcStyled -Style 'Success' -Text "✓ Interactive mode disabled"

    } catch {
        Write-PmcDebug -Level 1 -Category 'INTERACTIVE' -Message "Error disabling interactive mode: $_"
        Write-PmcStyled -Style 'Error' -Text ("Error disabling interactive mode: {0}" -f $_)
    }
}

function Get-PmcInteractiveStatus {
    return @{
        Enabled = $true
        GhostTextEnabled = (Pmc-GetGhost)
        CacheSize = (Pmc-GetCache).Keys.Count
        HistorySize = (Pmc-GetEditor).History.Count
        UndoStackSize = (Pmc-GetEditor).UndoStack.Count
        Features = @("InlineCycling", "GhostText", "History", "CtrlR", "UndoRedo", "ErrorRecovery")
    }
}

# Export functions
Export-ModuleMember -Function Enable-PmcInteractiveMode, Disable-PmcInteractiveMode, Get-PmcInteractiveStatus, Read-PmcCommand

===== END FILE: module/Pmc.Strict/src/Interactive.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/ProjectWizard.ps1 =====
# ProjectWizard.ps1 - Guided project creation wizard
# Provides step-by-step project setup with templates and best practices

class PmcProjectWizard {
    [string]$CurrentStep
    [hashtable]$ProjectData
    [string[]]$Steps
    [int]$StepIndex
    [hashtable]$Templates
    [bool]$IsActive

    PmcProjectWizard() {
        $this.InitializeWizard()
    }

    [void] InitializeWizard() {
        $this.Steps = @(
            'welcome',
            'template',
            'basic_info',
            'goals',
            'timeline',
            'resources',
            'review',
            'create'
        )

        $this.StepIndex = 0
        $this.CurrentStep = $this.Steps[0]
        $this.IsActive = $false

        $this.ProjectData = @{
            name = ""
            description = ""
            template = ""
            goals = @()
            timeline = @{
                start = ""
                deadline = ""
                milestones = @()
            }
            resources = @{
                budget = ""
                team = @()
                tools = @()
            }
            tags = @()
            priority = ""
        }

        $this.InitializeTemplates()
    }

    [void] InitializeTemplates() {
        $this.Templates = @{
            'software' = @{
                name = 'Software Development'
                description = 'Full-stack development project with phases'
                goals = @('Requirements Analysis', 'Design & Architecture', 'Development', 'Testing', 'Deployment')
                timeline_weeks = 12
                suggested_tools = @('IDE', 'Version Control', 'Issue Tracker', 'CI/CD')
                default_tags = @('development', 'software')
            }
            'marketing' = @{
                name = 'Marketing Campaign'
                description = 'Comprehensive marketing campaign planning'
                goals = @('Market Research', 'Strategy Development', 'Content Creation', 'Campaign Launch', 'Analytics')
                timeline_weeks = 8
                suggested_tools = @('Analytics', 'Social Media Tools', 'Design Software', 'Email Platform')
                default_tags = @('marketing', 'campaign')
            }
            'research' = @{
                name = 'Research Project'
                description = 'Academic or business research initiative'
                goals = @('Literature Review', 'Methodology Design', 'Data Collection', 'Analysis', 'Report Writing')
                timeline_weeks = 16
                suggested_tools = @('Research Database', 'Survey Tools', 'Statistical Software', 'Writing Tools')
                default_tags = @('research', 'analysis')
            }
            'event' = @{
                name = 'Event Planning'
                description = 'Conference, meeting, or event organization'
                goals = @('Planning & Budget', 'Venue & Logistics', 'Speaker Coordination', 'Marketing', 'Execution')
                timeline_weeks = 6
                suggested_tools = @('Event Platform', 'Registration System', 'Communication Tools', 'Budget Tracker')
                default_tags = @('event', 'planning')
            }
            'custom' = @{
                name = 'Custom Project'
                description = 'Build your project from scratch'
                goals = @()
                timeline_weeks = 4
                suggested_tools = @()
                default_tags = @()
            }
        }
    }

    [void] Start() {
        try {
            $this.IsActive = $true
            [Console]::Clear()

            while ($this.IsActive -and $this.StepIndex -lt $this.Steps.Count) {
                $this.DrawStep()
                $this.HandleStepInput()
            }

        } catch {
            Write-PmcStyled -Style 'Error' -Text ("Wizard error: {0}" -f $_)
        } finally {
            [Console]::Clear()
        }
    }

    [void] DrawStep() {
        [Console]::Clear()
        $this.DrawHeader()

        switch ($this.CurrentStep) {
            'welcome' { $this.DrawWelcomeStep() }
            'template' { $this.DrawTemplateStep() }
            'basic_info' { $this.DrawBasicInfoStep() }
            'goals' { $this.DrawGoalsStep() }
            'timeline' { $this.DrawTimelineStep() }
            'resources' { $this.DrawResourcesStep() }
            'review' { $this.DrawReviewStep() }
            'create' { $this.DrawCreateStep() }
        }

        $this.DrawFooter()
    }

    [void] DrawHeader() {
        $palette = Get-PmcColorPalette
        $headerColor = Get-PmcColorSequence $palette.Header
        $resetColor = [PmcVT]::Reset()

        $progressBar = $this.GenerateProgressBar()
        $stepName = $this.CurrentStep.Replace('_', ' ').ToUpper()

        Write-Host "$headerColor╭─ PMC Project Creation Wizard ─────────────────────────────────╮$resetColor"
        Write-Host "$headerColor│ Step $($this.StepIndex + 1) of $($this.Steps.Count): $stepName$(' ' * (50 - $stepName.Length))│$resetColor"
        Write-Host "$headerColor│ $progressBar │$resetColor"
        Write-Host "$headerColor╰─────────────────────────────────────────────────────────────────╯$resetColor"
        Write-Host ""
    }

    [string] GenerateProgressBar() {
        $width = 60
        $completed = [Math]::Floor($width * $this.StepIndex / $this.Steps.Count)
        $remaining = $width - $completed

        return ('█' * $completed) + ('░' * $remaining)
    }

    [void] DrawWelcomeStep() {
        $palette = Get-PmcColorPalette
        $textColor = Get-PmcColorSequence $palette.Text
        $highlightColor = Get-PmcColorSequence $palette.Highlight
        $resetColor = [PmcVT]::Reset()

        Write-Host "$textColor Welcome to the PMC Project Creation Wizard!$resetColor"
        Write-Host ""
        Write-Host "$textColor This wizard will guide you through creating a new project with:$resetColor"
        Write-Host "$highlightColor   ✓ Project templates and best practices$resetColor"
        Write-Host "$highlightColor   ✓ Goal setting and milestone planning$resetColor"
        Write-Host "$highlightColor   ✓ Timeline and deadline management$resetColor"
        Write-Host "$highlightColor   ✓ Resource allocation and team setup$resetColor"
        Write-Host ""
        Write-Host "$textColor The wizard takes about 5 minutes and will create a fully$resetColor"
        Write-Host "$textColor structured project ready for immediate use.$resetColor"
        Write-Host ""
        Write-Host "$highlightColor Press Enter to begin or Esc to cancel$resetColor"
    }

    [void] DrawTemplateStep() {
        $palette = Get-PmcColorPalette
        $textColor = Get-PmcColorSequence $palette.Text
        $highlightColor = Get-PmcColorSequence $palette.Highlight
        $resetColor = [PmcVT]::Reset()

        Write-Host "$textColor Choose a project template to get started quickly:$resetColor"
        Write-Host ""

        $index = 1
        foreach ($templateKey in $this.Templates.Keys) {
            $template = $this.Templates[$templateKey]
            $isSelected = $this.ProjectData.template -eq $templateKey

            $marker = if ($isSelected) { "$highlightColor►$resetColor" } else { " " }
            $nameColor = if ($isSelected) { $highlightColor } else { $textColor }

            Write-Host "$marker $nameColor$index. $($template.name)$resetColor"
            Write-Host "    $($template.description)"
            Write-Host "    Timeline: ~$($template.timeline_weeks) weeks"
            Write-Host ""
            $index++
        }

        Write-Host "$textColor Enter template number (1-$($this.Templates.Count)) or 'c' for custom:$resetColor"
    }

    [void] DrawBasicInfoStep() {
        $palette = Get-PmcColorPalette
        $textColor = Get-PmcColorSequence $palette.Text
        $labelColor = Get-PmcColorSequence $palette.Label
        $valueColor = Get-PmcColorSequence $palette.Highlight
        $resetColor = [PmcVT]::Reset()

        $selectedTemplate = if ($this.ProjectData.template) {
            $this.Templates[$this.ProjectData.template].name
        } else {
            "None selected"
        }

        Write-Host "$textColor Project Basic Information:$resetColor"
        Write-Host ""
        Write-Host "$labelColor Template:$resetColor $valueColor$selectedTemplate$resetColor"
        Write-Host ""

        Write-Host "$labelColor Project Name:$resetColor"
        if ($this.ProjectData.name) {
            Write-Host "$valueColor$($this.ProjectData.name)$resetColor"
        } else {
            Write-Host "$textColor[Enter project name]$resetColor"
        }
        Write-Host ""

        Write-Host "$labelColor Description:$resetColor"
        if ($this.ProjectData.description) {
            Write-Host "$valueColor$($this.ProjectData.description)$resetColor"
        } else {
            Write-Host "$textColor[Enter project description]$resetColor"
        }
        Write-Host ""

        if (-not $this.ProjectData.name) {
            Write-Host "$textColor Enter project name: $resetColor" -NoNewline
        } elseif (-not $this.ProjectData.description) {
            Write-Host "$textColor Enter project description: $resetColor" -NoNewline
        } else {
            Write-Host "$textColor Press Enter to continue, 'e' to edit name/description$resetColor"
        }
    }

    [void] DrawGoalsStep() {
        $palette = Get-PmcColorPalette
        $textColor = Get-PmcColorSequence $palette.Text
        $labelColor = Get-PmcColorSequence $palette.Label
        $valueColor = Get-PmcColorSequence $palette.Highlight
        $resetColor = [PmcVT]::Reset()

        Write-Host "$textColor Project Goals and Milestones:$resetColor"
        Write-Host ""

        if ($this.ProjectData.template -and $this.ProjectData.template -ne 'custom') {
            $template = $this.Templates[$this.ProjectData.template]
            Write-Host "$labelColor Template suggests these goals:$resetColor"
            foreach ($goal in $template.goals) {
                Write-Host "$valueColor  ✓ $goal$resetColor"
            }
            Write-Host ""
            Write-Host "$textColor Press 'a' to accept these goals, 'c' to customize, or 's' to skip:$resetColor"
        } else {
            Write-Host "$labelColor Current Goals:$resetColor"
            if ($this.ProjectData.goals.Count -gt 0) {
                foreach ($goal in $this.ProjectData.goals) {
                    Write-Host "$valueColor  ✓ $goal$resetColor"
                }
            } else {
                Write-Host "$textColor  [No goals defined yet]$resetColor"
            }
            Write-Host ""
            Write-Host "$textColor Enter goal (or 'done' to finish): $resetColor" -NoNewline
        }
    }

    [void] DrawTimelineStep() {
        $palette = Get-PmcColorPalette
        $textColor = Get-PmcColorSequence $palette.Text
        $labelColor = Get-PmcColorSequence $palette.Label
        $valueColor = Get-PmcColorSequence $palette.Highlight
        $resetColor = [PmcVT]::Reset()

        Write-Host "$textColor Project Timeline:$resetColor"
        Write-Host ""

        Write-Host "$labelColor Start Date:$resetColor $valueColor$($this.ProjectData.timeline.start)$resetColor"
        Write-Host "$labelColor Deadline:$resetColor $valueColor$($this.ProjectData.timeline.deadline)$resetColor"
        Write-Host ""

        if ($this.ProjectData.template -and $this.ProjectData.template -ne 'custom') {
            $template = $this.Templates[$this.ProjectData.template]
            $suggestedEnd = (Get-Date).AddDays($template.timeline_weeks * 7).ToString("yyyy-MM-dd")
            Write-Host "$labelColor Template suggests $($template.timeline_weeks) weeks: $resetColor$valueColor$suggestedEnd$resetColor"
        }

        Write-Host ""
        Write-Host "$textColor Enter start date (YYYY-MM-DD) or 'today': $resetColor" -NoNewline
    }

    [void] DrawResourcesStep() {
        $palette = Get-PmcColorPalette
        $textColor = Get-PmcColorSequence $palette.Text
        $labelColor = Get-PmcColorSequence $palette.Label
        $valueColor = Get-PmcColorSequence $palette.Highlight
        $resetColor = [PmcVT]::Reset()

        Write-Host "$textColor Project Resources:$resetColor"
        Write-Host ""

        Write-Host "$labelColor Budget:$resetColor $valueColor$($this.ProjectData.resources.budget)$resetColor"
        Write-Host "$labelColor Team Members:$resetColor $valueColor$($this.ProjectData.resources.team -join ', ')$resetColor"
        Write-Host "$labelColor Tools/Technologies:$resetColor $valueColor$($this.ProjectData.resources.tools -join ', ')$resetColor"
        Write-Host ""

        if ($this.ProjectData.template -and $this.ProjectData.template -ne 'custom') {
            $template = $this.Templates[$this.ProjectData.template]
            if ($template.suggested_tools.Count -gt 0) {
                Write-Host "$labelColor Template suggests these tools:$resetColor"
                foreach ($tool in $template.suggested_tools) {
                    Write-Host "$valueColor  • $tool$resetColor"
                }
                Write-Host ""
            }
        }

        Write-Host "$textColor Enter budget (optional) or press Enter to skip: $resetColor" -NoNewline
    }

    [void] DrawReviewStep() {
        $palette = Get-PmcColorPalette
        $textColor = Get-PmcColorSequence $palette.Text
        $labelColor = Get-PmcColorSequence $palette.Label
        $valueColor = Get-PmcColorSequence $palette.Highlight
        $headerColor = Get-PmcColorSequence $palette.Header
        $resetColor = [PmcVT]::Reset()

        Write-Host "$headerColor Review Project Configuration:$resetColor"
        Write-Host ""

        Write-Host "$labelColor Name:$resetColor $valueColor$($this.ProjectData.name)$resetColor"
        Write-Host "$labelColor Description:$resetColor $valueColor$($this.ProjectData.description)$resetColor"
        Write-Host "$labelColor Template:$resetColor $valueColor$($this.Templates[$this.ProjectData.template].name)$resetColor"
        Write-Host ""

        Write-Host "$labelColor Goals ($($this.ProjectData.goals.Count)):$resetColor"
        foreach ($goal in $this.ProjectData.goals) {
            Write-Host "$valueColor  ✓ $goal$resetColor"
        }
        Write-Host ""

        Write-Host "$labelColor Timeline:$resetColor"
        Write-Host "$valueColor  Start: $($this.ProjectData.timeline.start)$resetColor"
        Write-Host "$valueColor  End: $($this.ProjectData.timeline.deadline)$resetColor"
        Write-Host ""

        if ($this.ProjectData.resources.budget) {
            Write-Host "$labelColor Budget:$resetColor $valueColor$($this.ProjectData.resources.budget)$resetColor"
        }

        if ($this.ProjectData.resources.tools.Count -gt 0) {
            Write-Host "$labelColor Tools:$resetColor $valueColor$($this.ProjectData.resources.tools -join ', ')$resetColor"
        }

        Write-Host ""
        Write-Host "$textColor Press 'c' to create project, 'b' to go back, or 'e' to edit: $resetColor" -NoNewline
    }

    [void] DrawCreateStep() {
        $palette = Get-PmcColorPalette
        $textColor = Get-PmcColorSequence $palette.Text
        $successColor = Get-PmcColorSequence $palette.Success
        $resetColor = [PmcVT]::Reset()

        Write-Host "$successColor Creating project...$resetColor"
        Write-Host ""

        try {
            $this.CreateProject()
            Write-Host "$successColor✓ Project '$($this.ProjectData.name)' created successfully!$resetColor"
            Write-Host ""
            Write-Host "$textColor Initial tasks have been created based on your goals.$resetColor"
            Write-Host "$textColor Timeline and milestones are set up.$resetColor"
            Write-Host "$textColor You can now start working on your project.$resetColor"
            Write-Host ""
            Write-Host "$textColor Press any key to continue...$resetColor"

        } catch {
            Write-Host "✗ Error creating project: $_" -ForegroundColor Red
            Write-Host ""
            Write-Host "Press any key to continue..." -ForegroundColor Yellow
        }
    }

    [void] DrawFooter() {
        $footerRow = [Console]::WindowHeight - 3
        $palette = Get-PmcColorPalette
        $footerColor = Get-PmcColorSequence $palette.Footer
        $resetColor = [PmcVT]::Reset()

        [Console]::SetCursorPosition(0, $footerRow)
        Write-Host "$footerColor$('─' * [Console]::WindowWidth)$resetColor"

        $footerText = switch ($this.CurrentStep) {
            'welcome' { "Enter:Continue  Esc:Cancel" }
            'create' { "Any key to finish" }
            default { "Enter:Next  B:Back  Esc:Cancel" }
        }

        [Console]::SetCursorPosition(0, $footerRow + 1)
        Write-Host "$footerColor $footerText$resetColor"
    }

    [void] HandleStepInput() {
        $key = [Console]::ReadKey($true)

        switch ($key.Key) {
            'Escape' {
                $this.IsActive = $false
                return
            }
            'B' {
                if ($this.StepIndex -gt 0) {
                    $this.StepIndex--
                    $this.CurrentStep = $this.Steps[$this.StepIndex]
                }
                return
            }
            'Enter' {
                if ($this.CurrentStep -eq 'welcome') {
                    $this.NextStep()
                } elseif ($this.CanProceedFromCurrentStep()) {
                    $this.NextStep()
                }
                return
            }
        }

        # Handle step-specific input
        switch ($this.CurrentStep) {
            'template' { $this.HandleTemplateInput($key) }
            'basic_info' { $this.HandleBasicInfoInput($key) }
            'goals' { $this.HandleGoalsInput($key) }
            'timeline' { $this.HandleTimelineInput($key) }
            'resources' { $this.HandleResourcesInput($key) }
            'review' { $this.HandleReviewInput($key) }
            'create' { $this.IsActive = $false }
        }
    }

    [void] HandleTemplateInput([ConsoleKeyInfo]$key) {
        $templateKeys = @($this.Templates.Keys)
        $char = $key.KeyChar.ToString()

        if ($char -match '^[1-5]$') {
            $index = [int]$char - 1
            if ($index -lt $templateKeys.Count) {
                $this.ProjectData.template = $templateKeys[$index]
                $this.NextStep()
            }
        } elseif ($char.ToLower() -eq 'c') {
            $this.ProjectData.template = 'custom'
            $this.NextStep()
        }
    }

    [void] HandleBasicInfoInput([ConsoleKeyInfo]$key) {
        if (-not $this.ProjectData.name) {
            $name = $this.ReadLine("Enter project name: ")
            if (-not [string]::IsNullOrWhiteSpace($name)) {
                $this.ProjectData.name = $name.Trim()
            }
        } elseif (-not $this.ProjectData.description) {
            $description = $this.ReadLine("Enter project description: ")
            if (-not [string]::IsNullOrWhiteSpace($description)) {
                $this.ProjectData.description = $description.Trim()
            }
        } elseif ($key.KeyChar.ToString().ToLower() -eq 'e') {
            # Edit mode - allow re-entering values
            $choice = $this.ReadLine("Edit (n)ame or (d)escription? ")
            if ($choice.ToLower() -eq 'n') {
                $this.ProjectData.name = ""
            } elseif ($choice.ToLower() -eq 'd') {
                $this.ProjectData.description = ""
            }
        }
    }

    [void] HandleGoalsInput([ConsoleKeyInfo]$key) {
        $char = $key.KeyChar.ToString().ToLower()

        if ($this.ProjectData.template -and $this.ProjectData.template -ne 'custom' -and $this.ProjectData.goals.Count -eq 0) {
            switch ($char) {
                'a' {
                    # Accept template goals
                    $template = $this.Templates[$this.ProjectData.template]
                    $this.ProjectData.goals = $template.goals
                    $this.NextStep()
                }
                'c' {
                    # Customize goals - fall through to manual entry
                }
                's' {
                    # Skip goals
                    $this.NextStep()
                }
            }
        } else {
            # Manual goal entry
            $goal = $this.ReadLine("Enter goal (or 'done' to finish): ")
            if ($goal.ToLower() -eq 'done') {
                $this.NextStep()
            } elseif (-not [string]::IsNullOrWhiteSpace($goal)) {
                $this.ProjectData.goals += $goal.Trim()
            }
        }
    }

    [void] HandleTimelineInput([ConsoleKeyInfo]$key) {
        if (-not $this.ProjectData.timeline.start) {
            $start = $this.ReadLine("Enter start date (YYYY-MM-DD) or 'today': ")
            if ($start.ToLower() -eq 'today') {
                $this.ProjectData.timeline.start = (Get-Date).ToString("yyyy-MM-dd")
            } elseif ($start -match '^\d{4}-\d{2}-\d{2}$') {
                $this.ProjectData.timeline.start = $start
            }
        } elseif (-not $this.ProjectData.timeline.deadline) {
            $end = $this.ReadLine("Enter deadline (YYYY-MM-DD): ")
            if ($end -match '^\d{4}-\d{2}-\d{2}$') {
                $this.ProjectData.timeline.deadline = $end
                $this.NextStep()
            }
        }
    }

    [void] HandleResourcesInput([ConsoleKeyInfo]$key) {
        if (-not $this.ProjectData.resources.budget) {
            $budget = $this.ReadLine("Enter budget (optional): ")
            $this.ProjectData.resources.budget = $budget.Trim()
        } else {
            $this.NextStep()
        }
    }

    [void] HandleReviewInput([ConsoleKeyInfo]$key) {
        $char = $key.KeyChar.ToString().ToLower()

        switch ($char) {
            'c' { $this.NextStep() }
            'e' {
                # Edit mode - go back to basic info
                $this.StepIndex = 2  # basic_info step
                $this.CurrentStep = $this.Steps[$this.StepIndex]
            }
        }
    }

    [string] ReadLine([string]$prompt) {
        Write-PmcStyled -Style 'Body' -Text $prompt -NoNewline
        return [Console]::ReadLine()
    }

    [bool] CanProceedFromCurrentStep() {
        switch ($this.CurrentStep) {
            'template' {
                return -not [string]::IsNullOrWhiteSpace($this.ProjectData.template)
            }
            'basic_info' {
                return (-not [string]::IsNullOrWhiteSpace($this.ProjectData.name)) -and (-not [string]::IsNullOrWhiteSpace($this.ProjectData.description))
            }
            'goals' {
                return $true  # Goals are optional
            }
            'timeline' {
                return -not [string]::IsNullOrWhiteSpace($this.ProjectData.timeline.start)
            }
            'resources' {
                return $true  # Resources are optional
            }
            'review' {
                return $true
            }
            default {
                return $true
            }
        }
        return $true
    }

    [void] NextStep() {
        if ($this.StepIndex -lt ($this.Steps.Count - 1)) {
            $this.StepIndex++
            $this.CurrentStep = $this.Steps[$this.StepIndex]
        }
    }

    [void] CreateProject() {
        # Build PMC command to create project
        $createCmd = "project add '$($this.ProjectData.name)'"

        if ($this.ProjectData.description) {
            $createCmd += " --description '$($this.ProjectData.description)'"
        }

        # Execute project creation
        Invoke-PmcCommand $createCmd

        # Add initial tasks based on goals
        foreach ($goal in $this.ProjectData.goals) {
            $taskCmd = "task add '$goal' @$($this.ProjectData.name.Replace(' ', '_'))"
            if ($this.ProjectData.timeline.deadline) {
                $taskCmd += " due:$($this.ProjectData.timeline.deadline)"
            }
            Invoke-PmcCommand $taskCmd
        }

        # Set project as current context if supported
        try {
            Invoke-PmcCommand "project focus '$($this.ProjectData.name)'"
        } catch {
            # Focus command might not exist in all PMC versions
        }
    }
}

function Invoke-PmcProjectWizard {
    <#
    .SYNOPSIS
    Launches the guided project creation wizard

    .DESCRIPTION
    Opens a full-screen interactive wizard that guides users through
    creating a new project with templates, goals, timelines, and resources.

    .EXAMPLE
    Invoke-PmcProjectWizard
    Launches the project creation wizard
    #>

    try {
        $wizard = [PmcProjectWizard]::new()
        $wizard.Start()

    } catch {
        Write-PmcStyled -Style 'Error' -Text ("Error launching project wizard: {0}" -f $_)
    }
}

# Export for module use
Export-ModuleMember -Function Invoke-PmcProjectWizard

===== END FILE: module/Pmc.Strict/src/ProjectWizard.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/Resolvers.ps1 =====
# Project and argument resolvers for strict engine

Set-StrictMode -Version Latest

function Resolve-Project {
    param(
        [Parameter(Mandatory=$true)] $Data,
        [Parameter(Mandatory=$true)][string] $Name
    )
    if ([string]::IsNullOrWhiteSpace($Name)) { return $null }
    $q = $Name.Trim(); if ($q.StartsWith('@')) { $q = $q.Substring(1) }
    # Exact name match (case-insensitive)
    $p = $Data.projects | Where-Object { try { $_.name -and ($_.name.ToLower() -eq $q.ToLower()) } catch { $false } } | Select-Object -First 1
    if ($p) { return $p }
    # Alias match (case-insensitive)
    foreach ($proj in $Data.projects) {
        try {
            if (Pmc-HasProp $proj 'aliases' -and $proj.aliases) {
                foreach ($alias in $proj.aliases) {
                    if ([string]::IsNullOrWhiteSpace($alias)) { continue }
                    if ($alias.ToLower() -eq $q.ToLower()) { return $proj }
                }
            }
        } catch {
            # Project alias property access failed - skip this project
        }
    }
    return $null
}

===== END FILE: module/Pmc.Strict/src/Resolvers.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/Review.ps1 =====
# Weekly Review workflow

function Start-PmcReview {
    param([PmcCommandContext]$Context)
    Clear-Host
    Show-PmcHeader -Title 'WEEKLY REVIEW' -Icon '🗓'
    Show-PmcTip 'Walk through overdue, today/tomorrow, upcoming, blocked, and projects.'

    $sections = @(
        @{ title='Overdue';        action={ param($ctx) Show-PmcOverdueTasks -Context $ctx } },
        @{ title='Today & Tomorrow'; action={ param($ctx) Show-PmcTodayTasks -Context $ctx; Show-PmcTomorrowTasks -Context $ctx } },
        @{ title='Upcoming (7d)'; action={ param($ctx) Show-PmcUpcomingTasks -Context $ctx } },
        @{ title='Blocked';       action={ param($ctx) Show-PmcBlockedTasks -Context $ctx } },
        @{ title='Next Actions';  action={ param($ctx) Show-PmcNextTasks -Context $ctx } },
        @{ title='Projects';      action={ param($ctx) Show-PmcProjectsView -Context $ctx } }
    )

    foreach ($s in $sections) {
        Show-PmcSeparator -Width 60
        Show-PmcNotice ("Section: {0}" -f $s.title)
        & $s.action $Context
        $resp = Read-Host "Press Enter to continue, or 'q' to quit review"
        if ($resp -match '^(?i)q$') { break }
    }

    Show-PmcSeparator -Width 60
    Show-PmcSuccess 'Review complete.'
}


===== END FILE: module/Pmc.Strict/src/Review.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/Schemas.ps1 =====
# Parameter schemas for strict commands (subset to start)

# Each entry uses a simple schema array: ordered hints and prefixes
$Script:PmcParameterMap = @{
    'task add' = @(
        @{ Name='Text'; Type='FreeText'; Required=$true; Description='Task description' },
        @{ Name='Project'; Prefix='@'; Type='ProjectName' },
        @{ Name='Priority'; Prefix='p'; Type='Priority'; Pattern='^p[1-3]$' },
        @{ Name='Due'; Prefix='due:'; Type='DateString' },
        @{ Name='Tags'; Prefix='#'; Type='TagName'; AllowsMultiple=$true }
    )
    'task done' = @(
        @{ Name='Id'; Type='TaskID'; Required=$true; Pattern='^\d+$' }
    )
    'task list' = @()
    'task delete' = @()
    'task view' = @(
        @{ Name='Id'; Type='TaskID'; Required=$true }
    )
    'task agenda' = @()
    'task week' = @()
    'task month' = @()
    'time log' = @(
        @{ Name='Project'; Prefix='@'; Type='ProjectName'; Required=$true },
        @{ Name='Date'; Type='DateString' },
        @{ Name='Duration'; Type='Duration' },
        @{ Name='Description'; Type='FreeText' }
    )
    'time report' = @(
        @{ Name='Range'; Type='DateRange' },
        @{ Name='Project'; Prefix='@'; Type='ProjectName' }
    )
    'time list' = @()
    'time edit' = @(
        @{ Name='Id'; Type='FreeText'; Required=$true }
    )
    'time delete' = @(
        @{ Name='Id'; Type='FreeText'; Required=$true }
    )
    'timer start' = @(
        @{ Name='Project'; Prefix='@'; Type='ProjectName' },
        @{ Name='Description'; Type='FreeText' }
    )
    'timer stop' = @()
    'timer status' = @()
    'task update' = @(
        @{ Name='Id'; Type='TaskID'; Required=$true },
        @{ Name='Project'; Prefix='@'; Type='ProjectName' },
        @{ Name='Priority'; Prefix='p'; Type='Priority' },
        @{ Name='Due'; Prefix='due:'; Type='DateString' },
        @{ Name='Tags'; Prefix='#'; Type='TagName'; AllowsMultiple=$true },
        @{ Name='Text'; Type='FreeText' }
    )
    'task move' = @(
        @{ Name='Id'; Type='TaskID'; Required=$true },
        @{ Name='Project'; Prefix='@'; Type='ProjectName'; Required=$true }
    )
    'task postpone' = @(
        @{ Name='Id'; Type='TaskID'; Required=$true },
        @{ Name='Delta'; Type='FreeText'; Required=$true }
    )
    'task duplicate' = @(
        @{ Name='Id'; Type='TaskID'; Required=$true }
    )
    'task note' = @(
        @{ Name='Id'; Type='TaskID'; Required=$true },
        @{ Name='Note'; Type='FreeText'; Required=$true }
    )
    'task edit' = @(
        @{ Name='Id'; Type='TaskID'; Required=$true }
    )
    'task search' = @(
        @{ Name='Query'; Type='FreeText'; Required=$true }
    )
    'task priority' = @(
        @{ Name='Level'; Type='FreeText'; Required=$true }
    )

    # Project advanced
    'project add' = @(
        @{ Name='Name'; Type='FreeText'; Required=$true }
    )
    'project list' = @()
    'project stats' = @()
    'project info' = @()
    'project recent' = @()
    'project view' = @(
        @{ Name='Name'; Type='FreeText'; Required=$true }
    )
    'project rename' = @(
        @{ Name='Old'; Type='FreeText'; Required=$true },
        @{ Name='New'; Type='FreeText'; Required=$true }
    )
    'project delete' = @(
        @{ Name='Name'; Type='FreeText'; Required=$true }
    )
    'project archive' = @(
        @{ Name='Name'; Type='FreeText'; Required=$true }
    )
    'project set-fields' = @(
        @{ Name='Project'; Prefix='@'; Type='ProjectName'; Required=$true },
        @{ Name='Fields'; Type='FreeText' }
    )
    'project show-fields' = @(
        @{ Name='Project'; Prefix='@'; Type='ProjectName'; Required=$true }
    )
    'project update' = @(
        @{ Name='Project'; Prefix='@'; Type='ProjectName'; Required=$true },
        @{ Name='Fields'; Type='FreeText' }
    )
    'project edit' = @(
        @{ Name='Project'; Prefix='@'; Type='ProjectName'; Required=$true }
    )

    # Config / Template / Recurring
    'config show' = @()
    'config icons' = @()
    'config set' = @(
        @{ Name='Path'; Type='FreeText'; Required=$true },
        @{ Name='Value'; Type='FreeText'; Required=$true }
    )
    'config edit' = @()

    'template save' = @(
        @{ Name='Name'; Type='FreeText'; Required=$true },
        @{ Name='Body'; Type='FreeText' }
    )
    'template apply' = @(
        @{ Name='Name'; Type='FreeText'; Required=$true }
    )
    'template list' = @()
    'template remove' = @(
        @{ Name='Name'; Type='FreeText'; Required=$true }
    )

    'recurring add' = @(
        @{ Name='Pattern'; Type='FreeText'; Required=$true },
        @{ Name='Body'; Type='FreeText' }
    )
    'recurring list' = @()

    # Dependencies
    'dep add' = @(
        @{ Name='Id'; Type='TaskID'; Required=$true },
        @{ Name='Requires'; Type='FreeText'; Required=$true }
    )
    'dep remove' = @(
        @{ Name='Id'; Type='TaskID'; Required=$true },
        @{ Name='Requires'; Type='FreeText'; Required=$true }
    )
    'dep show' = @(
        @{ Name='Id'; Type='TaskID'; Required=$true }
    )
    'dep graph' = @()

    # Activity / System
    'activity list' = @()
    'system undo' = @()
    'system redo' = @()
    'system backup' = @()
    'system clean' = @()
    'theme reset' = @()
    'theme adjust' = @()
    'excel import' = @()
    'excel bind' = @()
    'excel view' = @()
    'excel latest' = @()
    'import tasks' = @()
    'export tasks' = @()
    'focus set' = @(
        @{ Name='Project'; Type='FreeText'; Required=$true }
    )
    'focus clear' = @()
    'focus status' = @()
    'interactive status' = @()
    'show aliases' = @()
    'show commands' = @()
    'alias add' = @(
        @{ Name='NameAndExpansion'; Type='FreeText'; Required=$true }
    )
    'alias remove' = @(
        @{ Name='Name'; Type='FreeText'; Required=$true }
    )
    'help all' = @()
    'help show' = @()
    'help commands' = @()
    'help examples' = @()
    'help guide' = @()
    'help domain' = @(
        @{ Name='Domain'; Type='FreeText'; Required=$true; Description='Domain name (e.g., task, project, time)' }
    )
    'help command' = @(
        @{ Name='Domain'; Type='FreeText'; Required=$true; Description='Domain name' },
        @{ Name='Action'; Type='FreeText'; Required=$true; Description='Action name' }
    )

    # Views
    'view today' = @()
    'view tomorrow' = @()
    'view overdue' = @()
    'view upcoming' = @()
    'view blocked' = @()
    'view noduedate' = @()
    'view projects' = @()
    'view next' = @()
}

===== END FILE: module/Pmc.Strict/src/Schemas.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/Security.ps1 =====
# Security and Safety Hardening for PMC
# Input validation, path protection, resource limits, and execution safety

Set-StrictMode -Version Latest

# Security system state - now managed by centralized state
# State initialization moved to State.ps1

function Initialize-PmcSecuritySystem {
    <#
    .SYNOPSIS
    Initializes security system based on configuration
    #>

    # Defer config loading to avoid circular dependency during initialization
    # Configuration will be applied later via Update-PmcSecurityFromConfig

    # Default allowed paths if none configured
    $securityState = Get-PmcSecurityState
    if ($securityState.AllowedWritePaths.Count -eq 0) {
        $root = Split-Path (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent) -Parent
        $defaultPaths = @(
            $root
            Join-Path $root 'reports'
            Join-Path $root 'backups'
            Join-Path $root 'exports'
            [System.IO.Path]::GetTempPath()
        )
        Set-PmcState -Section 'Security' -Key 'AllowedWritePaths' -Value $defaultPaths
    }
}

function Test-PmcInputSafety {
    <#
    .SYNOPSIS
    Validates input for potential security issues

    .PARAMETER Input
    User input to validate

    .PARAMETER InputType
    Type of input (command, text, path, etc.)
    #>
    param(
        [Parameter(Mandatory)]
        [AllowEmptyString()]
        [string]$Input,

        [string]$InputType = 'general'
    )

    $securityState = Get-PmcSecurityState
    if (-not $securityState.InputValidationEnabled) { return $true }

    $threats = @()

    try {
        # Check for command injection patterns
        $injectionPatterns = @(
            ';.*(?:rm|del|format|shutdown|reboot)',
            '\|.*(?:nc|netcat|wget|curl|powershell|cmd)',
            '&.*(?:ping|nslookup|whoami|net\s)',
            '`.*(?:Get-.*|Invoke-.*|Start-.*)',
            '\$\(.*(?:Get-.*|Invoke-.*|Remove-.*)\)',
            '(?:>|>>).*(?:/etc/|C:\\Windows\\)',
            '(?:\.\.[\\/]){3,}',  # Path traversal
            '(?i)(?:javascript:|data:|vbscript:)',  # Script injection
            '(?i)(?:<script|<iframe|<object|<embed)',  # HTML injection
            'eval\s*\(',  # Code evaluation
            '(?:exec|system|shell_exec|passthru)\s*\('  # System execution
        )

        foreach ($pattern in $injectionPatterns) {
            if ($Input -match $pattern) {
                $threats += "Potential injection: $pattern"
            }
        }

        # Check for sensitive data exposure
        if ($securityState.SensitiveDataScanEnabled) {
            $sensitivePatterns = @(
                '\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b',  # Credit card
                '\b\d{3}-\d{2}-\d{4}\b',  # SSN
                '\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',  # Email
                '\b[0-9a-fA-F]{32,}\b',  # Long hex (potential secrets)
                '(?i)(password|passwd|secret|token|key)\s*[:=]\s*\S+',  # Credentials
                'BEGIN\s+(RSA\s+)?PRIVATE\s+KEY',  # Private keys
                'sk_live_[0-9a-zA-Z]{24}',  # Stripe keys
                'AIza[0-9A-Za-z\\-_]{35}',  # Google API keys
                'ya29\\.[0-9A-Za-z\\-_]+',  # Google OAuth
                'AKIA[0-9A-Z]{16}'  # AWS access keys
            )

            foreach ($pattern in $sensitivePatterns) {
                if ($Input -match $pattern) {
                    $threats += "Potential sensitive data: $pattern"
                }
            }
        }

        # Input length validation
        if ($Input.Length -gt 10000) {
            $threats += "Input too long (${$Input.Length} chars, max 10000)"
        }

        # Null byte injection
        if ($Input.Contains("`0")) {
            $threats += "Null byte injection detected"
        }

        # Unicode normalization attacks
        if ($Input -match '[\u202A-\u202E\u2066-\u2069]') {
            $threats += "Unicode direction override detected"
        }

        if ($threats.Count -gt 0) {
            Write-PmcDebug -Level 1 -Category 'SECURITY' -Message "Input validation failed" -Data @{ Input = $Input.Substring(0, [Math]::Min($Input.Length, 100)); Threats = $threats; Type = $InputType }
            return $false
        }

        Write-PmcDebug -Level 3 -Category 'SECURITY' -Message "Input validation passed" -Data @{ Length = $Input.Length; Type = $InputType }
        return $true

    } catch {
        Write-PmcDebug -Level 1 -Category 'SECURITY' -Message "Input validation error: $_"
        return $false
    }
}

function Test-PmcPathSafety {
    <#
    .SYNOPSIS
    Validates that a file path is safe to write to

    .PARAMETER Path
    File path to validate

    .PARAMETER Operation
    Operation being performed (read, write, delete)
    #>
    param(
        [Parameter(Mandatory)]
        [string]$Path,

        [string]$Operation = 'write'
    )

    $securityState = Get-PmcSecurityState
    if (-not $securityState.PathWhitelistEnabled) { return $true }

    try {
        # Resolve path to absolute form
        $resolvedPath = $null
        try {
            if ([System.IO.Path]::IsPathRooted($Path)) {
                $resolvedPath = [System.IO.Path]::GetFullPath($Path)
            } else {
                $root = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
                $resolvedPath = [System.IO.Path]::GetFullPath((Join-Path $root $Path))
            }
        } catch {
            Write-PmcDebug -Level 1 -Category 'SECURITY' -Message "Path resolution failed: $_" -Data @{ Path = $Path }
            return $false
        }

        # Check against whitelist for write operations
        if ($Operation -eq 'write' -or $Operation -eq 'delete') {
            $allowed = $false
            foreach ($allowedPath in $securityState.AllowedWritePaths) {
                try {
                    $allowedResolved = [System.IO.Path]::GetFullPath($allowedPath)
                    if ($resolvedPath.StartsWith($allowedResolved, [System.StringComparison]::OrdinalIgnoreCase)) {
                        $allowed = $true
                        break
                    }
                } catch {
                    # Size configuration parsing failed - keep default value
                }
            }

            if (-not $allowed) {
                Write-PmcDebug -Level 1 -Category 'SECURITY' -Message "Path not in whitelist" -Data @{ Path = $resolvedPath; Operation = $Operation; AllowedPaths = $securityState.AllowedWritePaths }
                return $false
            }
        }

        # Check for dangerous paths
        $dangerousPaths = @(
            'C:\Windows\System32',
            'C:\Windows\SysWOW64',
            '/etc/',
            '/bin/',
            '/sbin/',
            '/usr/bin/',
            '/usr/sbin/',
            '/boot/',
            '/sys/',
            '/proc/'
        )

        foreach ($dangerousPath in $dangerousPaths) {
            if ($resolvedPath.StartsWith($dangerousPath, [System.StringComparison]::OrdinalIgnoreCase)) {
                Write-PmcDebug -Level 1 -Category 'SECURITY' -Message "Dangerous path detected" -Data @{ Path = $resolvedPath; DangerousPath = $dangerousPath }
                return $false
            }
        }

        # Log audit trail for file operations
        if ($securityState.AuditLoggingEnabled) {
            Write-PmcDebug -Level 2 -Category 'AUDIT' -Message "File operation approved" -Data @{ Path = $resolvedPath; Operation = $Operation; User = $env:USERNAME }
        }

        return $true

    } catch {
        Write-PmcDebug -Level 1 -Category 'SECURITY' -Message "Path safety check error: $_"
        return $false
    }
}

function Invoke-PmcSecureFileOperation {
    <#
    .SYNOPSIS
    Performs file operations with security checks and resource limits

    .PARAMETER Path
    File path for the operation

    .PARAMETER Operation
    Type of operation (read, write, delete)

    .PARAMETER Content
    Content to write (for write operations)

    .PARAMETER ScriptBlock
    Custom operation to perform within security context
    #>
    param(
        [Parameter(Mandatory)]
        [string]$Path,

        [Parameter(Mandatory)]
        [ValidateSet('read', 'write', 'delete', 'custom')]
        [string]$Operation,

        [string]$Content = '',

        [scriptblock]$ScriptBlock = $null
    )

    # Validate path safety
    if (-not (Test-PmcPathSafety -Path $Path -Operation $Operation)) {
        throw "Path safety validation failed: $Path"
    }

    # Check resource limits
    $securityState = Get-PmcSecurityState
    if ($securityState.ResourceLimitsEnabled) {
        if ($Operation -eq 'write' -and $Content.Length -gt 0) {
            $sizeBytes = [System.Text.Encoding]::UTF8.GetByteCount($Content)
            if ($sizeBytes -gt $securityState.MaxFileSize) {
                throw "Content size ($sizeBytes bytes) exceeds maximum allowed ($($securityState.MaxFileSize) bytes)"
            }
        }

        # Check existing file size for read operations
        if ($Operation -eq 'read' -and (Test-Path $Path)) {
            $fileSize = (Get-Item $Path).Length
            if ($fileSize -gt $securityState.MaxFileSize) {
                throw "File size ($fileSize bytes) exceeds maximum allowed ($($securityState.MaxFileSize) bytes)"
            }
        }
    }

    # Audit log the operation
    if ($securityState.AuditLoggingEnabled) {
        Write-PmcDebug -Level 1 -Category 'AUDIT' -Message "Secure file operation" -Data @{
            Path = $Path
            Operation = $Operation
            ContentSize = $Content.Length
            User = $env:USERNAME
            Timestamp = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
        }
    }

    try {
        # Perform the operation within timeout
        $result = Measure-PmcOperation -Name "SecureFileOp:$Operation" -Category 'SECURITY' -ScriptBlock {
            switch ($Operation) {
                'read' {
                    return Get-Content -Path $Path -Raw -Encoding UTF8
                }
                'write' {
                    return Set-Content -Path $Path -Value $Content -Encoding UTF8
                }
                'delete' {
                    return Remove-Item -Path $Path -Force
                }
                'custom' {
                    if ($ScriptBlock) {
                        return & $ScriptBlock
                    } else {
                        throw "Custom operation requires ScriptBlock parameter"
                    }
                }
            }
        }

        return $result

    } catch {
        Write-PmcDebug -Level 1 -Category 'SECURITY' -Message "Secure file operation failed: $_" -Data @{ Path = $Path; Operation = $Operation }
        throw
    }
}

function Protect-PmcUserInput {
    <#
    .SYNOPSIS
    Sanitizes user input for safe processing

    .PARAMETER Input
    User input to sanitize

    .PARAMETER AllowHtml
    Whether to allow HTML tags (default: false)
    #>
    param(
        [Parameter(Mandatory)]
        [AllowEmptyString()]
        [string]$Input,

        [bool]$AllowHtml = $false
    )

    try {
        $sanitized = $Input

        # Remove null bytes
        $sanitized = $sanitized -replace "`0", ''

        # Remove Unicode direction overrides
        $sanitized = $sanitized -replace '[\u202A-\u202E\u2066-\u2069]', ''

        # Remove or escape HTML if not allowed
        if (-not $AllowHtml) {
            $sanitized = $sanitized -replace '<', '&lt;'
            $sanitized = $sanitized -replace '>', '&gt;'
            $sanitized = $sanitized -replace '"', '&quot;'
            $sanitized = $sanitized -replace "'", '&#39;'
        }

        # Limit length
        if ($sanitized.Length -gt 10000) {
            $sanitized = $sanitized.Substring(0, 10000)
            Write-PmcDebug -Level 2 -Category 'SECURITY' -Message "Input truncated to 10000 characters"
        }

        Write-PmcDebug -Level 3 -Category 'SECURITY' -Message "Input sanitized" -Data @{
            OriginalLength = $Input.Length
            SanitizedLength = $sanitized.Length
            Modified = ($Input -ne $sanitized)
        }

        return $sanitized

    } catch {
        Write-PmcDebug -Level 1 -Category 'SECURITY' -Message "Input sanitization failed: $_"
        return ""
    }
}

function Test-PmcResourceLimits {
    <#
    .SYNOPSIS
    Checks current resource usage against configured limits

    .DESCRIPTION
    Monitors memory usage, execution time, and other resource constraints
    #>

    $securityState = Get-PmcSecurityState
    if (-not $securityState.ResourceLimitsEnabled) { return $true }

    try {
        # Check memory usage
        $process = Get-Process -Id $PID
        $memoryUsage = $process.WorkingSet64

        if ($memoryUsage -gt $securityState.MaxMemoryUsage) {
            Write-PmcDebug -Level 1 -Category 'SECURITY' -Message "Memory limit exceeded" -Data @{
                CurrentUsage = $memoryUsage
                Limit = $securityState.MaxMemoryUsage
                UsagePercent = [Math]::Round(($memoryUsage / $securityState.MaxMemoryUsage) * 100, 2)
            }
            return $false
        }

        Write-PmcDebug -Level 3 -Category 'SECURITY' -Message "Resource limits check passed" -Data @{
            MemoryUsage = $memoryUsage
            MemoryLimit = $securityState.MaxMemoryUsage
        }

        return $true

    } catch {
        Write-PmcDebug -Level 1 -Category 'SECURITY' -Message "Resource limit check failed: $_"
        return $false
    }
}

function Get-PmcSecurityStatus {
    <#
    .SYNOPSIS
    Returns current security system status and configuration
    #>

    $securityState = Get-PmcSecurityState
    return [PSCustomObject]@{
        InputValidationEnabled = $securityState.InputValidationEnabled
        PathWhitelistEnabled = $securityState.PathWhitelistEnabled
        ResourceLimitsEnabled = $securityState.ResourceLimitsEnabled
        SensitiveDataScanEnabled = $securityState.SensitiveDataScanEnabled
        AuditLoggingEnabled = $securityState.AuditLoggingEnabled
        AllowedWritePaths = $securityState.AllowedWritePaths
        MaxFileSize = $securityState.MaxFileSize
        MaxMemoryUsage = $securityState.MaxMemoryUsage
        MaxExecutionTime = $securityState.MaxExecutionTime
        CurrentMemoryUsage = (Get-Process -Id $PID).WorkingSet64
    }
}

function Set-PmcSecurityLevel {
    <#
    .SYNOPSIS
    Configures security level with predefined profiles

    .PARAMETER Level
    Security level: 'permissive', 'balanced', 'strict'
    #>
    param(
        [Parameter(Mandatory)]
        [ValidateSet('permissive', 'balanced', 'strict')]
        [string]$Level
    )

    switch ($Level) {
        'permissive' {
            Update-PmcStateSection -Section 'Security' -Values @{
                InputValidationEnabled = $false
                PathWhitelistEnabled = $false
                ResourceLimitsEnabled = $false
                SensitiveDataScanEnabled = $false
            }
        }
        'balanced' {
            Update-PmcStateSection -Section 'Security' -Values @{
                InputValidationEnabled = $true
                PathWhitelistEnabled = $true
                ResourceLimitsEnabled = $true
                SensitiveDataScanEnabled = $true
                MaxFileSize = 100MB
                MaxMemoryUsage = 500MB
            }
        }
        'strict' {
            Update-PmcStateSection -Section 'Security' -Values @{
                InputValidationEnabled = $true
                PathWhitelistEnabled = $true
                ResourceLimitsEnabled = $true
                SensitiveDataScanEnabled = $true
                AuditLoggingEnabled = $true
                MaxFileSize = 50MB
                MaxMemoryUsage = 256MB
            }
        }
    }

    Write-PmcDebug -Level 1 -Category 'SECURITY' -Message "Security level changed to: $Level" -Data (Get-PmcSecurityState)
}

function Update-PmcSecurityFromConfig {
    <#
    .SYNOPSIS
    Updates security settings from configuration after config provider is ready
    #>
    try {
        $cfg = Get-PmcConfig
        if ($cfg.Security) {
            if ($cfg.Security.AllowedWritePaths) {
                Set-PmcState -Section 'Security' -Key 'AllowedWritePaths' -Value @($cfg.Security.AllowedWritePaths)
            }
            if ($cfg.Security.MaxFileSize) {
                try {
                    $sizeStr = [string]$cfg.Security.MaxFileSize
                    if ($sizeStr -match '^(\d+)(MB|GB)?$') {
                        $num = [int64]$matches[1]
                        $unit = $matches[2]
                        $bytes = switch ($unit) {
                            'GB' { $num * 1GB }
                            'MB' { $num * 1MB }
                            default { $num }
                        }
                        Set-PmcState -Section 'Security' -Key 'MaxFileSize' -Value $bytes
                    }
                } catch {
                    # Size configuration parsing failed - keep default value
                }
            }
            if ($cfg.Security.MaxMemoryUsage) {
                try {
                    $sizeStr = [string]$cfg.Security.MaxMemoryUsage
                    if ($sizeStr -match '^(\d+)(MB|GB)?$') {
                        $num = [int64]$matches[1]
                        $unit = $matches[2]
                        $bytes = switch ($unit) {
                            'GB' { $num * 1GB }
                            'MB' { $num * 1MB }
                            default { $num }
                        }
                        Set-PmcState -Section 'Security' -Key 'MaxMemoryUsage' -Value $bytes
                    }
                } catch {
                    # Size configuration parsing failed - keep default value
                }
            }
            if ($cfg.Security.RequirePathWhitelist -ne $null) {
                Set-PmcState -Section 'Security' -Key 'PathWhitelistEnabled' -Value ([bool]$cfg.Security.RequirePathWhitelist)
            }
            if ($cfg.Security.ScanForSensitiveData -ne $null) {
                Set-PmcState -Section 'Security' -Key 'SensitiveDataScanEnabled' -Value ([bool]$cfg.Security.ScanForSensitiveData)
            }
            if ($cfg.Security.AuditAllFileOps -ne $null) {
                Set-PmcState -Section 'Security' -Key 'AuditLoggingEnabled' -Value ([bool]$cfg.Security.AuditAllFileOps)
            }
            if ($cfg.Security.AllowTemplateExecution -ne $null) {
                Set-PmcState -Section 'Security' -Key 'TemplateExecutionEnabled' -Value ([bool]$cfg.Security.AllowTemplateExecution)
            }
        }
    } catch {
        Write-PmcDebug -Level 1 -Category 'SECURITY' -Message "Failed to load security config: $_"
    }
}

# Note: Security system is initialized by the root orchestrator after config providers are set

===== END FILE: module/Pmc.Strict/src/Security.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/Shortcuts.ps1 =====
# Workflow shortcuts

function Invoke-PmcShortcut {
    param([PmcCommandContext]$Context)
    # Use: "# 3" to view item at index 3 from last task list
    if ($Context.FreeText.Count -lt 1) { Write-Host "Usage: # <index>" -ForegroundColor Yellow; return }
    $tok = $Context.FreeText[0]
    if (-not ($tok -match '^\d+$')) { Write-Host "Invalid index" -ForegroundColor Red; return }
    $n = [int]$tok
    $indexMap = Get-PmcLastTaskListMap
    if (-not $indexMap -or -not $indexMap.ContainsKey($n)) {
        Write-Host "No recent list or index out of range" -ForegroundColor Yellow
        return
    }
    # Delegate to task view
    $ctx = [PmcCommandContext]::new('task','view')
    $ctx.FreeText = @([string]$n)
    Show-PmcTask -Context $ctx
}

===== END FILE: module/Pmc.Strict/src/Shortcuts.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/State.ps1 =====
# Centralized State Management for PMC
# Consolidates all scattered script variables into a thread-safe, organized system

Set-StrictMode -Version Latest

# =============================================================================
# CENTRAL STATE CONTAINER
# =============================================================================

# Single master state object containing all global state
$Script:PmcGlobalState = @{
    # System & Core Configuration
    Config = @{
        ProviderGet = { @{} }
        ProviderSet = $null
    }

    # Security System State
    Security = @{
        InputValidationEnabled = $true
        PathWhitelistEnabled = $true
        ResourceLimitsEnabled = $true
        SensitiveDataScanEnabled = $true
        AuditLoggingEnabled = $true
        TemplateExecutionEnabled = $false
        AllowedWritePaths = @()
        MaxFileSize = 100MB
        MaxMemoryUsage = 500MB
        MaxExecutionTime = 300000  # 5 minutes in milliseconds
    }

    # Debug System State
    Debug = @{
        Level = 0                    # 0=off, 1-3=debug levels
        LogPath = 'debug.log'        # Relative to PMC root
        MaxSize = 10MB              # File size before rotation
        RedactSensitive = $true     # Redact sensitive data
        IncludePerformance = $false # Include timing information
        SessionId = (New-Guid).ToString().Substring(0,8)
        StartTime = Get-Date
    }

    # Display / Theme / UI State
    Display = @{
        Theme = @{ PaletteName='default'; Hex='#33aaff'; TrueColor=$true; HighContrast=$false; ColorBlindMode='none' }
        Icons = @{ Mode='emoji' }
        Capabilities = @{ AnsiSupport=$true; TrueColorSupport=$true; IsTTY=$true; NoColor=$false; Platform='unknown' }
        Styles = @{}
    }

    # Help and UI System State
    HelpUI = @{
        # Interactive help browser state
        HelpState = @{
            CurrentCategory = 'All'
            SelectedCommand = 0
            SearchFilter = ''
            ShowExamples = $false
            ViewMode = 'Categories'  # Categories, Commands, Examples, Search
        }
        # Command categories for organized browsing (this will be populated from CommandMap)
        CommandCategories = @{}
    }

    # Interactive Editor State
    Interactive = @{
        Editor = $null              # Will be initialized with PmcEditorState instance
        CompletionCache = @{}       # Completion caching for performance
        CompletionInfoMap = @{}     # Completion info mapping for interactive system
        GhostTextEnabled = $true    # Enable/disable ghost text feature
    }

    # Focus / Context State
    Focus = @{
        Current = 'inbox'
    }

    # Undo/Redo System State
    UndoRedo = @{
        UndoStack = @()
        RedoStack = @()
        MaxUndoSteps = 5
        DataCache = $null           # Cached data for performance
    }

    # Task and Time Mapping State (consolidated from multiple files)
    ViewMappings = @{
        LastTaskListMap = @{}       # Maps display numbers to task IDs
        LastTimeListMap = @{}       # Maps display numbers to time entry IDs
    }

    # Command System State (schemas, maps, metadata)
    Commands = @{
        ParameterMap = @{}          # Parameter schemas from Schemas.ps1
        CommandMap = @{}            # Command mappings from CommandMap.ps1
        ShortcutMap = @{}           # Shortcut mappings from CommandMap.ps1
        CommandMeta = @{}           # Command metadata from CommandMap.ps1
    }

    # State synchronization lock
    _Lock = $false
}

# Convenience: repo root path
function Get-PmcRootPath {
    try {
        return (Split-Path (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent) -Parent)
    } catch { return (Get-Location).Path }
}

# =============================================================================
# THREAD-SAFE STATE ACCESS FUNCTIONS
# =============================================================================

function Get-PmcState {
    <#
    .SYNOPSIS
    Gets a specific state section or the entire state object

    .PARAMETER Section
    The state section to retrieve (Config, Security, Debug, etc.)

    .PARAMETER Key
    Optional specific key within the section

    .EXAMPLE
    Get-PmcState -Section 'Security'
    Get-PmcState -Section 'Debug' -Key 'Level'
    #>
    [CmdletBinding()]
    param(
        [string]$Section,
        [string]$Key
    )

    # Acquire lock to ensure a consistent read snapshot
    while ($Script:PmcGlobalState._Lock) { Start-Sleep -Milliseconds 1 }
    $Script:PmcGlobalState._Lock = $true

    try {
        if (-not $Section) {
            # Return a shallow clone of the entire state without exposing the lock directly
            $snapshot = @{}
            foreach ($k in $Script:PmcGlobalState.Keys) {
                if ($k -eq '_Lock') { continue }
                $val = $Script:PmcGlobalState[$k]
                if ($val -is [hashtable]) { $snapshot[$k] = $val.Clone() } else { $snapshot[$k] = $val }
            }
            return $snapshot
        }

        if (-not $Script:PmcGlobalState.ContainsKey($Section)) {
            Write-Warning "State section '$Section' does not exist"
            return $null
        }

        $sectionState = $Script:PmcGlobalState[$Section]

        if ($Key) {
            if ($sectionState -is [hashtable] -and $sectionState.ContainsKey($Key)) {
                return $sectionState[$Key]
            } else {
                Write-Warning "State key '$Key' does not exist in section '$Section'"
                return $null
            }
        }

        # Return a copy to avoid external mutation of shared state
        if ($sectionState -is [hashtable]) { return $sectionState.Clone() }
        return $sectionState
    }
    finally {
        $Script:PmcGlobalState._Lock = $false
    }
}

function Set-PmcState {
    <#
    .SYNOPSIS
    Sets a value in the centralized state system

    .PARAMETER Section
    The state section to modify

    .PARAMETER Key
    The key within the section to set

    .PARAMETER Value
    The value to set

    .PARAMETER Merge
    If true, merge hashtable values instead of replacing

    .EXAMPLE
    Set-PmcState -Section 'Debug' -Key 'Level' -Value 2
    Set-PmcState -Section 'Security' -Key 'MaxFileSize' -Value 200MB
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$Section,

        [Parameter(Mandatory=$true)]
        [string]$Key,

        [Parameter(Mandatory=$true)]
        $Value,

        [switch]$Merge
    )

    # Acquire lock for thread safety
    while ($Script:PmcGlobalState._Lock) {
        Start-Sleep -Milliseconds 1
    }
    $Script:PmcGlobalState._Lock = $true

    try {
        if (-not $Script:PmcGlobalState.ContainsKey($Section)) {
            Write-Warning "State section '$Section' does not exist"
            return
        }

        $sectionState = $Script:PmcGlobalState[$Section]

        if ($Merge -and $sectionState[$Key] -is [hashtable] -and $Value -is [hashtable]) {
            # Merge hashtables
            foreach ($k in $Value.Keys) {
                $sectionState[$Key][$k] = $Value[$k]
            }
        } else {
            # Direct assignment
            $sectionState[$Key] = $Value
        }

        # Debug logging removed to avoid circular dependency during initialization
    }
    finally {
        $Script:PmcGlobalState._Lock = $false
    }
}

# Convenience helpers for common view mapping state
function Get-PmcLastTaskListMap {
    $map = Get-PmcState -Section 'ViewMappings' -Key 'LastTaskListMap'
    if (-not $map) { $map = @{}; Set-PmcState -Section 'ViewMappings' -Key 'LastTaskListMap' -Value $map }
    return $map
}

function Set-PmcLastTaskListMap {
    param([hashtable]$Map)
    if (-not $Map) { $Map = @{} }
    Set-PmcState -Section 'ViewMappings' -Key 'LastTaskListMap' -Value $Map
}

function Get-PmcLastTimeListMap {
    $map = Get-PmcState -Section 'ViewMappings' -Key 'LastTimeListMap'
    if (-not $map) { $map = @{}; Set-PmcState -Section 'ViewMappings' -Key 'LastTimeListMap' -Value $map }
    return $map
}

function Set-PmcLastTimeListMap {
    param([hashtable]$Map)
    if (-not $Map) { $Map = @{} }
    Set-PmcState -Section 'ViewMappings' -Key 'LastTimeListMap' -Value $Map
}

function Update-PmcStateSection {
    <#
    .SYNOPSIS
    Updates an entire state section

    .PARAMETER Section
    The state section to update

    .PARAMETER Values
    Hashtable of values to update in the section

    .PARAMETER Replace
    If true, replace entire section; if false, merge values

    .EXAMPLE
    Update-PmcStateSection -Section 'Security' -Values @{ MaxFileSize = 200MB; PathWhitelistEnabled = $false }
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$Section,

        [Parameter(Mandatory=$true)]
        [hashtable]$Values,

        [switch]$Replace
    )

    # Acquire lock for thread safety
    while ($Script:PmcGlobalState._Lock) {
        Start-Sleep -Milliseconds 1
    }
    $Script:PmcGlobalState._Lock = $true

    try {
        if (-not $Script:PmcGlobalState.ContainsKey($Section)) {
            Write-Warning "State section '$Section' does not exist"
            return
        }

        if ($Replace) {
            $Script:PmcGlobalState[$Section] = $Values
        } else {
            foreach ($key in $Values.Keys) {
                $Script:PmcGlobalState[$Section][$key] = $Values[$key]
            }
        }

        # Debug logging removed to avoid circular dependency during initialization
    }
    finally {
        $Script:PmcGlobalState._Lock = $false
    }
}

# =============================================================================
# BACKWARD COMPATIBILITY LAYER
# =============================================================================

# These functions provide backward compatibility for existing code
# They map old script variable access to the new centralized state

function Get-PmcConfigProviders {
    $config = Get-PmcState -Section 'Config'
    return @{
        Get = $config.ProviderGet
        Set = $config.ProviderSet
    }
}

function Set-PmcConfigProviders {
    param($Get, $Set)
    Set-PmcState -Section 'Config' -Key 'ProviderGet' -Value $Get
    if ($Set) {
        Set-PmcState -Section 'Config' -Key 'ProviderSet' -Value $Set
    }
}

function Get-PmcSecurityState {
    return Get-PmcState -Section 'Security'
}

function Get-PmcDebugState {
    return Get-PmcState -Section 'Debug'
}

function Get-PmcHelpState {
    return Get-PmcState -Section 'HelpUI' -Key 'HelpState'
}

function Get-PmcCommandCategories {
    return Get-PmcState -Section 'HelpUI' -Key 'CommandCategories'
}

function Get-PmcTaskListMap {
    return Get-PmcState -Section 'ViewMappings' -Key 'LastTaskListMap'
}

function Set-PmcTaskListMap {
    param([hashtable]$Map)
    Set-PmcState -Section 'ViewMappings' -Key 'LastTaskListMap' -Value $Map
}

function Get-PmcTimeListMap {
    return Get-PmcState -Section 'ViewMappings' -Key 'LastTimeListMap'
}

function Set-PmcTimeListMap {
    param([hashtable]$Map)
    Set-PmcState -Section 'ViewMappings' -Key 'LastTimeListMap' -Value $Map
}

function Get-PmcUndoRedoState {
    return Get-PmcState -Section 'UndoRedo'
}

function Get-PmcInteractiveState {
    return Get-PmcState -Section 'Interactive'
}

function Get-PmcCommandMaps {
    return Get-PmcState -Section 'Commands'
}

# =============================================================================
# STATE INITIALIZATION AND MIGRATION
# =============================================================================

function Initialize-PmcCentralizedState {
    <#
    .SYNOPSIS
    Initializes the centralized state system and migrates existing scattered state
    #>
    [CmdletBinding()]
    param()

    # Debug logging removed to avoid circular dependency during initialization

    # Initialize Interactive Editor if not already done
    if (-not (Get-PmcState -Section 'Interactive' -Key 'Editor')) {
        # Import the PmcEditorState class if it exists
        try {
            $editorState = [PmcEditorState]::new()
            Set-PmcState -Section 'Interactive' -Key 'Editor' -Value $editorState
            # Debug logging removed
        } catch {
            # Debug logging removed
        }
    }

    # Migrate any existing command maps from the old system
    try {
        if (Get-Variable -Name 'PmcCommandMap' -Scope Script -ErrorAction SilentlyContinue) {
            $oldCommandMap = Get-Variable -Name 'PmcCommandMap' -Scope Script -ValueOnly
            Set-PmcState -Section 'Commands' -Key 'CommandMap' -Value $oldCommandMap
            # Debug logging removed
        }

        if (Get-Variable -Name 'PmcParameterMap' -Scope Script -ErrorAction SilentlyContinue) {
            $oldParameterMap = Get-Variable -Name 'PmcParameterMap' -Scope Script -ValueOnly
            Set-PmcState -Section 'Commands' -Key 'ParameterMap' -Value $oldParameterMap
            # Debug logging removed
        }
    } catch {
        # Debug logging removed
    }

    # Debug logging removed
}

function Reset-PmcState {
    <#
    .SYNOPSIS
    Resets the entire state system to defaults (useful for testing)
    #>
    [CmdletBinding()]
    param()

    $Script:PmcGlobalState._Lock = $true
    try {
        # Reset to initial state structure
        $Script:PmcGlobalState = @{
            Config = @{
                ProviderGet = { @{} }
                ProviderSet = $null
            }
            Security = @{
                InputValidationEnabled = $true
                PathWhitelistEnabled = $true
                ResourceLimitsEnabled = $true
                SensitiveDataScanEnabled = $true
                AuditLoggingEnabled = $true
                TemplateExecutionEnabled = $false
                AllowedWritePaths = @()
                MaxFileSize = 100MB
                MaxMemoryUsage = 500MB
                MaxExecutionTime = 300000
            }
            Debug = @{
                Level = 0
                LogPath = 'debug.log'
                MaxSize = 10MB
                RedactSensitive = $true
                IncludePerformance = $false
                SessionId = (New-Guid).ToString().Substring(0,8)
                StartTime = Get-Date
            }
            HelpUI = @{
                HelpState = @{
                    CurrentCategory = 'All'
                    SelectedCommand = 0
                    SearchFilter = ''
                    ShowExamples = $false
                    ViewMode = 'Categories'
                }
                CommandCategories = @{}
            }
            Interactive = @{
                Editor = $null
                CompletionCache = @{}
                GhostTextEnabled = $true
            }
            UndoRedo = @{
                UndoStack = @()
                RedoStack = @()
                MaxUndoSteps = 5
                DataCache = $null
            }
            ViewMappings = @{
                LastTaskListMap = @{}
                LastTimeListMap = @{}
            }
            Commands = @{
                ParameterMap = @{}
                CommandMap = @{}
                ShortcutMap = @{}
                CommandMeta = @{}
            }
            _Lock = $false
        }

        # Debug logging removed
    }
    finally {
        $Script:PmcGlobalState._Lock = $false
    }
}

function Get-PmcStateSnapshot {
    <#
    .SYNOPSIS
    Gets a snapshot of the current state for debugging or backup purposes
    #>
    [CmdletBinding()]
    param()

    # Create a deep copy of the state (excluding the lock)
    $snapshot = @{}
    foreach ($section in $Script:PmcGlobalState.Keys) {
        if ($section -ne '_Lock') {
            $snapshot[$section] = $Script:PmcGlobalState[$section].Clone()
        }
    }

    return $snapshot
}

# =============================================================================
# MODULE INITIALIZATION
# =============================================================================

# Auto-initialize the state system when this module is loaded
Initialize-PmcCentralizedState

# Debug logging removed to avoid circular dependency during initialization

===== END FILE: module/Pmc.Strict/src/State.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/Storage.ps1 =====
# Storage and schema for strict engine (self-contained)

Set-StrictMode -Version Latest

function Add-PmcUndoEntry {
    param(
        [string]$file,
        [object]$data
    )

    # Create undo entry for the current data state before modification
    try {
        if (-not (Test-Path $file)) {
            # No existing file to backup
            return
        }

        $undoFile = $file + '.undo'
        $currentContent = Get-Content $file -Raw -ErrorAction SilentlyContinue

        if ($currentContent) {
            # Save current state for undo capability
            $undoEntry = @{
                timestamp = (Get-Date).ToString('o')
                file = $file
                content = $currentContent
            }

            $undoJson = $undoEntry | ConvertTo-Json -Compress
            Add-Content -Path $undoFile -Value $undoJson -ErrorAction SilentlyContinue

            # Keep only last 3 undo entries to prevent file growth
            $undoLines = Get-Content $undoFile -ErrorAction SilentlyContinue
            if ($undoLines -and $undoLines.Count -gt 3) {
                $undoLines[-3..-1] | Set-Content $undoFile -ErrorAction SilentlyContinue
            }
        }
    } catch {
        # Undo functionality is non-critical, don't fail the main operation
        Write-PmcDebug -Level 2 -Category 'STORAGE' -Message "Undo entry creation failed: $_"
    }
}

function Get-PmcTaskFilePath {
    $cfg = Get-PmcConfig
    $path = $null
    try { if ($cfg.Paths -and $cfg.Paths.TaskFile) { $path = [string]$cfg.Paths.TaskFile } } catch {
        # Configuration access failed - use default path
    }
    if (-not $path -or [string]::IsNullOrWhiteSpace($path)) {
        # Default to pmc/tasks.json (three levels up from module dir)
        $root = Split-Path (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent) -Parent
        $path = Join-Path $root 'tasks.json'
    }
    return $path
}

function Initialize-PmcDataSchema {
    param($data)
    if (-not $data) { return $data }
    if (-not $data.PSObject.Properties['schema_version']) { $data | Add-Member -NotePropertyName schema_version -NotePropertyValue 1 -Force }
    foreach ($k in @('tasks','deleted','completed','projects','timelogs','activityLog','templates','recurringTemplates','aliases')) {
        if (-not $data.PSObject.Properties[$k] -or -not $data.$k) { $data | Add-Member -NotePropertyName $k -NotePropertyValue @() -Force }
    }
    # Normalize aliases to hashtable for reliable access
    try {
        if ($data.PSObject.Properties['aliases']) {
            $al = $data.aliases
            if ($al -is [pscustomobject]) {
                $ht = @{}
                foreach ($p in $al.PSObject.Properties) { $ht[$p.Name] = $p.Value }
                $data.aliases = $ht
            } elseif ($al -is [array]) {
                # Convert array of pairs into hashtable if possible
                $ht = @{}
                foreach ($item in $al) { try { $ht[$item.Name] = $item.Value } catch {
                    # Array item property access failed - skip this item
                } }
                $data.aliases = $ht
            } elseif (-not ($al -is [hashtable])) {
                $data.aliases = @{}
            }
        } else {
            $data | Add-Member -NotePropertyName aliases -NotePropertyValue @{} -Force
        }
    } catch {
        # Data schema normalization failed - continue with what we have
    }
    if (-not $data.PSObject.Properties['currentContext'] -or -not $data.currentContext) { $data | Add-Member -NotePropertyName currentContext -NotePropertyValue 'inbox' -Force }
    if (-not $data.PSObject.Properties['preferences']) { $data | Add-Member -NotePropertyName preferences -NotePropertyValue @{ autoBackup = $true } -Force }

    # Normalize task properties to prevent "property cannot be found" errors
    if ($data.tasks -and $data.tasks.Count -gt 0) {
        foreach ($task in $data.tasks) {
            if ($null -eq $task) { continue }
            try {
                # Ensure critical properties exist with defaults
                if (-not (Pmc-HasProp $task 'depends')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'depends' -NotePropertyValue @() -Force }
                if (-not (Pmc-HasProp $task 'tags')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'tags' -NotePropertyValue @() -Force }
                if (-not (Pmc-HasProp $task 'notes')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'notes' -NotePropertyValue @() -Force }
                if (-not (Pmc-HasProp $task 'recur')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'recur' -NotePropertyValue $null -Force }
                if (-not (Pmc-HasProp $task 'estimatedMinutes')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'estimatedMinutes' -NotePropertyValue $null -Force }
                if (-not (Pmc-HasProp $task 'status')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'status' -NotePropertyValue 'pending' -Force }
                if (-not (Pmc-HasProp $task 'priority')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'priority' -NotePropertyValue 0 -Force }
                if (-not (Pmc-HasProp $task 'project')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'project' -NotePropertyValue 'inbox' -Force }
                if (-not (Pmc-HasProp $task 'due')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'due' -NotePropertyValue $null -Force }
                if (-not (Pmc-HasProp $task 'nextSuggestedCount')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'nextSuggestedCount' -NotePropertyValue 3 -Force }
                if (-not (Pmc-HasProp $task 'lastNextShown')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'lastNextShown' -NotePropertyValue (Get-Date).ToString('yyyy-MM-dd') -Force }
                if (-not (Pmc-HasProp $task 'created')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'created' -NotePropertyValue (Get-Date).ToString('yyyy-MM-dd HH:mm:ss') -Force }
            } catch {
                # Individual task property normalization failed - continue
            }
        }
    }

    # Normalize project properties
    if ($data.projects -and $data.projects.Count -gt 0) {
        foreach ($project in $data.projects) {
            if ($null -eq $project) { continue }
            try {
                if (-not (Pmc-HasProp $project 'name')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'name' -NotePropertyValue '' -Force }
                if (-not (Pmc-HasProp $project 'description')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'description' -NotePropertyValue '' -Force }
                if (-not (Pmc-HasProp $project 'aliases')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'aliases' -NotePropertyValue @() -Force }
                if (-not (Pmc-HasProp $project 'created')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'created' -NotePropertyValue (Get-Date).ToString('yyyy-MM-dd HH:mm:ss') -Force }
                if (-not (Pmc-HasProp $project 'isArchived')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'isArchived' -NotePropertyValue $false -Force }
                if (-not (Pmc-HasProp $project 'color')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'color' -NotePropertyValue 'Gray' -Force }
                if (-not (Pmc-HasProp $project 'icon')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'icon' -NotePropertyValue '📁' -Force }
                if (-not (Pmc-HasProp $project 'sortOrder')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'sortOrder' -NotePropertyValue 0 -Force }
                # Extended fields (t2 parity)
                if (-not (Pmc-HasProp $project 'ID1')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'ID1' -NotePropertyValue '' -Force }
                if (-not (Pmc-HasProp $project 'ID2')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'ID2' -NotePropertyValue '' -Force }
                if (-not (Pmc-HasProp $project 'ProjFolder')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'ProjFolder' -NotePropertyValue '' -Force }
                if (-not (Pmc-HasProp $project 'AssignedDate')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'AssignedDate' -NotePropertyValue '' -Force }
                if (-not (Pmc-HasProp $project 'DueDate')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'DueDate' -NotePropertyValue '' -Force }
                if (-not (Pmc-HasProp $project 'BFDate')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'BFDate' -NotePropertyValue '' -Force }
                if (-not (Pmc-HasProp $project 'CAAName')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'CAAName' -NotePropertyValue '' -Force }
                if (-not (Pmc-HasProp $project 'RequestName')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'RequestName' -NotePropertyValue '' -Force }
                if (-not (Pmc-HasProp $project 'T2020')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'T2020' -NotePropertyValue '' -Force }
            } catch {
                # Individual project property normalization failed - continue
            }
        }
    }

    return $data
}

# Normalize data to consistent shapes (fail-fast for irrecoverable cases)
function Normalize-PmcData {
    param($data)
    if (-not $data) { throw 'Data is null' }
    foreach ($k in @('tasks','deleted','completed','projects','timelogs','activityLog','templates','recurringTemplates')) {
        if (-not (Pmc-HasProp $data $k) -or -not $data.$k) { $data | Add-Member -NotePropertyName $k -NotePropertyValue @() -Force }
        elseif (-not ($data.$k -is [System.Collections.IEnumerable])) { throw "Data section '$k' is not a list" }
    }
    # Coerce hashtable entries to PSCustomObject for tasks/projects/timelogs
    $coerce = {
        param($arrRef)
        $new = @()
        foreach ($it in @($arrRef)) {
            if ($null -eq $it) { continue }
            if ($it -is [hashtable]) { $new += [pscustomobject]$it }
            else { $new += $it }
        }
        return ,$new
    }
    $data.tasks = & $coerce $data.tasks
    $data.projects = & $coerce $data.projects
    $data.timelogs = & $coerce $data.timelogs
    return $data
}

function Get-PmcData {
    $file = Get-PmcTaskFilePath
    if (-not (Test-Path $file)) {
        $root = Split-Path $file -Parent
        try { if (-not (Test-Path $root)) { New-Item -ItemType Directory -Path $root -Force | Out-Null } } catch {
            # Directory creation failed - may cause subsequent save failures
        }
        $init = @{
            tasks=@(); deleted=@(); completed=@(); timelogs=@(); activityLog=@(); projects=@(@{ name='inbox'; description='Default inbox'; aliases=@(); created=(Get-Date).ToString('yyyy-MM-dd HH:mm:ss') });
            currentContext='inbox'; schema_version=1; preferences=@{ autoBackup=$true }
        } | ConvertTo-Json -Depth 10
        $init | Set-Content -Path $file -Encoding UTF8
    }
    # Robust load with recovery from .tmp or .bakN
    try {
        $raw = Get-Content $file -Raw
        $data = $raw | ConvertFrom-Json
        # Coerce collections before adding default properties to ensure NoteProperty attaches to PSCustomObject
        $data = Normalize-PmcData $data
        $data = Initialize-PmcDataSchema $data
        return $data
    } catch {
        # Try .tmp
        $tmp = "$file.tmp"
        try {
            if (Test-Path $tmp) {
                $raw = Get-Content $tmp -Raw
                $data = $raw | ConvertFrom-Json
                Write-Host "Recovered data from tmp" -ForegroundColor Yellow
                return (Initialize-PmcDataSchema $data)
            }
        } catch {
            # Temporary file recovery failed - try backup files
        }
        # Try rotating backups .bak1..bak9
        for ($i=1; $i -le 9; $i++) {
            $bak = "$file.bak$i"
            if (-not (Test-Path $bak)) { continue }
            try {
                $raw = Get-Content $bak -Raw
                $data = $raw | ConvertFrom-Json
                Write-Host ("Recovered data from backup: {0}" -f (Split-Path $bak -Leaf)) -ForegroundColor Yellow
                return (Initialize-PmcDataSchema $data)
            } catch {
                # Backup file recovery failed - try next backup
            }
        }
        throw "Failed to load or recover data"
    }
}

function Get-PmcSafePath {
    param([string]$Path)
    $cfg = Get-PmcConfig
    $strict = $true; $allowed=@()
    try { if ($cfg.Behavior -and $cfg.Behavior.SafePathsStrict -ne $null) { $strict = [bool]$cfg.Behavior.SafePathsStrict } } catch {
        # Configuration access failed - use default strict mode
    }
    try { if ($cfg.Paths -and $cfg.Paths.AllowedWriteDirs) { $allowed = @($cfg.Paths.AllowedWriteDirs) } } catch {
        # Configuration access failed - use empty allowed paths list
    }
    $root = Split-Path (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent) -Parent
    if ([string]::IsNullOrWhiteSpace($Path)) { return (Join-Path $root 'output.txt') }
    try {
        $baseFull = [System.IO.Path]::GetFullPath($root)
        $isAbs = [System.IO.Path]::IsPathRooted($Path)
        if (-not $isAbs) {
            $combined = Join-Path $root $Path
            $full = [System.IO.Path]::GetFullPath($combined)
            if (-not $full.StartsWith($baseFull, [System.StringComparison]::OrdinalIgnoreCase)) {
                return (Join-Path $baseFull ([System.IO.Path]::GetFileName($Path)))
            }
            return $full
        }
        # Absolute path
        $fullAbs = [System.IO.Path]::GetFullPath($Path)
        if ($fullAbs.StartsWith($baseFull, [System.StringComparison]::OrdinalIgnoreCase)) { return $fullAbs }
        if (-not $strict) { return $fullAbs }
        foreach ($dir in $allowed) {
            if ([string]::IsNullOrWhiteSpace($dir)) { continue }
            # Allowlist entries are relative to base unless absolute
            $dirFull = if ([System.IO.Path]::IsPathRooted($dir)) { [System.IO.Path]::GetFullPath($dir) } else { [System.IO.Path]::GetFullPath((Join-Path $root $dir)) }
            if ($fullAbs.StartsWith($dirFull, [System.StringComparison]::OrdinalIgnoreCase)) { return $fullAbs }
        }
        return (Join-Path $baseFull ([System.IO.Path]::GetFileName($Path)))
    } catch {
        return (Join-Path $root ([System.IO.Path]::GetFileName($Path)))
    }
}

function Lock-PmcFile {
    param([string]$file)
    $lockPath = $file + '.lock'
    $maxRetries = 20; $delay = 100
    for ($i=0; $i -lt $maxRetries; $i++) {
        try { return [System.IO.File]::Open($lockPath, [System.IO.FileMode]::OpenOrCreate, [System.IO.FileAccess]::ReadWrite, [System.IO.FileShare]::None) } catch {
            # File lock acquisition failed - will retry
        }
        try { $info = Get-Item $lockPath -ErrorAction SilentlyContinue; if ($info -and ((Get-Date) - $info.LastWriteTime).TotalMinutes -gt 2) { Remove-Item $lockPath -Force -ErrorAction SilentlyContinue } } catch {
            # Stale lock cleanup failed - continue trying
        }
        Start-Sleep -Milliseconds $delay
    }
    throw "Could not acquire lock for $file"
}

function Unlock-PmcFile { param($lock,$file) try { if ($lock) { $lock.Close() } } catch {
        # Lock file close failed - file handle may remain open
    } ; try { Remove-Item ($file + '.lock') -Force -ErrorAction SilentlyContinue } catch {
        # Lock file removal failed - may cause future lock conflicts
    } }

function Invoke-PmcBackupRotation {
    param([string]$file,[int]$count=3)
    # Make backup retention configurable via Behavior.MaxBackups
    try { $cfg=Get-PmcConfig; if ($cfg.Behavior -and $cfg.Behavior.MaxBackups) { $count = [int]$cfg.Behavior.MaxBackups } } catch {
        # Configuration access failed - use default backup count
    }
    for ($i=$count-1; $i -ge 1; $i--) {
        $src = "$file.bak$i"; $dst = "$file.bak$($i+1)"; if (Test-Path $src) { Move-Item -Force $src $dst }
    }
    if (Test-Path $file) { Copy-Item $file "$file.bak1" -Force }
}

function Add-PmcUndoState {
    param([string]$file,[object]$data)
    $undoFile = $file + '.undo'
    $stack = @(); if (Test-Path $undoFile) { try { $stack = Get-Content $undoFile -Raw | ConvertFrom-Json } catch { $stack=@() } }
    $stack += ($data | ConvertTo-Json -Depth 10)
    $max = 10; try { $cfg=Get-PmcConfig; if ($cfg.Behavior -and $cfg.Behavior.MaxUndoLevels) { $max = [int]$cfg.Behavior.MaxUndoLevels } } catch {
        # Configuration access failed - use default undo levels
    }
    if (@($stack).Count -gt $max) { $stack = $stack[-$max..-1] }
    $stack | ConvertTo-Json -Depth 10 | Set-Content $undoFile -Encoding UTF8
}

function Get-PmcUndoRedoStacks {
    param([string]$file)
    $undoFile = $file + '.undo'
    $redoFile = $file + '.redo'
    $undo = @(); $redo = @()
    if (Test-Path $undoFile) { try { $undo = Get-Content $undoFile -Raw | ConvertFrom-Json } catch { $undo=@() } }
    if (Test-Path $redoFile) { try { $redo = Get-Content $redoFile -Raw | ConvertFrom-Json } catch { $redo=@() } }
    return @{ undo=$undo; redo=$redo; undoFile=$undoFile; redoFile=$redoFile }
}

function Save-PmcUndoRedoStacks {
    param([array]$Undo,[array]$Redo,[string]$UndoFile,[string]$RedoFile)
    try { $Undo | ConvertTo-Json -Depth 10 | Set-Content $UndoFile -Encoding UTF8 } catch {
        # Undo stack save failed - undo functionality may be impaired
    }
    try { $Redo | ConvertTo-Json -Depth 10 | Set-Content $RedoFile -Encoding UTF8 } catch {
        # Redo stack save failed - redo functionality may be impaired
    }
}

function Add-PmcActivity {
    param([object]$data,[string]$action)
    if (-not $data.PSObject.Properties['activityLog']) { $data | Add-Member -NotePropertyName activityLog -NotePropertyValue @() -Force }
    $data.activityLog += @{ timestamp=(Get-Date).ToString('yyyy-MM-dd HH:mm:ss'); action=$action; user=$env:USERNAME }
    if (@($data.activityLog).Count -gt 1000) { $data.activityLog = $data.activityLog[-1000..-1] }
}

function Save-PmcData {
    param(
        [Parameter(Mandatory=$true)][object]$data,
        [string]$Action=''
    )

    # Check resource limits before proceeding
    if (-not (Test-PmcResourceLimits)) {
        throw "Resource limits exceeded - cannot save data"
    }

    $cfg = Get-PmcConfig; $whatIf=$false; try { if ($cfg.Behavior -and $cfg.Behavior.WhatIf) { $whatIf = [bool]$cfg.Behavior.WhatIf } } catch {
        # Configuration access failed - whatIf remains false
    }
    if ($whatIf) { Write-Host 'WhatIf: changes not saved' -ForegroundColor DarkYellow; return }

    $file = Get-PmcTaskFilePath

    # Validate file path security
    if (-not (Test-PmcPathSafety -Path $file -Operation 'write')) {
        throw "Path safety validation failed for: $file"
    }

    Write-PmcDebugStorage -Operation 'SaveData' -File $file -Data @{ Action = $Action; WhatIf = $whatIf }

    $lock = $null
    try {
        $lock = Lock-PmcFile $file

        Write-PmcDebugStorage -Operation 'AcquiredLock' -File $file

        Invoke-PmcBackupRotation -file $file -count 3
        Add-PmcUndoEntry -file $file -data $data
        if ($Action) { Add-PmcActivity -data $data -action $Action }

        $tmp = "$file.tmp"

        # Use secure file operation for the actual write
        $jsonContent = $data | ConvertTo-Json -Depth 10

        # Validate content safety
        if (-not (Test-PmcInputSafety -Input $jsonContent -InputType 'json')) {
            Write-PmcDebug -Level 1 -Category 'SECURITY' -Message "Data content failed safety validation"
        }

        Invoke-PmcSecureFileOperation -Path $tmp -Operation 'write' -Content $jsonContent

        Move-Item -Force -Path $tmp -Destination $file
        if (Test-Path $tmp) { Remove-Item $tmp -Force -ErrorAction SilentlyContinue }

        Write-PmcDebugStorage -Operation 'SaveCompleted' -File $file -Data @{ Size = $jsonContent.Length }

    } catch {
        Write-PmcDebugStorage -Operation 'SaveFailed' -File $file -Data @{ Error = $_.ToString() }
        Write-Host "Failed to save data: $_" -ForegroundColor Red
        throw
    } finally {
        Unlock-PmcFile $lock $file
    }
}

function Get-PmcDataAlias { return Get-PmcData }

function Get-PmcNextTaskId {
    param($data)
    try { $ids = @($data.tasks | ForEach-Object { try { [int]$_.id } catch { 0 } }); $max = ($ids | Measure-Object -Maximum).Maximum; return ([int]$max + 1) } catch { return 1 }
}

function Get-PmcNextTimeLogId {
    param($data)
    try { $ids = @($data.timelogs | ForEach-Object { try { [int]$_.id } catch { 0 } }); $max = ($ids | Measure-Object -Maximum).Maximum; return ([int]$max + 1) } catch { return 1 }
}

===== END FILE: module/Pmc.Strict/src/Storage.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/TaskEditor.ps1 =====
# TaskEditor.ps1 - Interactive task editing with full-screen editor
# Provides rich editing experience for PMC tasks with multi-line support and metadata editing

class PmcTaskEditor {
    [string]$TaskId
    [hashtable]$TaskData
    [string[]]$DescriptionLines
    [string]$Project
    [string]$Priority
    [string]$DueDate
    [string[]]$Tags
    [int]$CurrentLine
    [int]$CursorColumn
    [bool]$IsEditing
    [string]$Mode  # 'description', 'metadata', 'preview'
    [hashtable]$OriginalData
    [int]$StartRow
    [int]$EndRow

    PmcTaskEditor([string]$taskId) {
        $this.TaskId = $taskId
        $this.LoadTask()
        $this.InitializeEditor()
    }

    [void] LoadTask() {
        try {
            # Load task data from PMC data store
            $taskDataResult = Invoke-PmcCommand "task show $($this.TaskId)" -Raw

            if (-not $taskDataResult) {
                throw "Task $($this.TaskId) not found"
            }

            $this.TaskData = $taskDataResult
            $this.OriginalData = $taskDataResult.Clone()

            # Parse task fields
            $this.DescriptionLines = @($taskDataResult.description -split "`n")
            $this.Project = if ($taskDataResult.project) { $taskDataResult.project } else { "" }
            $this.Priority = if ($taskDataResult.priority) { $taskDataResult.priority } else { "" }
            $this.DueDate = if ($taskDataResult.due) { $taskDataResult.due } else { "" }
            $this.Tags = @((if ($taskDataResult.tags) { $taskDataResult.tags } else { @() }))

        } catch {
            throw "Failed to load task: $_"
        }
    }

    [void] InitializeEditor() {
        $this.CurrentLine = 0
        $this.CursorColumn = 0
        $this.IsEditing = $false
        $this.Mode = 'description'

        # Calculate screen regions
        $this.StartRow = 3
        $this.EndRow = [Console]::WindowHeight - 8
    }

    [void] Show() {
        try {
            # Clear screen and setup editor
            [Console]::Clear()
            $this.DrawHeader()
            $this.DrawTaskContent()
            $this.DrawFooter()
            $this.DrawStatusLine()

            # Start editor loop
            $this.EditorLoop()

        } catch {
            Write-PmcStyled -Style 'Error' -Text ("Editor error: {0}" -f $_)
        } finally {
            # Restore normal screen
            [Console]::Clear()
        }
    }

    [void] DrawHeader() {
        $palette = Get-PmcColorPalette
        $headerColor = Get-PmcColorSequence $palette.Header
        $resetColor = [PmcVT]::Reset()

        [Console]::SetCursorPosition(0, 0)
        $title = "PMC Task Editor - Task #$($this.TaskId)"
        $separator = "═" * [Console]::WindowWidth

        Write-Host "$headerColor$title$resetColor"
        Write-Host "$headerColor$separator$resetColor"
        Write-Host ""
    }

    [void] DrawTaskContent() {
        $startRowPos = $this.StartRow

        # Mode indicator
        $modeIndicator = switch ($this.Mode) {
            'description' { "[F1] Description Editor" }
            'metadata' { "[F2] Metadata Editor" }
            'preview' { "[F3] Preview Mode" }
        }

        [Console]::SetCursorPosition(0, $startRowPos - 1)
        Write-Host $modeIndicator -ForegroundColor Yellow

        switch ($this.Mode) {
            'description' { $this.DrawDescriptionEditor($startRowPos) }
            'metadata' { $this.DrawMetadataEditor($startRowPos) }
            'preview' { $this.DrawPreviewMode($startRowPos) }
        }
    }

    [void] DrawDescriptionEditor([int]$startRow) {
        $palette = Get-PmcColorPalette
        $textColor = Get-PmcColorSequence $palette.Text
        $resetColor = [PmcVT]::Reset()
        $cursorColor = Get-PmcColorSequence $palette.Cursor

        # Clear content area
        for ($i = $startRow; $i -le $this.EndRow; $i++) {
            [Console]::SetCursorPosition(0, $i)
            Write-Host (' ' * [Console]::WindowWidth) -NoNewline
        }

        # Draw description lines
        $maxLines = $this.EndRow - $startRow + 1
        $visibleLines = [Math]::Min($this.DescriptionLines.Count, $maxLines)

        for ($i = 0; $i -lt $visibleLines; $i++) {
            [Console]::SetCursorPosition(0, $startRow + $i)

            $line = $this.DescriptionLines[$i]
            $lineNumber = ($i + 1).ToString().PadLeft(3)

            if ($i -eq $this.CurrentLine) {
                # Highlight current line
                Write-Host "$cursorColor$lineNumber │ $line$resetColor" -NoNewline
            } else {
                Write-Host "$textColor$lineNumber │ $line$resetColor" -NoNewline
            }
        }

        # Show cursor position
        if ($this.CurrentLine -lt $visibleLines) {
            $cursorRow = $startRow + $this.CurrentLine
            $cursorCol = 6 + $this.CursorColumn  # Account for line number prefix
            [Console]::SetCursorPosition($cursorCol, $cursorRow)
        }
    }

    [void] DrawMetadataEditor([int]$startRow) {
        $palette = Get-PmcColorPalette
        $labelColor = Get-PmcColorSequence $palette.Label
        $valueColor = Get-PmcColorSequence $palette.Text
        $resetColor = [PmcVT]::Reset()

        # Clear area
        for ($i = $startRow; $i -le $this.EndRow; $i++) {
            [Console]::SetCursorPosition(0, $i)
            Write-Host (' ' * [Console]::WindowWidth) -NoNewline
        }

        $row = $startRow

        # Project field
        [Console]::SetCursorPosition(0, $row++)
        Write-Host "$labelColor  Project:$resetColor $valueColor$($this.Project)$resetColor"

        # Priority field
        [Console]::SetCursorPosition(0, $row++)
        Write-Host "$labelColor Priority:$resetColor $valueColor$($this.Priority)$resetColor"

        # Due date field
        [Console]::SetCursorPosition(0, $row++)
        Write-Host "$labelColor Due Date:$resetColor $valueColor$($this.DueDate)$resetColor"

        # Tags field
        [Console]::SetCursorPosition(0, $row++)
        $tagsStr = if ($this.Tags.Count -gt 0) { $this.Tags -join ", " } else { "(none)" }
        Write-Host "$labelColor     Tags:$resetColor $valueColor$tagsStr$resetColor"

        $row++

        # Metadata editing instructions
        [Console]::SetCursorPosition(0, $row)
        Write-Host "Press Enter to edit a field, Tab/Shift+Tab to navigate" -ForegroundColor Gray
    }

    [void] DrawPreviewMode([int]$startRow) {
        $palette = Get-PmcColorPalette
        $headerColor = Get-PmcColorSequence $palette.Header
        $textColor = Get-PmcColorSequence $palette.Text
        $metaColor = Get-PmcColorSequence $palette.Muted
        $resetColor = [PmcVT]::Reset()

        # Clear area
        for ($i = $startRow; $i -le $this.EndRow; $i++) {
            [Console]::SetCursorPosition(0, $i)
            Write-Host (' ' * [Console]::WindowWidth) -NoNewline
        }

        $row = $startRow

        # Task header
        [Console]::SetCursorPosition(0, $row++)
        Write-Host "$headerColor╭─ Task Preview ─────────────────────────$resetColor"

        # Description
        [Console]::SetCursorPosition(0, $row++)
        Write-Host "$textColor│ Description:$resetColor"

        foreach ($line in $this.DescriptionLines) {
            [Console]::SetCursorPosition(0, $row++)
            Write-Host "$textColor│   $line$resetColor"
        }

        # Metadata
        [Console]::SetCursorPosition(0, $row++)
        Write-Host "$textColor│$resetColor"
        [Console]::SetCursorPosition(0, $row++)
        Write-Host "$textColor│ Metadata:$resetColor"
        [Console]::SetCursorPosition(0, $row++)
        Write-Host "$metaColor│   Project: $($this.Project)$resetColor"
        [Console]::SetCursorPosition(0, $row++)
        Write-Host "$metaColor│   Priority: $($this.Priority)$resetColor"
        [Console]::SetCursorPosition(0, $row++)
        Write-Host "$metaColor│   Due: $($this.DueDate)$resetColor"
        [Console]::SetCursorPosition(0, $row++)
        Write-Host "$metaColor│   Tags: $($this.Tags -join ', ')$resetColor"

        [Console]::SetCursorPosition(0, $row++)
        Write-Host "$headerColor╰────────────────────────────────────────$resetColor"
    }

    [void] DrawFooter() {
        $footerRow = [Console]::WindowHeight - 4
        $palette = Get-PmcColorPalette
        $footerColor = Get-PmcColorSequence $palette.Footer
        $resetColor = [PmcVT]::Reset()

        [Console]::SetCursorPosition(0, $footerRow)
        Write-Host "$footerColor$('─' * [Console]::WindowWidth)$resetColor"

        [Console]::SetCursorPosition(0, $footerRow + 1)
        Write-Host "$footerColor F1:Description  F2:Metadata  F3:Preview  Ctrl+S:Save  Esc:Cancel$resetColor"
    }

    [void] DrawStatusLine() {
        $statusRow = [Console]::WindowHeight - 2
        $palette = Get-PmcColorPalette
        $statusColor = Get-PmcColorSequence $palette.Status
        $resetColor = [PmcVT]::Reset()

        [Console]::SetCursorPosition(0, $statusRow)

        $status = switch ($this.Mode) {
            'description' { "Line $($this.CurrentLine + 1), Column $($this.CursorColumn + 1)" }
            'metadata' { "Metadata Editor - Use Enter to edit fields" }
            'preview' { "Preview Mode - Read-only view" }
        }

        $hasChanges = $this.HasUnsavedChanges()
        $changeIndicator = if ($hasChanges) { " [Modified]" } else { "" }

        Write-Host "$statusColor$status$changeIndicator$resetColor" -NoNewline
    }

    [bool] HasUnsavedChanges() {
        # Compare current state with original
        $currentDescription = $this.DescriptionLines -join "`n"
        $originalDescription = $this.OriginalData.description

        return ($currentDescription -ne $originalDescription) -or
               ($this.Project -ne $this.OriginalData.project) -or
               ($this.Priority -ne $this.OriginalData.priority) -or
               ($this.DueDate -ne $this.OriginalData.due)
    }

    [void] EditorLoop() {
        while ($true) {
            $key = [Console]::ReadKey($true)

            switch ($key.Key) {
                'F1' {
                    $this.Mode = 'description'
                    $this.DrawTaskContent()
                    $this.DrawStatusLine()
                }
                'F2' {
                    $this.Mode = 'metadata'
                    $this.DrawTaskContent()
                    $this.DrawStatusLine()
                }
                'F3' {
                    $this.Mode = 'preview'
                    $this.DrawTaskContent()
                    $this.DrawStatusLine()
                }
                'Escape' {
                    if ($this.ConfirmExit()) { return }
                }
                'S' {
                    if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                        $this.SaveTask()
                        return
                    }
                }
                default {
                    $this.HandleModeSpecificInput($key)
                }
            }
        }
    }

    [void] HandleModeSpecificInput([ConsoleKeyInfo]$key) {
        switch ($this.Mode) {
            'description' { $this.HandleDescriptionInput($key) }
            'metadata' { $this.HandleMetadataInput($key) }
            # Preview mode is read-only
        }

        $this.DrawTaskContent()
        $this.DrawStatusLine()
    }

    [void] HandleDescriptionInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            'UpArrow' {
                if ($this.CurrentLine -gt 0) {
                    $this.CurrentLine--
                    $this.CursorColumn = [Math]::Min($this.CursorColumn, $this.DescriptionLines[$this.CurrentLine].Length)
                }
            }
            'DownArrow' {
                if ($this.CurrentLine -lt ($this.DescriptionLines.Count - 1)) {
                    $this.CurrentLine++
                    $this.CursorColumn = [Math]::Min($this.CursorColumn, $this.DescriptionLines[$this.CurrentLine].Length)
                }
            }
            'LeftArrow' {
                if ($this.CursorColumn -gt 0) {
                    $this.CursorColumn--
                }
            }
            'RightArrow' {
                if ($this.CursorColumn -lt $this.DescriptionLines[$this.CurrentLine].Length) {
                    $this.CursorColumn++
                }
            }
            'Enter' {
                # Split current line at cursor position
                $currentLineText = $this.DescriptionLines[$this.CurrentLine]
                $beforeCursor = $currentLineText.Substring(0, $this.CursorColumn)
                $afterCursor = $currentLineText.Substring($this.CursorColumn)

                $this.DescriptionLines[$this.CurrentLine] = $beforeCursor
                $this.DescriptionLines = $this.DescriptionLines[0..$this.CurrentLine] + @($afterCursor) + $this.DescriptionLines[($this.CurrentLine + 1)..($this.DescriptionLines.Count - 1)]

                $this.CurrentLine++
                $this.CursorColumn = 0
            }
            'Backspace' {
                if ($this.CursorColumn -gt 0) {
                    $currentLineText = $this.DescriptionLines[$this.CurrentLine]
                    $newLine = $currentLineText.Substring(0, $this.CursorColumn - 1) + $currentLineText.Substring($this.CursorColumn)
                    $this.DescriptionLines[$this.CurrentLine] = $newLine
                    $this.CursorColumn--
                } elseif ($this.CurrentLine -gt 0) {
                    # Join with previous line
                    $prevLine = $this.DescriptionLines[$this.CurrentLine - 1]
                    $currentLineText = $this.DescriptionLines[$this.CurrentLine]
                    $this.CursorColumn = $prevLine.Length
                    $this.DescriptionLines[$this.CurrentLine - 1] = $prevLine + $currentLineText
                    $this.DescriptionLines = $this.DescriptionLines[0..($this.CurrentLine - 1)] + $this.DescriptionLines[($this.CurrentLine + 1)..($this.DescriptionLines.Count - 1)]
                    $this.CurrentLine--
                }
            }
            default {
                # Regular character input
                if ([char]::IsControl($key.KeyChar)) { return }

                $currentLineText = $this.DescriptionLines[$this.CurrentLine]
                $newLine = $currentLineText.Substring(0, $this.CursorColumn) + $key.KeyChar + $currentLineText.Substring($this.CursorColumn)
                $this.DescriptionLines[$this.CurrentLine] = $newLine
                $this.CursorColumn++
            }
        }
    }

    [void] HandleMetadataInput([ConsoleKeyInfo]$key) {
        # Metadata editing would be implemented here
        # For now, just basic navigation
    }

    [bool] ConfirmExit() {
        if (-not $this.HasUnsavedChanges()) {
            return $true
        }

        [Console]::SetCursorPosition(0, [Console]::WindowHeight - 1)
        Write-PmcStyled -Style 'Warning' -Text "Unsaved changes! Exit anyway? (y/N): " -NoNewline

        $response = [Console]::ReadKey($true)
        return ($response.Key -eq 'Y')
    }

    [void] SaveTask() {
        try {
            # Update task data
            $this.TaskData.description = $this.DescriptionLines -join "`n"
            $this.TaskData.project = $this.Project
            $this.TaskData.priority = $this.Priority
            $this.TaskData.due = $this.DueDate

            # Save via PMC command
            $updateCmd = "task edit $($this.TaskId) '$($this.TaskData.description)'"
            if ($this.Project) { $updateCmd += " @$($this.Project)" }
            if ($this.Priority) { $updateCmd += " $($this.Priority)" }
            if ($this.DueDate) { $updateCmd += " due:$($this.DueDate)" }

            Invoke-PmcCommand $updateCmd

            [Console]::SetCursorPosition(0, [Console]::WindowHeight - 1)
            Write-PmcStyled -Style 'Success' -Text "✓ Task saved successfully!"
            Start-Sleep -Seconds 1

        } catch {
            [Console]::SetCursorPosition(0, [Console]::WindowHeight - 1)
            Write-PmcStyled -Style 'Error' -Text ("✗ Error saving task: {0}" -f $_)
            Start-Sleep -Seconds 2
        }
    }
}

function Invoke-PmcTaskEditor {
    <#
    .SYNOPSIS
    Opens the interactive task editor for a specific task

    .PARAMETER TaskId
    The ID of the task to edit

    .EXAMPLE
    Invoke-PmcTaskEditor -TaskId "123"
    Opens the full-screen editor for task 123
    #>
    param(
        [Parameter(Mandatory)]
        [string]$TaskId
    )

    try {
        $editor = [PmcTaskEditor]::new($TaskId)
        $editor.Show()

    } catch {
        Write-PmcStyled -Style 'Error' -Text ("Error opening task editor: {0}" -f $_)
    }
}

# Export for module use
Export-ModuleMember -Function Invoke-PmcTaskEditor

===== END FILE: module/Pmc.Strict/src/TaskEditor.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/Theme.ps1 =====
# Theme and Preferences management

function Initialize-PmcThemeSystem {
    # Force VT/ANSI capabilities; no fallbacks
    $caps = @{ AnsiSupport=$true; TrueColorSupport=$true; IsTTY=$true; NoColor=$false; Platform='forced' }
    Set-PmcState -Section 'Display' -Key 'Capabilities' -Value $caps

    # Normalize theme from config
    $cfg = Get-PmcConfig
    $theme = @{ PaletteName='default'; Hex='#33aaff'; TrueColor=$true; HighContrast=$false; ColorBlindMode='none' }
    try {
        if ($cfg.Display -and $cfg.Display.Theme) {
            if ($cfg.Display.Theme.Hex) { $theme.Hex = ($cfg.Display.Theme.Hex.ToString()) }
            if ($cfg.Display.Theme.Enabled -ne $null) { } # reserved for future toggles
        }
        if ($cfg.Display -and $cfg.Display.Icons -and $cfg.Display.Icons.Mode) {
            Set-PmcState -Section 'Display' -Key 'Icons' -Value @{ Mode = ($cfg.Display.Icons.Mode.ToString()) }
        }
    } catch { }
    Set-PmcState -Section 'Display' -Key 'Theme' -Value $theme

    # Compute simple style tokens (expand later)
    $styles = @{
        Title    = @{ Fg='Cyan'   }
        Header   = @{ Fg='Yellow' }
        Body     = @{ Fg='White'  }
        Muted    = @{ Fg='Gray'   }
        Success  = @{ Fg='Green'  }
        Warning  = @{ Fg='Yellow' }
        Error    = @{ Fg='Red'    }
        Info     = @{ Fg='Cyan'   }
        Prompt   = @{ Fg='DarkGray' }
        Border   = @{ Fg='DarkCyan' }
        Highlight= @{ Fg='Magenta' }
    }
    Set-PmcState -Section 'Display' -Key 'Styles' -Value $styles
}

function Set-PmcTheme {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "Theme" -Message "Starting theme set" -Data @{ FreeText = $Context.FreeText }
    $cfg = Get-PmcConfig
    $color = ($Context.FreeText -join ' ').Trim()
    if ([string]::IsNullOrWhiteSpace($color)) {
        Write-PmcStyled -Style 'Warning' -Text "Usage: theme <#RRGGBB> | <preset>"
        Write-PmcStyled -Style 'Muted' -Text "Presets: ocean, lime, purple, slate"
        return
    }
    $hex = $null
    switch -Regex ($color.ToLower()) {
        '^#?[0-9a-f]{6}$' { $hex = if ($color.StartsWith('#')) { $color } else { '#'+$color } ; break }
        '^ocean$'   { $hex = '#33aaff'; break }
        '^lime$'    { $hex = '#33cc66'; break }
        '^purple$'  { $hex = '#9966ff'; break }
        '^slate$'   { $hex = '#8899aa'; break }
        default     { }
    }
    if (-not $hex) { Write-PmcStyled -Style 'Error' -Text "Invalid color. Use #RRGGBB or a preset."; return }
    try {
        if (-not $cfg.Display) { $cfg.Display = @{} }
        if (-not $cfg.Display.Theme) { $cfg.Display.Theme = @{} }
        $cfg.Display.Theme.Hex = $hex
        $cfg.Display.Theme.Enabled = $true
        Save-PmcConfig $cfg
        Write-PmcStyled -Style 'Success' -Text ("Theme color set to {0}" -f $hex)
    } catch {
        Write-PmcStyled -Style 'Error' -Text "Failed to save theme"
    }
}

function Reset-PmcTheme {
    param([PmcCommandContext]$Context)
    $cfg = Get-PmcConfig
    if (-not $cfg.Display) { $cfg.Display = @{} }
    if (-not $cfg.Display.Theme) { $cfg.Display.Theme = @{} }
    $cfg.Display.Theme.Hex = '#33aaff'
    $cfg.Display.Theme.Enabled = $true
    Save-PmcConfig $cfg
    Write-PmcStyled -Style 'Success' -Text "Theme reset to default (#33aaff)"
}

function Set-PmcIconMode {
    param([PmcCommandContext]$Context)
    $mode = ($Context.FreeText -join ' ').Trim().ToLower()
    if ([string]::IsNullOrWhiteSpace($mode)) {
        Write-PmcStyled -Style 'Warning' -Text "Usage: config icons ascii|emoji"
        return
    }
    if ($mode -notin @('ascii','emoji')) { Write-PmcStyled -Style 'Error' -Text "Invalid mode. Use ascii or emoji."; return }
    $cfg = Get-PmcConfig
    if (-not $cfg.Display) { $cfg.Display = @{} }
    if (-not $cfg.Display.Icons) { $cfg.Display.Icons = @{} }
    $cfg.Display.Icons.Mode = $mode
    Save-PmcConfig $cfg
    Write-PmcStyled -Style 'Success' -Text ("Icon mode set to {0}" -f $mode)
}

function Edit-PmcTheme {
    param([PmcCommandContext]$Context)

    # Read current theme
    $cfg = Get-PmcConfig
    $hex = try { if ($cfg.Display -and $cfg.Display.Theme -and $cfg.Display.Theme.Hex) { [string]$cfg.Display.Theme.Hex } else { '#33aaff' } } catch { '#33aaff' }
    if (-not $hex.StartsWith('#')) { $hex = '#'+$hex }
    $rgb = ConvertFrom-PmcHex $hex
    $r = [int]$rgb.R; $g=[int]$rgb.G; $b=[int]$rgb.B
    $chan = 0  # 0=R,1=G,2=B

    $done = $false
    while (-not $done) {
        # Render UI
        Clear-Host
        Show-PmcHeader -Title 'THEME ADJUSTER' -Icon '🎨'
        Write-Host ''

        # Preview box
        $preview = [PmcVT]::BgRGB($r,$g,$b) + '          ' + [PmcVT]::Reset() + ("  #{0:X2}{1:X2}{2:X2}" -f $r,$g,$b)
        Write-Host ("  Preview: " + $preview)
        Write-Host ''

        # Sliders
        Show-Slider -Label 'R' -Value $r -Selected:($chan -eq 0)
        Show-Slider -Label 'G' -Value $g -Selected:($chan -eq 1)
        Show-Slider -Label 'B' -Value $b -Selected:($chan -eq 2)

        Write-Host ''
        Write-Host '  Use ↑/↓ to select channel, ←/→ to adjust, PgUp/PgDn for ±10, Enter to save, Esc to cancel' -ForegroundColor DarkGray

        # Read key
        $k = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')
        switch ($k.VirtualKeyCode) {
            38 { $chan = [Math]::Max(0, $chan - 1) }       # Up
            40 { $chan = [Math]::Min(2, $chan + 1) }       # Down
            37 { if ($chan -eq 0) { $r = [Math]::Max(0,$r-1) } elseif ($chan -eq 1) { $g=[Math]::Max(0,$g-1) } else { $b=[Math]::Max(0,$b-1) } }  # Left
            39 { if ($chan -eq 0) { $r = [Math]::Min(255,$r+1) } elseif ($chan -eq 1) { $g=[Math]::Min(255,$g+1) } else { $b=[Math]::Min(255,$b+1) } } # Right
            33 { if ($chan -eq 0) { $r = [Math]::Min(255,$r+10) } elseif ($chan -eq 1) { $g=[Math]::Min(255,$g+10) } else { $b=[Math]::Min(255,$b+10) } } # PgUp
            34 { if ($chan -eq 0) { $r = [Math]::Max(0,$r-10) } elseif ($chan -eq 1) { $g=[Math]::Max(0,$g-10) } else { $b=[Math]::Max(0,$b-10) } } # PgDn
            13 {
                # Enter: save and exit
                $newHex = ("#{0:X2}{1:X2}{2:X2}" -f $r,$g,$b)
                if (-not $cfg.Display) { $cfg.Display=@{} }
                if (-not $cfg.Display.Theme) { $cfg.Display.Theme=@{} }
                $cfg.Display.Theme.Hex = $newHex
                Save-PmcConfig $cfg
                Write-Host "Saved theme: $newHex" -ForegroundColor Green
                Start-Sleep -Milliseconds 400
                $done = $true
            }
            27 { $done = $true } # Esc: cancel
            default {}
        }
    }
}

function Show-Slider {
    param(
        [string]$Label,
        [int]$Value,
        [switch]$Selected
    )
    $width = 32
    $filled = [int]([Math]::Round(($Value / 255.0) * $width))
    $bar = ('#' * $filled) + ('-' * ($width - $filled))
    $sel = if ($Selected) { '▶' } else { ' ' }
    $fg = if ($Selected) { 'White' } else { 'Gray' }
    Write-Host ("  {0} {1}: [{2}] {3,3}" -f $sel, $Label, $bar, $Value) -ForegroundColor $fg
}

function Show-PmcPreferences {
    param([PmcCommandContext]$Context)
    $cfg = Get-PmcConfig
    Write-Host "\nPREFERENCES" -ForegroundColor Cyan
    Write-Host "───────────" -ForegroundColor DarkGray
    Write-Host ("1) Theme color: {0}" -f ($cfg.Display.Theme.Hex ?? '#33aaff'))
    Write-Host ("2) Icons: {0}" -f ($cfg.Display.Icons.Mode ?? 'emoji'))
    Write-Host ("3) CSV ledger: {0}" -f ($cfg.Behavior.EnableCsvLedger ?? $true))
    Write-Host "q) Quit"
    while ($true) {
        $sel = Read-Host "Select option (1/2/3/q)"
        switch ($sel) {
            '1' {
                # Launch interactive adjuster with preview and sliders
                $ctx = [PmcCommandContext]::new('theme','adjust')
                Edit-PmcTheme -Context $ctx
            }
            '2' {
                $m = Read-Host "Enter icons mode (ascii/emoji)"
                $ctx = [PmcCommandContext]::new('config','icons'); $ctx.FreeText = @($m)
                Set-PmcIconMode -Context $ctx
            }
            '3' {
                $v = Read-Host "Enable CSV ledger? (y/n)"
                $flag = ($v -match '^(?i)y')
                if (-not $cfg.Behavior) { $cfg.Behavior=@{} }
                $cfg.Behavior.EnableCsvLedger = $flag
                Save-PmcConfig $cfg
                Write-Host ("CSV ledger set to {0}" -f $flag) -ForegroundColor Green
            }
            'q' { break }
            default { Write-Host 'Invalid choice' -ForegroundColor Yellow }
        }
    }
}

# Additional theme utilities and commands
function Get-PmcThemeList { [PmcCommandContext]$Context | Out-Null; @('default','ocean','#33aaff','lime','#33cc66','purple','#9966ff','slate','#8899aa','high-contrast') | ForEach-Object { Write-Host $_ } }

function Apply-PmcTheme {
    param([PmcCommandContext]$Context)
    $arg = ($Context.FreeText -join ' ').Trim()
    if (-not $arg) { Write-Host "Usage: theme apply <name|#RRGGBB>" -ForegroundColor Yellow; return }
    $hex = $null
    switch -Regex ($arg.ToLower()) {
        '^#?[0-9a-f]{6}$' { $hex = if ($arg.StartsWith('#')) { $arg } else { '#'+$arg } ; break }
        '^(default|ocean)$' { $hex = '#33aaff'; break }
        '^lime$'    { $hex = '#33cc66'; break }
        '^purple$'  { $hex = '#9966ff'; break }
        '^slate$'   { $hex = '#8899aa'; break }
        '^high-contrast$' { $hex = '#00ffff'; break }
        default {}
    }
    if (-not $hex) { Write-Host "Unknown theme; see 'theme list'" -ForegroundColor Yellow; return }
    $cfg = Get-PmcConfig
    if (-not $cfg.Display) { $cfg.Display=@{} }
    if (-not $cfg.Display.Theme) { $cfg.Display.Theme=@{} }
    $cfg.Display.Theme.Hex = $hex
    Save-PmcConfig $cfg
    Initialize-PmcThemeSystem
    Write-Host ("Theme applied: {0}" -f $hex) -ForegroundColor Green
}

function Show-PmcThemeInfo { param([PmcCommandContext]$Context)
    $disp = Get-PmcState -Section 'Display'
    $theme = $disp.Theme
    Write-Host "Theme: $($theme.PaletteName) $($theme.Hex)  TrueColor=$($theme.TrueColor) HighContrast=$($theme.HighContrast)" -ForegroundColor Cyan
}

function Reload-PmcConfig { param([PmcCommandContext]$Context)
    # Re-apply runtime from config (providers already return latest on read)
    $cfg = Get-PmcConfig
    $lvl = try { [int]$cfg.Debug.Level } catch { 0 }
    Initialize-PmcDebugSystem -Level $lvl
    Initialize-PmcSecuritySystem
    Initialize-PmcThemeSystem
    Write-Host "Configuration reloaded and systems re-initialized" -ForegroundColor Green
}

===== END FILE: module/Pmc.Strict/src/Theme.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/Types.ps1 =====
# Types and context for the strict engine

Set-StrictMode -Version Latest

class PmcCommandContext {
    [string] $Domain
    [string] $Action
    [hashtable] $Args = @{}
    [string[]] $FreeText = @()
    [string] $Raw = ''

    PmcCommandContext([string]$domain, [string]$action) {
        $this.Domain = $domain
        $this.Action = $action
    }
}

function ConvertTo-PmcTokens {
    param([string]$Buffer)

    # Always return an array, even for empty input
    if ([string]::IsNullOrWhiteSpace($Buffer)) {
        return ,[string[]]@()
    }

    # Simple split preserving quoted strings
    $pattern = '"([^"]*)"|(\S+)'
    $tokens = [string[]]@()

    foreach ($m in [regex]::Matches($Buffer, $pattern)) {
        if ($m.Groups[1].Success) {
            $tokens += $m.Groups[1].Value
        } elseif ($m.Groups[2].Success) {
            $tokens += $m.Groups[2].Value
        }
    }

    # Ensure we always return an array type with Count property
    return ,[string[]]$tokens
}

# Property helpers (consistent across PSCustomObject/Hashtable)
function Pmc-HasProp {
    param($Object, [string]$Name)
    if ($null -eq $Object -or [string]::IsNullOrWhiteSpace($Name)) { return $false }
    try {
        if ($Object -is [hashtable]) { return $Object.ContainsKey($Name) }
        $psobj = $Object.PSObject
        if ($null -eq $psobj) { return $false }
        return ($psobj.Properties[$Name] -ne $null)
    } catch { return $false }
}

function Pmc-GetProp {
    param($Object, [string]$Name, $Default=$null)
    if (-not (Pmc-HasProp $Object $Name)) { return $Default }
    try { return $Object.$Name } catch { return $Default }
}

function Ensure-PmcTaskProperties {
    <#
    .SYNOPSIS
    Ensures all required properties exist on a task object with proper defaults

    .DESCRIPTION
    Normalizes task objects by adding missing properties with appropriate default values.
    This prevents "property cannot be found" errors when accessing task properties.

    .PARAMETER Task
    The task object to normalize
    #>
    param($Task)

    if ($null -eq $Task) { return }

    # Required task properties with their default values
    $requiredProperties = @{
        'depends' = @()
        'tags' = @()
        'notes' = @()
        'recur' = $null
        'estimatedMinutes' = $null
        'nextSuggestedCount' = 3
        'lastNextShown' = (Get-Date).ToString('yyyy-MM-dd')
        'status' = 'pending'
        'priority' = 0
        'created' = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
        'project' = 'inbox'
        'due' = $null
    }

    foreach ($propName in $requiredProperties.Keys) {
        if (-not (Pmc-HasProp $Task $propName)) {
            try {
                Add-Member -InputObject $Task -MemberType NoteProperty -Name $propName -NotePropertyValue $requiredProperties[$propName] -Force
            } catch {
                # Ignore errors - property may already exist or object may be read-only
            }
        }
    }
}

function Ensure-PmcProjectProperties {
    <#
    .SYNOPSIS
    Ensures all required properties exist on a project object
    #>
    param($Project)

    if ($null -eq $Project) { return }

    $requiredProperties = @{
        'name' = ''
        'description' = ''
        'aliases' = @()
        'created' = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
        'isArchived' = $false
        'color' = 'Gray'
        'icon' = '📁'
        'sortOrder' = 0
    }

    foreach ($propName in $requiredProperties.Keys) {
        if (-not (Pmc-HasProp $Project $propName)) {
            try {
                Add-Member -InputObject $Project -MemberType NoteProperty -Name $propName -NotePropertyValue $requiredProperties[$propName] -Force
            } catch {
                # Ignore errors
            }
        }
    }
}

===== END FILE: module/Pmc.Strict/src/Types.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/UI.ps1 =====
# Pmc UI primitives with centralized style tokens and sanitization

Set-StrictMode -Version Latest

class PmcVT {
    static [string] MoveTo([int]$x, [int]$y) { return "`e[$($y + 1);$($x + 1)H" }
    static [string] Clear() { return "`e[2J`e[H" }
    static [string] ClearLine() { return "`e[2K" }
    static [string] Hide() { return "`e[?25l" }
    static [string] Show() { return "`e[?25h" }
    static [string] FgRGB([int]$r, [int]$g, [int]$b) { return "`e[38;2;$r;$g;${b}m" }
    static [string] BgRGB([int]$r, [int]$g, [int]$b) { return "`e[48;2;$r;$g;${b}m" }
    static [string] Reset() { return "`e[0m" }
    static [string] Bold() { return "`e[1m" }
}

function Sanitize-PmcOutput {
    param([string]$Text)
    if (-not $Text) { return '' }
    # Strip ANSI escape sequences and control chars
    $t = $Text -replace "`e\[[0-9;]*[A-Za-z]", ''
    $t = ($t.ToCharArray() | Where-Object { [int]$_ -ge 32 -or [int]$_ -eq 10 -or [int]$_ -eq 13 } ) -join ''
    return $t
}

function Get-PmcStyle {
    param([string]$Token)
    $styles = Get-PmcState -Section 'Display' -Key 'Styles'
    if (-not $styles) { return @{ Fg='White' } }
    if ($styles.ContainsKey($Token)) { return $styles[$Token] }
    return @{ Fg='White' }
}

function Write-PmcStyled {
    param(
        [Parameter(Mandatory)] [string]$Style,
        [Parameter(Mandatory)] [string]$Text,
        [switch]$NoNewline
    )
    $sty = Get-PmcStyle $Style
    $fg = $sty.Fg
    $safe = Sanitize-PmcOutput $Text
    if ($fg) {
        if ($NoNewline) { Write-Host -NoNewline $safe -ForegroundColor $fg } else { Write-Host $safe -ForegroundColor $fg }
    } else {
        if ($NoNewline) { Write-Host -NoNewline $safe } else { Write-Host $safe }
    }
}

function ConvertFrom-PmcHex {
    param([string]$Hex)
    $h = if ($Hex) { $Hex.Trim() } else { '#33aaff' }
    if ($h.StartsWith('#')) { $h = $h.Substring(1) }
    if ($h.Length -eq 3) { $h = ($h[0]+$h[0]+$h[1]+$h[1]+$h[2]+$h[2]) }
    if ($h.Length -ne 6) { $h = '33aaff' }
    return @{
        R = [Convert]::ToInt32($h.Substring(0,2),16)
        G = [Convert]::ToInt32($h.Substring(2,2),16)
        B = [Convert]::ToInt32($h.Substring(4,2),16)
    }
}

function Get-PmcColorPalette {
    $cfg = Get-PmcConfig
    $hex = '#33aaff'
    try { if ($cfg.Display -and $cfg.Display.Theme -and $cfg.Display.Theme.Hex) { $hex = [string]$cfg.Display.Theme.Hex } } catch {
        # Theme configuration access failed - use default hex color
    }
    $rgb = ConvertFrom-PmcHex $hex
    # Simple derived shades
    $dim = @{
        R = [int]([Math]::Max(0, $rgb.R * 0.7)); G = [int]([Math]::Max(0, $rgb.G * 0.7)); B = [int]([Math]::Max(0, $rgb.B * 0.7))
    }
    return @{
        Primary = $rgb
        Border = $dim
        Text = @{ R=220; G=220; B=220 }
        Muted = @{ R=150; G=150; B=150 }
        Error = @{ R=220; G=80; B=80 }
        Warning = @{ R=220; G=180; B=80 }
        Success = @{ R=80; G=200; B=120 }
    }
}

function Get-PmcColorSequence { param($rgb) return ([PmcVT]::FgRGB($rgb.R, $rgb.G, $rgb.B)) }

function Show-PmcHeader {
    param([string]$Title,[string]$Icon='')
    $t = if ($Icon) { " $Icon $Title" } else { " $Title" }
    Write-PmcStyled -Style 'Title' -Text $t
    $width = [Math]::Max(8, $t.Length)
    Write-PmcStyled -Style 'Border' -Text ('-' * $width)
}

function Show-PmcTip { param([string]$Text) Write-PmcStyled -Style 'Muted' -Text ('  ' + $Text) }

function Get-PmcIcon {
    param([string]$Name)
    $mode = 'emoji'
    try { $cfg = Get-PmcConfig; if ($cfg.Display -and $cfg.Display.Icons -and $cfg.Display.Icons.Mode) { $mode = [string]$cfg.Display.Icons.Mode } } catch {
        # Icon configuration access failed - use default mode
    }
    switch ($Name) {
        'notice' { return ($mode -eq 'ascii') ? '*' : '•' }
        'warn'   { return ($mode -eq 'ascii') ? '!' : '⚠' }
        'error'  { return ($mode -eq 'ascii') ? 'X' : '✖' }
        'ok'     { return ($mode -eq 'ascii') ? '+' : '✓' }
        default  { return '' }
    }
}

function Show-PmcNotice { param([string]$Text) $i=(Get-PmcIcon 'notice'); Write-PmcStyled -Style 'Body' -Text ($i + ' ' + $Text) }
function Show-PmcWarning { param([string]$Text) $i=(Get-PmcIcon 'warn'); Write-PmcStyled -Style 'Warning' -Text ($i + ' ' + $Text) }
function Show-PmcError { param([string]$Text) $i=(Get-PmcIcon 'error'); Write-PmcStyled -Style 'Error' -Text ($i + ' ' + $Text) }
function Show-PmcSuccess { param([string]$Text) $i=(Get-PmcIcon 'ok'); Write-PmcStyled -Style 'Success' -Text ($i + ' ' + $Text) }
function Show-PmcSeparator { param([int]$Width=40) Write-PmcStyled -Style 'Border' -Text ('─' * [Math]::Max(8,$Width)) }

function Show-PmcTable {
    param(
        [array]$Columns, # array of @{ key='id'; title='#'; width=4; align='right' }
        [array]$Rows,    # array of hashtables or psobjects
        [string]$Title=''
    )
    if ($Title) { Show-PmcHeader -Title $Title }
    # Header
    $header = '  ' + ($Columns | ForEach-Object {
        if (-not ($_ -is [hashtable])) { throw "Show-PmcTable: Column must be a hashtable with keys: key[,title,width,align]" }
        if (-not $_.ContainsKey('key')) { throw "Show-PmcTable: Column missing required 'key'" }
        $t = if ($_.ContainsKey('title')) { [string]$_['title'] } else { [string]$_['key'] }
        $w = if ($_.ContainsKey('width')) { [int]$_['width'] } else { 8 }
        $t.PadRight($w)
    }) -join '  '
    Write-PmcStyled -Style 'Header' -Text $header
    $sep = '  ' + ($Columns | ForEach-Object {
        if (-not ($_ -is [hashtable])) { throw "Show-PmcTable: Column must be hashtable" }
        $w = if ($_.ContainsKey('width')) { [int]$_['width'] } else { 8 }
        ('-' * $w)
    }) -join '  '
    Write-PmcStyled -Style 'Border' -Text $sep
    # Rows
    foreach ($row in $Rows) {
        $line = '  '
        foreach ($col in $Columns) {
            if (-not ($col -is [hashtable])) { throw "Show-PmcTable: Column must be hashtable" }
            if (-not $col.ContainsKey('key')) { throw "Show-PmcTable: Column missing 'key'" }
            $k = [string]$col['key']
            $w = if ($col.ContainsKey('width')) { [int]$col['width'] } else { 8 }
            $a = if ($col.ContainsKey('align')) { [string]$col['align'] } else { 'left' }
            if ($a -notin @('left','right')) { throw "Show-PmcTable: Invalid align '$a' (use 'left' or 'right')" }
            $v = ''
            try { $v = if ($row.PSObject -and $row.PSObject.Properties[$k]) { [string]$row.$k } elseif ($row[$k]) { [string]$row[$k] } else { '' } } catch {
                # Property access failed - use empty string
            }
            if ($v.Length -gt $w) { $v = $v.Substring(0, [Math]::Max(0,$w-1)) + '…' }
            if ($a -eq 'right') { $line += $v.PadLeft($w) + '  ' } else { $line += $v.PadRight($w) + '  ' }
        }
        Write-PmcStyled -Style 'Body' -Text ($line.TrimEnd())
    }
}

===== END FILE: module/Pmc.Strict/src/UI.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/UndoRedo.ps1 =====
# Undo/Redo System Implementation
# Based on t2.ps1 undo/redo functionality

# Global variables for undo/redo stacks
$Script:PmcUndoStack = @()
$Script:PmcRedoStack = @()
$Script:PmcMaxUndoSteps = 5

function Invoke-PmcUndo {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "System" -Message "Starting undo operation"
    $file = Get-PmcTaskFilePath
    $stacks = Get-PmcUndoRedoStacks $file
    $undo = @($stacks.undo); $redo = @($stacks.redo)
    if (@($undo).Count -eq 0) { Write-PmcStyled -Style 'Muted' -Text 'Nothing to undo'; return }
    try {
        $current = Get-PmcData
        $redo += ($current | ConvertTo-Json -Depth 10)
    } catch {
        # Undo state push failed - undo history may be incomplete
    }
    $snap = $undo[-1]; if (@($undo).Count -gt 1) { $undo = $undo[0..($undo.Count-2)] } else { $undo=@() }
    try {
        $state = $snap | ConvertFrom-Json
        $tmp = "$file.tmp"; $state | ConvertTo-Json -Depth 10 | Set-Content -Path $tmp -Encoding UTF8; Move-Item -Force -Path $tmp -Destination $file
        Save-PmcUndoRedoStacks -Undo $undo -Redo $redo -UndoFile $stacks.undoFile -RedoFile $stacks.redoFile
        Write-PmcStyled -Style 'Success' -Text 'Undid last action'
        Write-PmcDebug -Level 2 -Category 'System' -Message 'Undo completed' -Data @{ UndoCount=@($undo).Count; RedoCount=@($redo).Count }
    } catch {
        Write-PmcStyled -Style 'Error' -Text ("Undo failed: {0}" -f $_)
    }
}

function Invoke-PmcRedo {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "System" -Message "Starting redo operation"
    $file = Get-PmcTaskFilePath
    $stacks = Get-PmcUndoRedoStacks $file
    $undo = @($stacks.undo); $redo = @($stacks.redo)
    if (@($redo).Count -eq 0) { Write-PmcStyled -Style 'Muted' -Text 'Nothing to redo'; return }
    $snap = $redo[-1]; if (@($redo).Count -gt 1) { $redo = $redo[0..($redo.Count-2)] } else { $redo=@() }
    try {
        $current = Get-PmcData
        $undo += ($current | ConvertTo-Json -Depth 10)
    } catch {
        # Undo state push failed - undo history may be incomplete
    }
    try {
        $state = $snap | ConvertFrom-Json
        $tmp = "$file.tmp"; $state | ConvertTo-Json -Depth 10 | Set-Content -Path $tmp -Encoding UTF8; Move-Item -Force -Path $tmp -Destination $file
        Save-PmcUndoRedoStacks -Undo $undo -Redo $redo -UndoFile $stacks.undoFile -RedoFile $stacks.redoFile
        Write-PmcStyled -Style 'Success' -Text 'Redid last action'
        Write-PmcDebug -Level 2 -Category 'System' -Message 'Redo completed' -Data @{ UndoCount=@($undo).Count; RedoCount=@($redo).Count }
    } catch {
        Write-PmcStyled -Style 'Error' -Text ("Redo failed: {0}" -f $_)
    }
}

function New-PmcBackup {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "System" -Message "Starting manual backup"

    try {
        $data = Get-PmcDataAlias
        $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"

        # Create backups directory if it doesn't exist
        $backupDir = "backups"
        if (-not (Test-Path $backupDir)) {
            New-Item -ItemType Directory -Path $backupDir -Force | Out-Null
        }

        $backupFile = Join-Path $backupDir "pmc_backup_$timestamp.json"

        # Export data to backup file
        $data | ConvertTo-Json -Depth 10 | Set-Content -Path $backupFile -Encoding UTF8

        Write-PmcStyled -Style 'Success' -Text ("Backup created: {0}" -f $backupFile)

        # Clean up old backups (keep last 2)
        $backupFiles = Get-ChildItem -Path $backupDir -Filter "pmc_backup_*.json" | Sort-Object LastWriteTime -Descending
        if ($backupFiles.Count -gt 2) {
            $oldBackups = $backupFiles | Select-Object -Skip 2
            foreach ($oldBackup in $oldBackups) {
                Remove-Item $oldBackup.FullName -Force
                Write-PmcStyled -Style 'Muted' -Text ("Removed old backup: {0}" -f $oldBackup.Name)
            }
        }

        Write-PmcDebug -Level 2 -Category "System" -Message "Manual backup completed successfully" -Data @{ BackupFile = $backupFile }
    } catch {
        Write-PmcStyled -Style 'Error' -Text ("Backup failed: {0}" -f $_)
        Write-PmcDebug -Level 1 -Category "System" -Message "Manual backup failed" -Data @{ Error = $_.Exception.Message }
    }
}

function Clear-PmcBackups {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "System" -Message "Starting system clean"

    $data = Get-PmcDataAlias
    $completedTasks = @($data.tasks | Where-Object { $_.status -eq 'completed' })

    if ($completedTasks.Count -eq 0) {
        Write-PmcStyled -Style 'Muted' -Text "No completed tasks to clean"
        return
    }

    Write-PmcStyled -Style 'Warning' -Text ("Found {0} completed tasks" -f $completedTasks.Count)

    # Show sample of what will be cleaned
    $sample = $completedTasks | Select-Object -First 5
    foreach ($task in $sample) {
        $completedDate = if ($task.completed) { $task.completed } else { 'unknown' }
        Write-PmcStyled -Style 'Muted' -Text ("  #$($task.id) - $($task.text) (completed: $completedDate)")
    }

    if ($completedTasks.Count -gt 5) {
        Write-PmcStyled -Style 'Muted' -Text ("  ... and {0} more" -f ($completedTasks.Count - 5))
    }

    # Ask for confirmation
    $response = Read-Host "`nProceed with cleaning? This will permanently remove completed tasks. (y/N)"

    if ($response -match '^[Yy]') {
        # Record current state for undo
        Record-PmcUndoState $data 'system clean'

        # Remove completed tasks
        $data.tasks = @($data.tasks | Where-Object { $_.status -ne 'completed' })

        # Save cleaned data
        Save-StrictData $data 'system clean'

        Write-PmcStyled -Style 'Success' -Text ("Cleaned {0} completed tasks" -f $completedTasks.Count)

        Write-PmcDebug -Level 2 -Category "System" -Message "System clean completed successfully" -Data @{ RemovedTasks = $completedTasks.Count }
    } else {
        Write-PmcStyled -Style 'Muted' -Text "Clean operation cancelled"
    }
}

# Initialize undo system - integrate with existing Add-PmcUndoEntry mechanism
function Initialize-PmcUndoSystem {
    $taskFile = Get-PmcTaskFilePath
    $undoFile = $taskFile + '.undo'

    if (-not $Script:PmcUndoStack -or $Script:PmcUndoStack.Count -eq 0) {
        if (Test-Path $undoFile) {
            try {
                $undoStack = Get-Content $undoFile -Raw | ConvertFrom-Json
                $Script:PmcUndoStack = @($undoStack)

                Write-PmcDebug -Level 3 -Category "System" -Message "Undo system initialized from existing file" -Data @{
                    UndoSteps = $Script:PmcUndoStack.Count
                    RedoSteps = $Script:PmcRedoStack.Count
                }
            } catch {
                $Script:PmcUndoStack = @()
                $Script:PmcRedoStack = @()
                Write-PmcDebug -Level 1 -Category "System" -Message "Failed to load undo data" -Data @{ Error = $_.Exception.Message }
            }
        } else {
            $Script:PmcUndoStack = @()
            $Script:PmcRedoStack = @()
        }
    }
}

# Record state for undo
function Record-PmcUndoState {
    param($data, [string]$action)

    if (-not $data) { return }

    # Add current state to undo stack
    $Script:PmcUndoStack += ($data | ConvertTo-Json -Depth 10)

    # Limit undo stack size
    if ($Script:PmcUndoStack.Count -gt $Script:PmcMaxUndoSteps) {
        $Script:PmcUndoStack = $Script:PmcUndoStack[1..($Script:PmcUndoStack.Count-1)]
    }

    # Clear redo stack when new action is performed
    $Script:PmcRedoStack = @()

    # Save undo stack
    Save-PmcUndoStack

    Write-PmcDebug -Level 3 -Category "System" -Message "Undo state recorded" -Data @{
        Action = $action
        UndoStackSize = $Script:PmcUndoStack.Count
    }
}

# Save undo stack to disk
function Save-PmcUndoStack {
    $undoFile = "pmc_undo.json"

    try {
        $undoData = @{
            undoStack = $Script:PmcUndoStack
            redoStack = $Script:PmcRedoStack
            lastUpdated = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
        }

        $undoData | ConvertTo-Json -Depth 10 | Set-Content -Path $undoFile -Encoding UTF8

        Write-PmcDebug -Level 3 -Category "System" -Message "Undo stack saved to disk"
    } catch {
        Write-PmcDebug -Level 1 -Category "System" -Message "Failed to save undo stack" -Data @{ Error = $_.Exception.Message }
    }
}

# Save data directly without recording undo state
function Save-PmcDataDirect {
    param($data)

    $dataFile = "pmc_data.json"
    $data | ConvertTo-Json -Depth 10 | Set-Content -Path $dataFile -Encoding UTF8

    # Update in-memory cache if it exists
    if (Get-Variable -Name 'Script:PmcDataCache' -Scope Script -ErrorAction SilentlyContinue) {
        $Script:PmcDataCache = $data
    }
}

# Get undo/redo status
function Get-PmcUndoStatus {
    Initialize-PmcUndoSystem

    return @{
        UndoSteps = $Script:PmcUndoStack.Count
        RedoSteps = $Script:PmcRedoStack.Count
        MaxSteps = $Script:PmcMaxUndoSteps
    }
}

===== END FILE: module/Pmc.Strict/src/UndoRedo.ps1 =====

===== BEGIN FILE: module/Pmc.Strict/src/Views.ps1 =====
# Advanced Task Views Implementation
# Implements today, overdue, blocked, upcoming, noduedate views

function Show-PmcTodayTasks {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "Views" -Message "Starting today view"

    $today = (Get-Date).Date
    $title = "📅 TASKS DUE TODAY - {0}" -f $today.ToString('yyyy-MM-dd')

    Show-PmcDataGrid -Domains @("task") -Columns @{
        "id" = @{ Header = "#"; Width = 4; Alignment = "Right" }
        "text" = @{ Header = "Task"; Width = 40; Alignment = "Left" }
        "project" = @{ Header = "Project"; Width = 12; Alignment = "Left"; Truncate = $true }
        "priority" = @{ Header = "P"; Width = 3; Alignment = "Center" }
    } -Filters @{
        "status" = "pending"
        "due_range" = "today"
    } -Title $title

    # Show summary stats using the filtered data
    $data = Get-PmcFilteredData -Domains @("task") -Filters @{
        "status" = "pending"
        "due_range" = "today"
    }

    if ($data.Count -eq 0) {
        Write-PmcStyled -Style 'Success' -Text "`nNo tasks due today! 🎉"
        return
    }

    $blocked = @($data | Where-Object { $_ -ne $null -and $_.PSObject.Properties['blocked'] -and $_.blocked })
    $highPri = @($data | Where-Object { $_ -ne $null -and $_.priority -and $_.priority -le 2 })

    Write-PmcStyled -Style 'Title' -Text "`nSummary:"
    Write-PmcStyled -Style 'Body' -Text "  Total due today: $($data.Count)"
    if ($blocked.Count -gt 0) {
        Write-PmcStyled -Style 'Error' -Text "  🔒 Blocked: $($blocked.Count)"
    }
    if ($highPri.Count -gt 0) {
        Write-PmcStyled -Style 'Warning' -Text "  ⭐ High priority: $($highPri.Count)"
    }

    Write-PmcDebug -Level 2 -Category "Views" -Message "Today view completed" -Data @{ TaskCount = $data.Count; BlockedCount = $blocked.Count }
}

function Show-PmcTomorrowTasks {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "Views" -Message "Starting tomorrow view"

    $data = Get-PmcDataAlias
    $tomorrow = (Get-Date).Date.AddDays(1)

    # Initialize tasks array if null
    if (-not $data.tasks) { $data.tasks = @() }

    $tomorrowTasks = @($data.tasks | Where-Object {
        if ($_ -eq $null -or $_.status -ne 'pending' -or -not $_.due -or -not ($_.due -is [string])) { return $false }
        if ($_.due -notmatch '^\d{4}-\d{2}-\d{2}$') { return $false }
        $d = [datetime]::ParseExact([string]$_.due, 'yyyy-MM-dd', [Globalization.CultureInfo]::InvariantCulture)
        return ($d.Date -eq $tomorrow)
    })

    Write-PmcStyled -Style 'Title' -Text ("`n📅 TASKS DUE TOMORROW - {0}" -f $tomorrow.ToString('yyyy-MM-dd'))
    Write-PmcStyled -Style 'Border' -Text "───────────────────────────────────────────────────"

    if ($tomorrowTasks.Count -eq 0) {
        Write-PmcStyled -Style 'Muted' -Text "No tasks due tomorrow"
        return
    }

    Show-TaskListWithIndex $tomorrowTasks "TOMORROW'S TASKS"

    Write-PmcDebug -Level 2 -Category "Views" -Message "Tomorrow view completed" -Data @{ TaskCount = $tomorrowTasks.Count }
}

function Show-PmcOverdueTasks {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "Views" -Message "Starting overdue view"

    $title = "⚠️  OVERDUE TASKS"

    Show-PmcDataGrid -Domains @("task") -Columns @{
        "id" = @{ Header = "#"; Width = 4; Alignment = "Right" }
        "text" = @{ Header = "Task"; Width = 35; Alignment = "Left" }
        "project" = @{ Header = "Project"; Width = 12; Alignment = "Left"; Truncate = $true }
        "due" = @{ Header = "Due"; Width = 10; Alignment = "Center" }
        "priority" = @{ Header = "P"; Width = 3; Alignment = "Center" }
    } -Filters @{
        "status" = "pending"
        "due_range" = "overdue"
    } -Title $title

    # Show overdue statistics
    $data = Get-PmcFilteredData -Domains @("task") -Filters @{
        "status" = "pending"
        "due_range" = "overdue"
    }

    if ($data.Count -eq 0) {
        Write-PmcStyled -Style 'Success' -Text "`nNo overdue tasks! ✅"
        return
    }

    $today = (Get-Date).Date
    $ages = @()
    foreach ($task in $data) {
        if ($task -ne $null -and $task.due) {
            try {
                $dueDate = [datetime]$task.due
                $daysOverdue = ($today - $dueDate).Days
                $ages += $daysOverdue
            } catch {
                # Skip invalid date
            }
        }
    }

    if ($ages.Count -gt 0) {
        $maxOverdue = $ages | Measure-Object -Maximum | Select-Object -ExpandProperty Maximum
        $avgOverdue = [Math]::Round(($ages | Measure-Object -Average | Select-Object -ExpandProperty Average), 1)

        Write-PmcStyled -Style 'Error' -Text "`nOverdue Statistics:"
        Write-PmcStyled -Style 'Warning' -Text "  Most overdue: $maxOverdue days"
        Write-PmcStyled -Style 'Warning' -Text "  Average overdue: $avgOverdue days"
    }

    Write-PmcDebug -Level 2 -Category "Views" -Message "Overdue view completed" -Data @{ TaskCount = $data.Count; MaxOverdue = $maxOverdue }
}

function Show-PmcUpcomingTasks {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "Views" -Message "Starting upcoming view"

    $data = Get-PmcDataAlias
    $today = (Get-Date).Date
    $weekFromNow = $today.AddDays(7)

    # Initialize tasks array if null
    if (-not $data.tasks) { $data.tasks = @() }

    $upcomingTasks = @($data.tasks | Where-Object {
        if ($_ -eq $null -or $_.status -ne 'pending' -or -not (Pmc-HasProp $_ 'due') -or -not $_.due -or -not ($_.due -is [string])) { return $false }
        if ($_.due -notmatch '^\d{4}-\d{2}-\d{2}$') { return $false }
        $d = [datetime]::ParseExact([string]$_.due, 'yyyy-MM-dd', [Globalization.CultureInfo]::InvariantCulture)
        return ($d.Date -gt $today -and $d.Date -le $weekFromNow)
    })

    Write-PmcStyled -Style 'Success' -Text "`n📋 UPCOMING TASKS (Next 7 Days)"
    Write-PmcStyled -Style 'Border' -Text "────────────────────────────────"

    if ($upcomingTasks.Count -eq 0) {
        Write-PmcStyled -Style 'Muted' -Text "No tasks due in the next 7 days"
        return
    }

    # Sort by due date
    $upcomingTasks = $upcomingTasks | Sort-Object { [datetime]::ParseExact([string]$_.due, 'yyyy-MM-dd', [Globalization.CultureInfo]::InvariantCulture) }

    Show-TaskListWithIndex $upcomingTasks "UPCOMING TASKS" -ShowDaysUntil

    # Group by day
    $tasksByDay = $upcomingTasks | Group-Object { ([datetime]::ParseExact([string]$_.due, 'yyyy-MM-dd', [Globalization.CultureInfo]::InvariantCulture)).ToString('yyyy-MM-dd') }

    Write-PmcStyled -Style 'Success' -Text "`nBy Day:"
    foreach ($dayGroup in $tasksByDay) {
        if ($dayGroup -eq $null -or -not $dayGroup.Name) { continue }
        $date = $null
        if ($dayGroup.Name -and $dayGroup.Name -is [string] -and $dayGroup.Name -match '^\d{4}-\d{2}-\d{2}$') {
            $date = [datetime]::ParseExact([string]$dayGroup.Name, 'yyyy-MM-dd', [Globalization.CultureInfo]::InvariantCulture)
            $dayName = $date.ToString('dddd')
            $daysAway = ($date.Date - $today).Days
            $dayLabel = if ($daysAway -eq 1) { "Tomorrow" } else { "$daysAway days away" }
            Write-PmcStyled -Style 'Body' -Text ("  {0} ({1} - {2}): {3} tasks" -f $date.ToString('MM/dd'), $dayName, $dayLabel, $dayGroup.Count)
        }
    }

    Write-PmcDebug -Level 2 -Category "Views" -Message "Upcoming view completed" -Data @{ TaskCount = $upcomingTasks.Count }
}

# Additional views: agenda, week, month
function Show-PmcAgenda {
    param([PmcCommandContext]$Context)

    $today = (Get-Date).Date
    $title = "🗓️ AGENDA - {0}" -f $today.ToString('yyyy-MM-dd')

    Show-PmcDataGrid -Domains @("task") -Columns @{
        "id" = @{ Header = "#"; Width = 4; Alignment = "Right" }
        "text" = @{ Header = "Task"; Width = 35; Alignment = "Left" }
        "project" = @{ Header = "Project"; Width = 12; Alignment = "Left"; Truncate = $true }
        "due" = @{ Header = "Due"; Width = 8; Alignment = "Center" }
        "priority" = @{ Header = "P"; Width = 3; Alignment = "Center" }
    } -Filters @{
        "status" = "pending"
        "due_range" = "overdue_and_today"
    } -Title $title
}

function Show-PmcWeekTasks { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    if (-not $data.tasks) { $data.tasks = @() }
    $today = (Get-Date).Date
    $end = $today.AddDays(6)
    $week = @($data.tasks | Where-Object {
        if ($_ -eq $null -or $_.status -ne 'pending' -or -not (Pmc-HasProp $_ 'due') -or -not $_.due) { return $false }
        if ($_.due -and ($_.due -is [string]) -and $_.due -match '^\d{4}-\d{2}-\d{2}$') {
            $d = [datetime]::ParseExact([string]$_.due, 'yyyy-MM-dd', [Globalization.CultureInfo]::InvariantCulture)
            return ($d.Date -ge $today -and $d.Date -le $end)
        }
        return $false
    })
    Write-PmcStyled -Style 'Title' -Text ("`n📆 THIS WEEK - {0}..{1}" -f $today.ToString('yyyy-MM-dd'), $end.ToString('yyyy-MM-dd'))
    Write-PmcStyled -Style 'Border' -Text "─────────────────────────────────────────────────"
    if ($week.Count -eq 0) { Write-PmcStyled -Style 'Muted' -Text 'No tasks due this week'; return }
    Show-TaskListWithIndex $week "THIS WEEK'S TASKS"
}

function Show-PmcMonthTasks { param([PmcCommandContext]$Context)
    $data = Get-PmcDataAlias
    if (-not $data.tasks) { $data.tasks = @() }
    $today = (Get-Date).Date
    $y = $today.Year; $m = $today.Month
    $month = @($data.tasks | Where-Object {
        if ($_ -eq $null -or $_.status -ne 'pending' -or -not (Pmc-HasProp $_ 'due') -or -not $_.due) { return $false }
        if ($_.due -and ($_.due -is [string]) -and $_.due -match '^\d{4}-\d{2}-\d{2}$') {
            $d = [datetime]::ParseExact([string]$_.due, 'yyyy-MM-dd', [Globalization.CultureInfo]::InvariantCulture)
            return ($d.Year -eq $y -and $d.Month -eq $m)
        }
        return $false
    })
    Write-PmcStyled -Style 'Title' -Text ("`n🗓️ THIS MONTH - {0}" -f $today.ToString('yyyy-MM'))
    Write-PmcStyled -Style 'Border' -Text "─────────────────────────────────────────────────"
    if ($month.Count -eq 0) { Write-PmcStyled -Style 'Muted' -Text 'No tasks due this month'; return }
    Show-TaskListWithIndex $month "THIS MONTH'S TASKS"
}

function Show-PmcBlockedTasks {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "Views" -Message "Starting blocked view"

    $data = Get-PmcDataAlias

    # Ensure blocked status is updated
    Update-PmcBlockedStatus -data $data

    # Initialize tasks array if null
    if (-not $data.tasks) { $data.tasks = @() }

    $blockedTasks = @($data.tasks | Where-Object { $_ -ne $null -and $_.status -eq 'pending' -and $_.PSObject.Properties['blocked'] -and $_.blocked })

    Write-PmcStyled -Style 'Error' -Text "`n🔒 BLOCKED TASKS"
    Write-PmcStyled -Style 'Border' -Text "────────────────"

    if ($blockedTasks.Count -eq 0) {
        Write-PmcStyled -Style 'Success' -Text "No blocked tasks! 🎉"
        return
    }

    Show-TaskListWithIndex $blockedTasks "BLOCKED TASKS" -ShowBlockers

    Write-PmcStyled -Style 'Warning' -Text "`nTo unblock these tasks, complete their dependencies:"
    foreach ($task in $blockedTasks) {
        if ($task -ne $null -and (Pmc-HasProp $task 'depends') -and $task.depends) {
            $blockers = @()
            foreach ($depId in $task.depends) {
                if ($depId -ne $null) {
                    $depTask = $data.tasks | Where-Object { $_ -ne $null -and $_.id -eq $depId -and $_.status -eq 'pending' } | Select-Object -First 1
                    if ($depTask -ne $null) {
                        $blockers += "#$depId ($($depTask.text))"
                    }
                }
            }
            if ($blockers.Count -gt 0) {
                Write-PmcStyled -Style 'Muted' -Text ("  Task #$($task.id): blocked by {0}" -f ($blockers -join ', '))
            }
        }
    }

    Write-PmcDebug -Level 2 -Category "Views" -Message "Blocked view completed" -Data @{ TaskCount = $blockedTasks.Count }
}

function Show-PmcTasksWithoutDueDate {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "Views" -Message "Starting noduedate view"

    $data = Get-PmcDataAlias

    # Initialize tasks array if null
    if (-not $data.tasks) { $data.tasks = @() }

    $nodueTasks = @($data.tasks | Where-Object { $_ -ne $null -and $_.status -eq 'pending' -and (-not $_.due -or $_.due -eq '') })

    Write-PmcStyled -Style 'Highlight' -Text "`n📝 TASKS WITHOUT DUE DATES"
    Write-PmcStyled -Style 'Border' -Text "───────────────────────────"

    if ($nodueTasks.Count -eq 0) {
        Write-PmcStyled -Style 'Success' -Text "All pending tasks have due dates! 📅"
        return
    }

    # Sort by priority, then by creation date
    $nodueTasks = $nodueTasks | Sort-Object @{
        Expression = { if ($_ -ne $null -and $_.priority) { 4 - $_.priority } else { 0 } }
    }, @{
        Expression = {
            if ($_ -ne $null -and $_.created -and ($_.created -is [string]) -and $_.created -match '^\d{4}-\d{2}-\d{2}') {
                try { [datetime]$_.created } catch { [datetime]::MinValue }
            } else { [datetime]::MinValue }
        }
    }

    Show-TaskListWithIndex $nodueTasks "TASKS WITHOUT DUE DATES"

    # Show recommendations
    Write-PmcStyled -Style 'Highlight' -Text "`nRecommendations:"
    Write-PmcStyled -Style 'Muted' -Text "  • Consider adding due dates with: task update <id> due:yyyy-mm-dd"
    Write-PmcStyled -Style 'Muted' -Text "  • High priority tasks should have due dates first"

    $highPriNodue = @($nodueTasks | Where-Object { $_ -ne $null -and $_.priority -and $_.priority -le 2 })
    if ($highPriNodue.Count -gt 0) {
        Write-PmcStyled -Style 'Warning' -Text "  ⭐ $($highPriNodue.Count) high-priority tasks need due dates!"
    }

    Write-PmcDebug -Level 2 -Category "Views" -Message "NoDueDate view completed" -Data @{ TaskCount = $nodueTasks.Count; HighPriorityCount = $highPriNodue.Count }
}

function Show-PmcNextTasks {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "Views" -Message "Starting next actions view"

    $data = Get-PmcDataAlias

    # Initialize tasks array if null
    if (-not $data.tasks) { $data.tasks = @() }

    # Consider current context when listing next actions (avoid clobbering $Context param)
    $focusContext = Get-PmcCurrentContext
    $tasks = @($data.tasks | Where-Object { $_ -ne $null -and $_.status -eq 'pending' })
    if ($focusContext -and $focusContext -ne 'inbox') {
        $tasks = @($tasks | Where-Object { $_ -ne $null -and $_.project -eq $focusContext })
    } else {
        $tasks = @($tasks | Where-Object { $_ -ne $null -and (-not $_.project -or $_.project -eq 'inbox') })
    }

    # Favor unblocked, higher priority, earlier due
    Update-PmcBlockedStatus -data $data
    $today = (Get-Date).Date
    $scored = @()
    foreach ($t in $tasks) {
        if ($t -eq $null) { continue }
        $pri = if ($t.priority) { [int]$t.priority } else { 3 }
        $dueDelta = 999
        if ($t.due -and ($t.due -is [string]) -and $t.due -match '^\d{4}-\d{2}-\d{2}$') {
            $d = [datetime]::ParseExact([string]$t.due, 'yyyy-MM-dd', [Globalization.CultureInfo]::InvariantCulture)
            $dueDelta = ($d.Date - $today).Days
        }
        $blocked = if ((Pmc-HasProp $t 'blocked') -and $t.blocked) { 1 } else { 0 }
        $score = ($blocked*1000) + (($pri-1)*100) + ([Math]::Max(0, $dueDelta))
        $scored += @{ task=$t; score=$score }
    }
    $ordered = @($scored | Sort-Object score | Select-Object -First 10 | ForEach-Object { $_.task })

    Write-PmcStyled -Style 'Info' -Text "`n🎯 NEXT ACTIONS"
    Write-PmcStyled -Style 'Border' -Text "───────────────"

    if ($ordered.Count -eq 0) {
        Write-PmcStyled -Style 'Muted' -Text "No next actions found"
        return
    }

    Show-TaskListWithIndex $ordered "NEXT ACTIONS"

    Write-PmcDebug -Level 2 -Category "Views" -Message "Next actions view completed" -Data @{ Count = $ordered.Count; Context=$context }
}

function Show-PmcProjectsView {
    param([PmcCommandContext]$Context)
    Write-PmcDebug -Level 1 -Category "Views" -Message "Starting projects dashboard view"

    $data = Get-PmcDataAlias

    Write-PmcStyled -Style 'Info' -Text "`n📊 PROJECTS DASHBOARD"
    Write-PmcStyled -Style 'Border' -Text "──────────────────────"

    # Initialize projects array if null
    if (-not $data.projects) { $data.projects = @() }
    if (-not $data.tasks) { $data.tasks = @() }

    if ($data.projects.Count -eq 0) {
        Write-PmcStyled -Style 'Muted' -Text "No projects found"
        return
    }

    $rows = @()
    $totalTasks = 0
    $totalCompleted = 0

    foreach ($project in ($data.projects | Where-Object { $_ -ne $null } | Sort-Object name)) {
        if ((Pmc-HasProp $project 'isArchived') -and $project.isArchived) { continue }

        $projectTasks = @($data.tasks | Where-Object { $_ -ne $null -and $_.project -eq $project.name })
        $pendingTasks = @($projectTasks | Where-Object { $_ -ne $null -and $_.status -eq 'pending' })
        $completedTasks = @($projectTasks | Where-Object { $_ -ne $null -and $_.status -eq 'completed' })
        $overdueTasks = @($pendingTasks | Where-Object {
            if ($_ -eq $null -or -not $_.due -or -not ($_.due -is [string]) -or $_.due -notmatch '^\d{4}-\d{2}-\d{2}$') { return $false }
            $dd = [datetime]::ParseExact([string]$_.due, 'yyyy-MM-dd', [Globalization.CultureInfo]::InvariantCulture)
            return ($dd.Date -lt (Get-Date).Date)
        })
        $blockedTasks = @($pendingTasks | Where-Object { $_ -ne $null -and $_.PSObject.Properties['blocked'] -and $_.blocked })

        $totalTasks += $pendingTasks.Count
        $totalCompleted += $completedTasks.Count

        # Calculate completion percentage
        $completionPct = if ($projectTasks.Count -gt 0) {
            [Math]::Round(($completedTasks.Count / $projectTasks.Count) * 100, 1)
        } else { 0 }

        # Status indicators
        $status = @()
        if ($overdueTasks.Count -gt 0) { $status += "⚠️$($overdueTasks.Count)" }
        if ($blockedTasks.Count -gt 0) { $status += "🔒$($blockedTasks.Count)" }

        $desc = if ((Pmc-HasProp $project 'description') -and $project.description) { [string]$project.description } else { '' }
        $descShort = $desc.Substring(0, [Math]::Min(30, $desc.Length))

        $rows += @{
            project = $project.name
            pending = $pendingTasks.Count
            completed = $completedTasks.Count
            completion = "$completionPct%"
            status = $status -join ' '
            description = $descShort
        }
    }

    $cols = @(
        @{ key='project'; title='Project'; width=20 },
        @{ key='pending'; title='Pending'; width=8; align='right' },
        @{ key='completed'; title='Done'; width=6; align='right' },
        @{ key='completion'; title='%'; width=6; align='right' },
        @{ key='status'; title='Issues'; width=10 },
        @{ key='description'; title='Description'; width=30 }
    )

    Show-PmcTable -Columns $cols -Rows $rows -Title 'PROJECTS OVERVIEW'

    # Show summary
    Write-PmcStyled -Style 'Title' -Text "`nSummary:"
    Write-PmcStyled -Style 'Body' -Text "  Active projects: $($rows.Count)"
    Write-PmcStyled -Style 'Body' -Text "  Total pending tasks: $totalTasks"
    Write-PmcStyled -Style 'Body' -Text "  Total completed tasks: $totalCompleted"

    # Show current focus
    $currentContext = Get-PmcCurrentContext
    if ($currentContext -and $currentContext -ne 'inbox') {
        Write-PmcStyled -Style 'Warning' -Text "  🎯 Current focus: $currentContext"
    }

    Write-PmcStyled -Style 'Muted' -Text "`nTip: Use 'focus set <project>' to focus on a specific project"

    Write-PmcDebug -Level 2 -Category "Views" -Message "Projects dashboard completed" -Data @{ ProjectCount = $rows.Count; TotalTasks = $totalTasks }
}

# Helper function to display task lists with consistent formatting
function Show-TaskListWithIndex {
    param(
        [array]$Tasks,
        [string]$Title,
        [switch]$ShowDaysOverdue,
        [switch]$ShowDaysUntil,
        [switch]$ShowBlockers
    )

    if ($Tasks.Count -eq 0) { return }

    Set-PmcLastTaskListMap @{}
    $rows = @()
    $i = 1

    foreach ($task in $Tasks) {
        if ($task -eq $null) { continue }
        $map = Get-PmcLastTaskListMap
        $map[$i] = $task.id
        Set-PmcLastTaskListMap $map

        $row = @{
            idx = "[$i]"
            text = (Pmc-GetProp $task 'text' '')
            project = (Pmc-GetProp $task 'project' 'inbox')
            pri = if ((Pmc-HasProp $task 'priority') -and $task.priority) { "p$($task.priority)" } else { '' }
        }

        if ($ShowDaysOverdue -and (Pmc-HasProp $task 'due') -and $task.due) {
            $daysOverdue = ((Get-Date).Date - [datetime]$task.due).Days
            $row.due = "$($daysOverdue)d ago"
        } elseif ($ShowDaysUntil -and (Pmc-HasProp $task 'due') -and $task.due) {
            $daysUntil = ([datetime]$task.due - (Get-Date).Date).Days
            $dayLabel = if ($daysUntil -eq 0) { "today" } elseif ($daysUntil -eq 1) { "tomorrow" } else { "${daysUntil}d" }
            $row.due = $dayLabel
        } elseif ((Pmc-HasProp $task 'due') -and $task.due) {
            $row.due = ([datetime]$task.due).ToString('MM/dd')
        } else {
            $row.due = ''
        }

        if ($ShowBlockers -and (Pmc-HasProp $task 'depends') -and $task.depends) {
            $row.blockers = ($task.depends -join ',')
        }

        $rows += $row
        $i++
    }

    $cols = @(
        @{ key='idx'; title='#'; width=5; align='right' },
        @{ key='text'; title='Task'; width=46 },
        @{ key='project'; title='Project'; width=15 },
        @{ key='pri'; title='Pri'; width=4 },
        @{ key='due'; title='Due'; width=10 }
    )

    if ($ShowBlockers) {
        $cols += @{ key='blockers'; title='Blocked By'; width=12 }
    }

    Show-PmcTable -Columns $cols -Rows $rows -Title $Title
    Show-PmcTip "Use 'task view <#>', 'task done <#>', 'task edit <#>'"
}

===== END FILE: module/Pmc.Strict/src/Views.ps1 =====

===== FILE LIST (2025-09-18T04:49:50Z) =====
pmc.ps1
start-pmc.ps1
config.json
tasks.json
module/Pmc.Strict/Pmc.Strict.psd1
module/Pmc.Strict/Pmc.Strict.psm1
module/Pmc.Strict/src/Aliases.ps1
module/Pmc.Strict/src/Analytics.ps1
module/Pmc.Strict/src/CommandMap.ps1
module/Pmc.Strict/src/Config.ps1
module/Pmc.Strict/src/DataDisplay.ps1
module/Pmc.Strict/src/Debug.ps1
module/Pmc.Strict/src/Dependencies.ps1
module/Pmc.Strict/src/Excel.ps1
module/Pmc.Strict/src/Execution.ps1
module/Pmc.Strict/src/Focus.ps1
module/Pmc.Strict/src/Help.ps1
module/Pmc.Strict/src/HelpUI.ps1
module/Pmc.Strict/src/ImportExport.ps1
module/Pmc.Strict/src/Interactive.ps1
module/Pmc.Strict/src/ProjectWizard.ps1
module/Pmc.Strict/src/Resolvers.ps1
module/Pmc.Strict/src/Review.ps1
module/Pmc.Strict/src/Schemas.ps1
module/Pmc.Strict/src/Security.ps1
module/Pmc.Strict/src/Shortcuts.ps1
module/Pmc.Strict/src/State.ps1
module/Pmc.Strict/src/Storage.ps1
module/Pmc.Strict/src/TaskEditor.ps1
module/Pmc.Strict/src/Theme.ps1
module/Pmc.Strict/src/Types.ps1
module/Pmc.Strict/src/UI.ps1
module/Pmc.Strict/src/UndoRedo.ps1
module/Pmc.Strict/src/Views.ps1
